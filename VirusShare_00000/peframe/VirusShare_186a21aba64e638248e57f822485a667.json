{
    "docinfo": {},
    "filename": "VirusShare_186a21aba64e638248e57f822485a667",
    "filesize": 163840,
    "filetype": "PE32 executable (console) Intel 80386, for MS Windows",
    "hashes": {
        "md5": "186a21aba64e638248e57f822485a667",
        "sha1": "406dfcbacf336abfeec0f1ab5d8f4b098552ff9e",
        "sha256": "b16282e730bc343955e772ea279a34c038ead26e52686c74649c8630f42ece2b"
    },
    "peinfo": {
        "behavior": [
            "DebuggerException__SetConsoleCtrl",
            "Check_OutputDebugStringA_iat",
            "anti_dbg",
            "Xor",
            "network_tcp_listen",
            "network_tcp_socket",
            "win_files_operation"
        ],
        "breakpoint": [
            "CloseHandle",
            "CreateFileA",
            "ExitProcess",
            "GetCommandLineA",
            "GetCurrentProcess",
            "GetModuleFileNameA",
            "GetProcAddress",
            "GetStartupInfoA",
            "HeapAlloc",
            "IsBadReadPtr",
            "IsBadWritePtr",
            "LoadLibraryA",
            "OutputDebugStringA",
            "ReadFile",
            "SetFilePointer",
            "TerminateProcess",
            "UnhandledExceptionFilter",
            "VirtualAlloc",
            "VirtualFree",
            "WSASocketA",
            "WSAStartup",
            "WriteFile",
            "closesocket",
            "sendto"
        ],
        "directories": {
            "debug": {},
            "export": [],
            "import": {
                "KERNEL32.DLL": [
                    {
                        "function": "TerminateProcess",
                        "offset": 4354480
                    },
                    {
                        "function": "GetLastError",
                        "offset": 4354484
                    },
                    {
                        "function": "GetCurrentProcess",
                        "offset": 4354488
                    },
                    {
                        "function": "SetFilePointer",
                        "offset": 4354492
                    },
                    {
                        "function": "LCMapStringA",
                        "offset": 4354496
                    },
                    {
                        "function": "SetEndOfFile",
                        "offset": 4354500
                    },
                    {
                        "function": "LCMapStringW",
                        "offset": 4354504
                    },
                    {
                        "function": "GetACP",
                        "offset": 4354508
                    },
                    {
                        "function": "GetCPInfo",
                        "offset": 4354512
                    },
                    {
                        "function": "GetOEMCP",
                        "offset": 4354516
                    },
                    {
                        "function": "CloseHandle",
                        "offset": 4354520
                    },
                    {
                        "function": "GetStringTypeW",
                        "offset": 4354524
                    },
                    {
                        "function": "RtlUnwind",
                        "offset": 4354528
                    },
                    {
                        "function": "GetCommandLineA",
                        "offset": 4354532
                    },
                    {
                        "function": "GetVersion",
                        "offset": 4354536
                    },
                    {
                        "function": "DebugBreak",
                        "offset": 4354540
                    },
                    {
                        "function": "GetStdHandle",
                        "offset": 4354544
                    },
                    {
                        "function": "WriteFile",
                        "offset": 4354548
                    },
                    {
                        "function": "InterlockedDecrement",
                        "offset": 4354552
                    },
                    {
                        "function": "OutputDebugStringA",
                        "offset": 4354556
                    },
                    {
                        "function": "GetProcAddress",
                        "offset": 4354560
                    },
                    {
                        "function": "LoadLibraryA",
                        "offset": 4354564
                    },
                    {
                        "function": "InterlockedIncrement",
                        "offset": 4354568
                    },
                    {
                        "function": "GetModuleFileNameA",
                        "offset": 4354572
                    },
                    {
                        "function": "SetHandleCount",
                        "offset": 4354576
                    },
                    {
                        "function": "GetFileType",
                        "offset": 4354580
                    },
                    {
                        "function": "GetStartupInfoA",
                        "offset": 4354584
                    },
                    {
                        "function": "IsBadWritePtr",
                        "offset": 4354588
                    },
                    {
                        "function": "IsBadReadPtr",
                        "offset": 4354592
                    },
                    {
                        "function": "HeapValidate",
                        "offset": 4354596
                    },
                    {
                        "function": "ExitProcess",
                        "offset": 4354600
                    },
                    {
                        "function": "HeapFree",
                        "offset": 4354604
                    },
                    {
                        "function": "CreateFileA",
                        "offset": 4354608
                    },
                    {
                        "function": "UnhandledExceptionFilter",
                        "offset": 4354612
                    },
                    {
                        "function": "FreeEnvironmentStringsA",
                        "offset": 4354616
                    },
                    {
                        "function": "FreeEnvironmentStringsW",
                        "offset": 4354620
                    },
                    {
                        "function": "WideCharToMultiByte",
                        "offset": 4354624
                    },
                    {
                        "function": "GetEnvironmentStrings",
                        "offset": 4354628
                    },
                    {
                        "function": "GetEnvironmentStringsW",
                        "offset": 4354632
                    },
                    {
                        "function": "HeapDestroy",
                        "offset": 4354636
                    },
                    {
                        "function": "HeapCreate",
                        "offset": 4354640
                    },
                    {
                        "function": "VirtualAlloc",
                        "offset": 4354644
                    },
                    {
                        "function": "VirtualFree",
                        "offset": 4354648
                    },
                    {
                        "function": "SetConsoleCtrlHandler",
                        "offset": 4354652
                    },
                    {
                        "function": "HeapAlloc",
                        "offset": 4354656
                    },
                    {
                        "function": "HeapReAlloc",
                        "offset": 4354660
                    },
                    {
                        "function": "FlushFileBuffers",
                        "offset": 4354664
                    },
                    {
                        "function": "SetStdHandle",
                        "offset": 4354668
                    },
                    {
                        "function": "ReadFile",
                        "offset": 4354672
                    },
                    {
                        "function": "MultiByteToWideChar",
                        "offset": 4354676
                    },
                    {
                        "function": "GetStringTypeA",
                        "offset": 4354680
                    }
                ],
                "WS2_32.dll": [
                    {
                        "function": "htons",
                        "offset": 4354768
                    },
                    {
                        "function": "WSASocketA",
                        "offset": 4354772
                    },
                    {
                        "function": "setsockopt",
                        "offset": 4354776
                    },
                    {
                        "function": "sendto",
                        "offset": 4354780
                    },
                    {
                        "function": "inet_addr",
                        "offset": 4354784
                    },
                    {
                        "function": "htonl",
                        "offset": 4354788
                    },
                    {
                        "function": "WSAStartup",
                        "offset": 4354792
                    },
                    {
                        "function": "closesocket",
                        "offset": 4354796
                    },
                    {
                        "function": "WSACleanup",
                        "offset": 4354800
                    }
                ]
            },
            "relocations": {
                "Size": 0,
                "VirtualAddress": 0,
                "count": 0,
                "details": {}
            },
            "resources": [],
            "sign": {},
            "tls": {
                "AddressOfCallBacks": 65535,
                "AddressOfIndex": 4,
                "Characteristics": 0,
                "EndAddressOfRawData": 3,
                "SizeOfZeroFill": 184,
                "StartAddressOfRawData": 9460301
            }
        },
        "dll": false,
        "entrypoint": 10704,
        "features": {
            "antidbg": [
                "GetLastError",
                "OutputDebugStringA",
                "TerminateProcess",
                "UnhandledExceptionFilter"
            ],
            "antivm": {},
            "crypto": [],
            "mutex": [],
            "packer": [
                "Microsoft_Visual_Cpp_v50v60_MFC_additional",
                "Microsoft_Visual_Cpp_50",
                "Microsoft_Visual_Cpp_v50v60_MFC",
                "Install_Shield_2000",
                "Microsoft_Visual_Cpp",
                "InstallShield_2000_additional"
            ],
            "xor": {}
        },
        "imagebase": 4194304,
        "imphash": "143533bc45f477c8754d1d7cb53e895e",
        "metadata": {},
        "sections": {
            "count": 5,
            "details": [
                {
                    "characteristics": 1610612768,
                    "data": "b'\\xcc\\xcc\\xcc\\xcc\\xcc\\xe9\\x86\\x01\\x00\\x00\\xe9\\xb1",
                    "entropy": 5.9979984259398815,
                    "executable": true,
                    "hash": {
                        "md5": "df0f4715665520bf53f1e179410b0d65",
                        "sha1": "3143c307c3ddb22ec0c36cdc743c83bd81ff663f",
                        "sha256": "099419b0ccaf0d7eff03666b7afdbccf3444ecee38c3864f2a8b9a2bfe2b4474"
                    },
                    "section_name": ".text",
                    "size_of_raw_data": 135168,
                    "virtual_address": 4096,
                    "virtual_size": 134400
                },
                {
                    "characteristics": 1073741888,
                    "data": "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00",
                    "entropy": 3.8198359441287613,
                    "executable": false,
                    "hash": {
                        "md5": "71b5fb4ade980b6136bcc0a044ce3f48",
                        "sha1": "eb967a51075c170485e42e47d3e76d253a357763",
                        "sha256": "dbbc638a5809eaa579977b6ca95424781c8121ba9f96296165915a4ebb75e70b"
                    },
                    "section_name": ".rdata",
                    "size_of_raw_data": 8192,
                    "virtual_address": 139264,
                    "virtual_size": 5960
                },
                {
                    "characteristics": 3221225536,
                    "data": "b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00",
                    "entropy": 0.7376548801021799,
                    "executable": false,
                    "hash": {
                        "md5": "9d2e0ec55b4751188960df7b7351e0eb",
                        "sha1": "866a35d4d9f1c28b19ba7a8afb3126b9ecc4751b",
                        "sha256": "6db1d5ad2781e14dbfd356ff1c14fe91c42d261163c5cca8bcca0eb76ba59d1a"
                    },
                    "section_name": ".data",
                    "size_of_raw_data": 8192,
                    "virtual_address": 147456,
                    "virtual_size": 12132
                },
                {
                    "characteristics": 3221225536,
                    "data": "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00",
                    "entropy": 1.9368139356934948,
                    "executable": false,
                    "hash": {
                        "md5": "97e74bf054ed08599f2ae825959d9476",
                        "sha1": "7a9df87acc9067e6e7a9c67497deb9b496d822ec",
                        "sha256": "b17bfc0bd7e8f5583080219c4b82a6cbe72c0ec30abbe61d28a7be7ef38f66a3"
                    },
                    "section_name": ".idata",
                    "size_of_raw_data": 4096,
                    "virtual_address": 159744,
                    "virtual_size": 2078
                },
                {
                    "characteristics": 1107296320,
                    "data": "b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00",
                    "entropy": 0.0,
                    "executable": false,
                    "hash": {
                        "md5": "620f0b67a91f7f74151bc5be745b7110",
                        "sha1": "1ceaf73df40e531df3bfb26b4fb7cd95fb7bff1d",
                        "sha256": "ad7facb2586fc6e966c004d7d1d16b024f5805ff7cb47c7a85dabd8b48892ca7"
                    },
                    "section_name": ".reloc",
                    "size_of_raw_data": 4096,
                    "virtual_address": 163840,
                    "virtual_size": 3675
                }
            ]
        },
        "timestamp": "2003-10-18 11:36:07"
    },
    "strings": {
        "dump": [
            "L!This program cannot be run in DOS mode.",
            "\u017f'>ImImIm",
            "GmImiCmImZmImHmImiBmImRichIm",
            ".text",
            "`.rdata",
            "@.data",
            ".idata",
            ".reloc",
            "SVW,u",
            "t-lPh4 B",
            "hpJB",
            "t-lRh",
            "hpJB",
            "3_^[",
            "]Ujh B",
            "SVWJ",
            "<<u6",
            "Ph B",
            "hpJB",
            "E}u6",
            "Ph B",
            "hpJB",
            "E}u'",
            "Php B",
            "hpJB",
            "\u0185 \u0185!",
            "$hd B",
            "h9h7(",
            "hT B",
            "(f\u01c5\"",
            "h9h7(",
            "RdP\t",
            "j XQ",
            "RXP\t",
            "QlR\t",
            "EP+\t",
            "j(XQT",
            "RXP[\t",
            "QlRC\t",
            "hP B",
            "j(XR<P",
            "E\u060b@Q",
            "_^[@",
            "]UDSVW}",
            "\u0449UE_^[]U@SVW}",
            "hL\"B",
            "h$\"B",
            "hL\"B",
            "Ph!B",
            "Qhh!B",
            "RhL!B",
            "Ph,!B",
            "_^[@;{",
            "]U@SVW}",
            "Qh\"B",
            "Ph\"B",
            "Ph\"B",
            "Pht\"B",
            "_^[@;",
            "]%(rB",
            "SVWE",
            "3\u0245u\u0583}",
            "3\u0485u\u058bE",
            "EMQ.",
            "EURE",
            "PMQ7",
            "EUREPd",
            "E_^[]UQ=`oB",
            "=`oB",
            "\u01c1@JB",
            "\ubb4b]UJ",
            "PRSVWh4#B",
            "h0#B",
            "j*h #B",
            "_^[ZX]U",
            "SVW}",
            "3u\u058bM",
            "EMQeI",
            "$\u03cbMA",
            "_^[]\u030bT$",
            "tG3D$",
            "GJuD$",
            "UWVu",
            "r)$x!@",
            "r$x!@",
            "r$x!@",
            "r$x!@",
            "DDDDDDDDDDDDDD",
            "$x!@",
            "t1|9",
            "SVW}",
            "h$$B",
            "3u\u058bM",
            "EEEE_^[]UE",
            "=0OB",
            "MM}-t",
            "=0OB",
            "URmH",
            "t%Ek",
            "\ub903}-u",
            "E]UE",
            "V=0OB",
            "MM}-t",
            "=0OB",
            "UREG",
            "EPMQG",
            "\ub383}-u",
            "EU^]U",
            "SVWE",
            "j6h4$B",
            "3\u0245uhPJB",
            "EURE",
            "PhPJB",
            "EhPJB",
            "E_^[]U",
            "SVW}",
            "j5hx$B",
            "3u\u058bM",
            "hd$B",
            "j6hx$B",
            "3u\u0483}",
            "hT$B",
            "j7hx$B",
            "3\u0245u\u058bU",
            "h@$B",
            "j8hx$B",
            "EE_^[]Uj@E",
            "]USVWUj",
            "]_^[]",
            "SVWD$",
            "D$ X",
            "t.;t$$t(4v",
            "_^[3d",
            "SQLB",
            "SQLB",
            "VC20XC00U",
            "SVWU]",
            "EECs",
            "tEVUk",
            "t3x<{",
            "]_^[]UL$",
            "Ujh$B",
            "SVWe",
            "EUR;",
            "UEPMQG",
            "eUR;",
            "_^[]U=UB",
            "]U=UB",
            "SVW}",
            "jAh$B",
            "3u\u058bM",
            "}PJB",
            "}pJB",
            "M<UB",
            "uZj^h$B",
            "E<UB",
            "_^[]UQSVW}",
            "t!h$B",
            "3u\u034bM",
            "tIUB",
            "t8MQ;",
            "MQI;",
            "_^[]U",
            "SVWE",
            "M\u0603 |",
            "pUEM",
            "UE\u8245ll",
            "l$9@",
            "tXRE",
            "U\u0605u!h@%B",
            "h4%B",
            "3u\u044dQU",
            "M\u0609hh hh",
            "wHh39@",
            "M\u0603*u3U",
            "U\u0603*u'E",
            "M\u0609ddIdd.wld3",
            "6u U",
            " E\tM",
            "U\u0609``C``5",
            "`3\u024al:@",
            "$0:@",
            "fEfMQRO",
            "UEPN",
            "t 3f",
            "\u01cb+UUZ}",
            "\u024b+MMb",
            "U\u0600 U\u060bE",
            "U\u0603gu",
            "EPMQR",
            "U\u0603gu",
            "UEP L",
            "M@M\u01c5",
            "\u01850QE",
            "U tHE@t",
            "?E@t",
            "3\u0249U@t>",
            "RPRPEK",
            "0RPQRJ",
            "ERM+MM\u070bU",
            "E@tOM",
            "+M+MU",
            "QRj ",
            "QURP",
            "QRj0",
            "EM\u0709|||",
            "|tmf",
            "fZfZPxQ",
            "QtRxP)",
            "REPMQ",
            "QRj ",
            "_^[]@.@",
            "]UQE",
            "UEPM",
            "\ubf8b]UE",
            "A]UE",
            "fA]U",
            "]UQ}",
            "E]UQ}",
            "E]UQ",
            "E]U,0",
            "Ph%B",
            "t7PM",
            "QR~J",
            "PQxJ",
            "tBPM",
            "Rht%B",
            "t;QRE",
            "3_]U8",
            "u%hl'B",
            "h`'B",
            "(3uh",
            "hH'B",
            "EMQ?",
            "@v)URs?",
            "hD'B",
            "tIR5?",
            "@v5P!?",
            "hD'B",
            "\u01c50#B",
            "\u01c50#B",
            "\u01c50#B",
            "\u01c50#B",
            "\u01c50#B",
            "\u01c50#B",
            "\u01c50#B",
            "\u01c50#B",
            "\u01c50#B",
            "\u01c50#B",
            "RPQRPQRPQREPM",
            "RhL&B",
            "h(&B",
            "3]Ulh",
            "MZUE",
            "MU;U}eE8tXM",
            "\u0409MUE",
            "\u0483UEP",
            "E}tXMQ",
            "tEUE",
            "]UQE",
            "E}@}2M<ZB",
            "\ubfcb]Uj",
            "RpWB",
            "]UQE",
            "\ubf8b]Uj",
            "SVWE",
            "u!hx(B",
            "hl(B",
            "3\u0245u\u040b",
            "REPM",
            "Qh4(B",
            "3\u0485u&h",
            "3u3(",
            "$v,M",
            "Qh'B",
            "3\u0485u3",
            "t&h'B",
            "3\u0485u\u068bE",
            "$EMQnH",
            "PM Q",
            "E _^[]Uj",
            "t(UUE",
            "EM;Ms",
            "EE]Uj",
            "]UQj",
            "EE]U",
            "SVWE",
            "u!hx(B",
            "hl(B",
            "3\u0245u\u040b",
            "REPM",
            "Rh)B",
            "3u&h)B",
            "3\u0245u3",
            "Rh)B",
            "t&h'B",
            "3u\u068bM",
            "u!h|)B",
            "hl(B",
            "3\u0485u\u024bE",
            " EMy",
            "t>Uz",
            "u\tEx",
            "t!h4)B",
            "hl(B",
            "3\u0245udUB",
            ";t!h(B",
            "hl(B",
            "3\u0485u}",
            "$PMQlD",
            "$REPC",
            "uVUUB",
            "M MUE",
            "v$MU",
            "M;Mt!h(B",
            "hl(B",
            "3\u0485u\u014bE;Et",
            ";Et!h(B",
            "hl(B",
            "3\u0245u\u03cbUB",
            ";Et!h(B",
            "hl(B",
            "3\u0245u\u03cbU",
            "E_^[]Uj",
            "]UQj",
            "EE]Uj",
            "]UQSVW",
            "u!hx(B",
            "hl(B",
            "3\u0245u\u0403}",
            "u+h<+B",
            "3\u0245uM",
            "u!h|)B",
            "hl(B",
            "3u\u024bM",
            " MUB",
            "tCMy",
            "t:UB",
            "t*My",
            "hl(B",
            "uCE PMQ",
            "Rh*B",
            "uCE PMQ",
            "Rh*B",
            "3uMy",
            "ulUz",
            "u\tEx",
            "t!h|*B",
            "hl(B",
            "3\u0245u\u010bUB",
            "$P3\u024a",
            "t!h\\*B",
            "hl(B",
            "3\u0245u\u038bUUB",
            ";Mt!hD*B",
            "hl(B",
            "3\u0485u\u038bEH",
            ";Mt!h,*B",
            "hl(B",
            "3\u0485u\u038bE",
            "$P3\u024a",
            "QU RN",
            "_^[]Uj",
            "u!hx(B",
            "hl(B",
            "3\u0245u\u040bU",
            "u!h|)B",
            "hl(B",
            "3u\u024bM",
            " MUB",
            "tCMy",
            "t:UB",
            "t*My",
            "hl(B",
            "3\u0485uEx",
            "t2UB",
            "t!h\\*B",
            "hl(B",
            "3\u0245u\u038bUB",
            "EE_^[]UQ",
            "E]UQSVWE",
            " MUB",
            "tCMy",
            "t:UB",
            "t*My",
            "hl(B",
            "3\u0485uEM",
            "_^[]UQPB",
            "E]UQSVWE",
            ";tAE",
            "3\u048aQRE",
            "PhX+B",
            "3\u0245uE",
            "\ub40bE_^[]U",
            "SVWE",
            "E$[@",
            "3\u0485uvhd,B",
            "3uNh@,B",
            "3\u0245u&h",
            "3\u0485u3",
            "t#Uz",
            "t\tUz",
            "u:U REH",
            "QURh*B",
            "u:E PMQ",
            "REPh*B",
            "3\u0245uE",
            "uPEH",
            "RE P",
            "u/M Qh+B",
            "3\u0485uE",
            "uvEx",
            "t3MQ",
            "QURh+B",
            "3u\u034bMQ",
            "RE PMQh+B",
            "3\u0485uE",
            "E_^[]@Y@",
            "E]UQ",
            "t$MQ",
            "PM QU",
            "\u038b]UQ}",
            "E]UQ}",
            " Q{9",
            " REP9",
            "]UQE",
            " MUB",
            "t\"My",
            "t\tMy",
            "tSMQ",
            "uHEH",
            "3]UQZB",
            "SVW}",
            "u+h,B",
            "|fMQ",
            "}UEH",
            "%URh,B",
            "3uOM",
            "H0_^[]U",
            "SVWE",
            "3u\u068bE",
            "A,+B,M",
            "J0+H0U",
            "E_^[]U",
            "SVWE",
            "3u\u0683}",
            "t-EH",
            "u*UB",
            "3\u0245u/UB",
            "Rh-B",
            "3u\u044bMQ",
            "Rh-B",
            "3u\u060bMQ",
            "uqEH",
            "PM Qh-B",
            "QU R",
            "u=UB",
            "PM Qh-B",
            "3\u0485u\u044bEP",
            "uJEH",
            "PM Qh\\-B",
            "hD-B",
            "3\u0245u_^[]U\\SVWE",
            "UB E=0OB",
            "Rh8.B",
            "EPMQh(.B",
            "3\u0485u_^[]U4SVWEP",
            "t7h@.B",
            "3\u0485uj",
            "3_^[]UQSVW}",
            "Rh.B",
            "3u\ubb4bM",
            "Q,Rhx.B",
            "3u\u060bM",
            "Q0RhX.B",
            "3u_^[]U",
            "qE]U=ZB",
            "]UQ=8VB",
            "uG=ZB",
            "h$GB",
            "h,IB",
            "h(HB",
            "=<VB",
            "uzEH",
            "tjUE",
            "~VUREH",
            ";Eu!MQ",
            "EEMQ",
            "E]Uj",
            "SVW}",
            "jih.B",
            "3u\u058bM",
            "t\tMy",
            "u0UB",
            "uSMy",
            "t!UB",
            "u'UB",
            "_^[]U",
            "MQUREPj",
            "]\u030bD$",
            "u\tD$",
            "S\u060bD$",
            "U$SVW|WB",
            "jGh.B",
            "3\u0245u\u0583}",
            "hT$B",
            "jHh.B",
            "3\u0485u\u0583}",
            "jIh.B",
            "3u\u058bM",
            "U}at1}rt",
            "M\u070bU\u0703+U\u0703}I",
            "M3uq@",
            "$Mq@",
            "EMMU\u0280UE$E",
            "\tU\u0380U",
            "\tM@M",
            "M Me}",
            "UDE%",
            "M$U@t\tE",
            "QURE",
            "UEMH",
            "E_^[]{o@",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t",
            "\t\t\t\t\t\t\t\t\t\t\t\t\t",
            "\t\t\t\t\t\t\t\t\t\t",
            "\t\t\t\t\t",
            "ME>jUh.B",
            "t;MA",
            "t\tMy",
            "\u01c2HOB",
            "]UQE@OB",
            "=t\tU",
            "Ujmh.B",
            "tfMQF",
            "=tGjyh.B",
            "hDVB",
            "EMMUREPj",
            "UREPMU",
            "PMQUR#",
            "\"tzU",
            "tpM3\u048a",
            "3AYB",
            "\"u\tU",
            "3\u048aAYB",
            "\"uQE3\u04b9",
            "UEEMU",
            "Ut$}",
            "tTU3",
            "3\u024aAYB",
            "3\u024aAYB",
            "=HWB",
            "=HWB",
            "EEM3f",
            "EM3f",
            "E\u050bM+M",
            "UREPj",
            "EPMQUREPj",
            "=HWB",
            "E\u060bM+M",
            "3%MQUREP",
            "3]Uj",
            "=lZB",
            "]U=UB",
            "u2=LB",
            "=LWB",
            "SVWE",
            "\u0303=UB",
            "uB=LB",
            "hH'B",
            "UEP-",
            "<v,Q",
            "hD'B",
            "PRe\t",
            "EPPQb\t",
            "PRN\t",
            "QPR4\t",
            "_^[]UQE",
            "3]UE",
            "@]\u030bL$",
            "tAt2t$",
            "\u034dAL$",
            "E]SVD$",
            "3\u060bD$",
            "A\u020b\\$",
            "N3\u048b^[",
            "3P\u020b\\$",
            "SVW}",
            "jih 2B",
            "3u\u058bM",
            "tJMA",
            "UUEH",
            "u.}PJB",
            "t\t}pJB",
            "}!h1B",
            "h 2B",
            "3u\u028bMU",
            "MQUB",
            "PMQR0",
            "EF}t",
            "QUR/",
            "EE;Et",
            "_^[]U}",
            "EM;Mr\u030b]UQ}",
            "]UQ}",
            "3QPU",
            "3RQE",
            "EM;Mr\u030b]",
            "]U0SVWEE\u070dM",
            "h82B",
            "j]h,2B",
            "3\u0485u\u0583}",
            "j^h,2B",
            "3u\u058bMA",
            "PMQ\u88a4",
            "E\u060bU\u070bB",
            "|\"E\u070b",
            "U\u040bE\u070b",
            "E\u040bE_^[]W|$",
            "tAt#t",
            "tt4t'",
            "_U,SVWEE\u0703}",
            "h82B",
            "jZhH2B",
            "3\u0245u\u0583}",
            "j[hH2B",
            "3\u0485u\u058bE@",
            "REP\u8e22",
            "E\u060bM\u070bQ",
            "|\"U\u070b",
            "M\u050bU\u070b",
            "E\u050bE_^[]Q=",
            "s+\u020b\u0105",
            "u7=`WB",
            "w^E3\u048a\u078c@",
            "8TWB",
            "u*UE",
            "EPWB",
            "ETWB",
            "wrE3\u048a",
            "EPWB",
            "UWETWB",
            "MFEXWB",
            "E5E\\WB",
            "u+@VB",
            "\u01c2HOB",
            "E@VB",
            "UQE@OB",
            "=dWB",
            "hx2B",
            "=dWB",
            "3lhh2B",
            "hT2B",
            "=hWB",
            "=lWB",
            "]\u030bL$",
            "WtzVS\u064bt$",
            "GIt%t)",
            "Gt/KuD$",
            "GKu[^D$",
            "t\u0784t,t",
            "[^_UQtWB",
            "E]UtWB",
            "]UQtWB",
            "]UpWB",
            "]UQ}",
            "\ubecb]UQE",
            "PMQ8",
            "UE.}",
            "REPt",
            "MU;U",
            "MURE",
            "PMQ-",
            "UE;E",
            "UEPM",
            "QUR\u8b4b",
            "PMQ}",
            "u\t=pWB",
            "n]UQ}",
            "]UQE",
            "EE]U]U\uc844PB",
            "]Uh@",
            "=hZB",
            "UE;Es%MU",
            "E3]U",
            "#\u0405u E",
            "E]U<E",
            "U\u0409U\u020bE\u020b",
            "MUBEM",
            "U\u0703}?v",
            "E\u020bM\u020bP",
            "} s_",
            "M\u040bMU\u010bLD#\u020bUE\u0109LDM",
            "kM\u0703 ",
            "\u048bEM\u010b",
            "UU\u040bE",
            "E\u0603}?v",
            "U+UU\u030bE",
            "E\u0503}?v",
            "MM\u040bU",
            "U\u0603}?v",
            "M\u030bU\u030bA",
            "} s_",
            "M\u048bEM\u010bDD#",
            "MU\u0109DDE",
            "kM\u0503 ",
            "\u040bMU\u010b",
            "#\u020bUE\u0109",
            "E\u0309EM",
            "UEMQ",
            "} s[M",
            "MMU\u010bLD",
            "\u020bUE\u0109LDgM",
            "\u020bUE\u0109",
            "E\u040bM\u0409HU",
            "=`ZB",
            "R`ZB",
            "EXZB",
            "]U8VdZB",
            "\u0209M\u050bU",
            "E} }",
            "M E\u030b",
            "MU;Us$EM#",
            "UE#B",
            "M\u050bU;U",
            "s$UE#",
            "MU#Q",
            "E\u044bM;",
            "U;Us",
            "MU;UuIhZB",
            "E\u07cbM;",
            "M\u020bU\u020b",
            "E\u0403}t#M\u040bU\u020bE#DDM\u040bU\u020bu#",
            "\u0185u5E",
            "E\u040bM\u020bU#TDE\u040bM\u020bu#",
            "U\u048bEi",
            "E\u040bM\u020bU#TDU}",
            "E\u040bM\u020bU#",
            "MUEL",
            "+E\u0609EM",
            "M}?~",
            "} }_",
            "M\u040bM\u040bU\u020bLD#\u020bU\u040bE\u0209LDM",
            "\u048bE\u040bM\u020b",
            "M\u040bU\u0209",
            "#\u028bUJ",
            "\u0409MUEH",
            "} }ZE",
            "ME\u040bM\u020bDD",
            "M\u040bU\u0209DDfE",
            "E\u040bM\u020b",
            "M\u040bU\u0209",
            "UEBM",
            "MMU\u0603",
            "U\u0609JE",
            "u E;",
            "U\u020bE\u0409",
            "^]UQdZB",
            "\u0209MhA",
            "E]U,E",
            "MMU\u0603",
            "E}?} MU",
            "\u0289EMUQ",
            "UE;Ew]MA",
            "EMUQ",
            "EMUQ",
            "E\u060bMDD",
            "U\u060bE\u01c4",
            "QCE\u050aHC",
            "E\u0508HCu",
            "E\u060b]U0E",
            "E\u0609E\u050bM\u050b",
            "UE;E",
            "U9U~",
            "E}?v",
            "M\u050bU\u050bA",
            "} s_",
            "M\u048bEM\u040bDD#",
            "MU\u0409DDE",
            "\u040bMU\u040b",
            "#\u020bUE\u0409",
            "E+EE}",
            "MM\u050bU",
            "U}?v",
            "UE\u050bMQ",
            "E\u050bMH",
            "UE\u0509B",
            "M\u050bU\u050bA",
            "} s[M",
            "MMU\u040bLD",
            "\u020bUE\u0409LDgM",
            "\u020bUE\u0409",
            "EMHU",
            "UUE+EE\u060bM",
            "M\u0703}?v",
            "E}?v",
            "M\u050bU\u050bA",
            "} s_",
            "M\u048bEM\u040bDD#",
            "MU\u0409DDE",
            "\u040bMU\u040b",
            "#\u020bUE\u0409",
            "EE\u060bM",
            "M\u0703}?v",
            "\u0409MUEH",
            "} sZE",
            "MEM\u040bDD",
            "MU\u0409DDfE",
            "U\u060bE\u0609B",
            "]UQ=`ZB",
            "ud=dZB",
            "~[`ZB",
            "+Q`ZB",
            "\u0449U\u058bE;u",
            "tn} }2",
            "E\uc2cd;t",
            "U\udbec\udd60;LDu",
            "EMM;",
            ",3]U0SVWEE\u070dM",
            "h82B",
            "j]h,2B",
            "3\u0485u\u0583}",
            "j^h,2B",
            "3u\u058bMA",
            "REPz",
            "E\u060bM\u070bQ",
            "|\"U\u070b",
            "M\u040bU\u070b",
            "E\u040bE_^[]U",
            "SVWEE",
            "jwh2B",
            "3\u0245u\u058bUB",
            "t[MQ\u0674",
            "EURj ",
            "}\tE$Uz",
            "E_^[]UQE",
            "EE]U ",
            "UE+=",
            "}_U+U",
            "QU+RQU",
            "EM+9}",
            "\tE+]UQE",
            "M}-s#UE",
            "M<ZB",
            "9Es6M",
            "|jyh2B",
            "t[MU",
            "E]UQE",
            "<uh=LB",
            "]UQE",
            "<tc=LB",
            "t\tM MU",
            "U\\E}u",
            "PMQ]",
            "E]U E",
            "HtlU",
            "PMQU",
            "MUUE",
            "@u1M",
            "t!UE",
            "9EsGM",
            "ME;E",
            "MU+U",
            "UE]UQSVW}",
            "j.h2B",
            "Uj;h2B",
            "_^[]Ujh2B",
            "SVWe=xWB",
            "uOEPj",
            ",MQj",
            "=xWB",
            "=xWB",
            "$e\u0509eM\u0509M\u070bURj",
            "EP8]",
            "3CMQURE",
            "PMQURE",
            "3e\u020bMd",
            "_^[]U",
            "MUBEE",
            "MQj@U",
            "]UHE",
            "t\tM\u0200\u0240M\u020bU",
            "M}0w6E3\u048a",
            "t3U}",
            "tCJ}",
            "E\u050bM\u0503",
            "M\u050bU\u050bBEE",
            "\u044bU#\u0441",
            "M\u060bU\u0301",
            "t\tM\u0600",
            "U8E}u",
            "EPMQUREPMQU",
            "u!MQ",
            "U\u0200@U",
            "E\u020bMQUR",
            "jURC",
            "E\u0103}u\"=UB",
            "MQUR",
            "u&MQURu",
            "E\u0103}u",
            "E\u0203Hu;M",
            "E]L@",
            "Ek0QB",
            "E\u0180@YB",
            "s{Uk0E",
            "UE3\u024a",
            "tMU3B",
            "tAM3\u048a",
            "U\tE\u0703",
            "E\u070bM3\u048aQ",
            "E\u070bMAYB",
            "E\u0708AYB",
            "Mk0UEfAQB",
            "U0XB",
            "U\u0182@YB",
            "MM\tU\u0603",
            "U\u060bE3\u024a",
            "tGU3B",
            "t;M3\u048a",
            "U\tE\u0703",
            "E\u070bM3\u048aQ",
            "E\u070aAYB",
            "U\u0708AYB",
            "M\u070aAYB",
            "E\u0708AYB",
            "E0XB",
            "]UQE",
            "w.E3\u048a",
            "M\u0181@YB",
            "E0XB",
            "\u0185 U\tE",
            "EM3\u048a",
            "t@E3\u024a",
            "E3\u024aH",
            "t6AYB",
            "Y3fE",
            "t5AYB",
            " AYB",
            "\u0182@XB",
            "Ar;Zw2AYB",
            " @XB",
            "Qar;zw2AYB",
            " AYB",
            " @XB",
            "\u0182@XB",
            "G]U=<XB",
            "3]U=ZB",
            "]UWVu",
            "r)$h@",
            "r$h@",
            "r$h@",
            "r$h@",
            "DDDDDDDDDDDDDD",
            "t1|9",
            "^_UQVE",
            "3^]USVW}",
            "h$$B",
            "j0h2B",
            "3u\u058bM",
            "_^[]U$",
            "3SVW\u01c5",
            "}!h2B",
            "u!=UB",
            "CURE",
            "_^[]Ujh2B",
            "SVWe=WB",
            "RE P",
            "$\u87f2e\u0409eM\u0409ME",
            "UREPM",
            "MQURE",
            "t8E;E",
            "REPMQU",
            "M\u0609ME",
            "$\u8a71e\u0309eU\u0309UE",
            "EPMQUREPM",
            "EPMQh ",
            "390j",
            "QUREPh ",
            "3eMd",
            "_^[]U",
            "]UQE",
            "]%qB",
            "% rB",
            "%$rB",
            "%4rB",
            "%8rB",
            "%<rB",
            "%@rB",
            "%DrB",
            "%HrB",
            "%LrB",
            "%PrB",
            "%,rB",
            "%XrB",
            "%\\rB",
            "%`rB",
            "%drB",
            "%TrB",
            "%hrB",
            "%lrB",
            "%prB",
            "%trB",
            "%xrB",
            "%0rB",
            "BOOLEAN",
            "u_char",
            "ULONG",
            "SECURITY_CONTEXT_TRACKING_MODE",
            "size_t",
            "USHORT",
            "FLOAT",
            "LPBOOL",
            "WIN_TRUST_SUBJECT",
            "BYTE",
            "MCIERROR",
            "LPSTR",
            "wchar_t",
            "UINT",
            "MCIDEVICEID",
            "HPSTR",
            "LPARAM",
            "WPARAM",
            "PVOID64",
            "FILEOP_FLAGS",
            "BSTR",
            "SCODE",
            "PROPID",
            "KSPIN_LOCK",
            "LCTYPE",
            "LPMENUTEMPLATEA",
            "va_list*",
            "main",
            "argc",
            "argv",
            "\tErrorCode",
            "wsaData",
            "SendThread",
            "$L43377",
            "ipe.",
            "static void process_signal(void)",
            "  int fd, command;",
            "  int magic = 0;",
            "  /* open the firewall named input pipe */",
            "  if ((fd = open(IPIPE, O_RDONLY)) < 0)",
            "    crit_error(\"Cannot open the firewall input pipe!\");",
            "  /* get command from the pipe */",
            "  if (read(fd, &magic, sizeof(magic)) < 0)",
            "    crit_error(\"Cannot read from the firewall input pipe!\");",
            "  if (magic == SF_CMD_DAEMON_MAGIC) {",
            "    if (read(fd, &command, sizeof(command)) < 0)",
            "      crit_error(\"Cannot read from the firewall input pipe!\");",
            "    switch (command) {",
            "      case SF_CMD_DAEMON_RULES:",
            "\tdaemon_write_rules(fd);",
            "\tbreak;",
            "      case SF_CMD_DAEMON_TCPKILL:",
            "\tdaemon_kill_tcp(fd);",
            "\tbreak;",
            "      case SF_CMD_DAEMON_FLUSH_ALL:",
            "\tdaemon_flush_all();",
            "\tbreak;",
            "      case SF_CMD_DAEMON_RESETUSAGE:",
            "\tdaemon_resetusage();",
            "\tbreak;",
            "      default:",
            "\tcrit_error(\"Unknown command in firewall input pipe!\");",
            "\tbreak;",
            "    }",
            "  else",
            "    crit_error(\"Unknown magic command in firewall input pipe!\");",
            "  close(fd);",
            " * Fork process and write configuration data to named pipe.",
            " * This function fork()s and thereby provides a `snapshot'.",
            "static void daemon_write_rules(int ifd)",
            "  if (fork() == 0) {\t\t/* child */",
            "    int i, fd;",
            "    struct sf_fw *r;",
            "    struct sf_fw rt;",
            "    close(ifd);",
            "    prepare_for_exec();\t\t/* not really, but we want to close all files */",
            "    /* open the firewall named output pipe */",
            "    if ((fd = open(OPIPE, O_WRONLY)) < 0)",
            "      exit(2);\t\t\t/* silent failure */",
            "    /* write usage since */",
            "    write(fd, &usage_since, sizeof(usage_since));",
            "    /* write the address array */",
            "    write(fd, &sf_addr_free, sizeof(sf_addr_free));",
            "    write(fd, sf_addr, sizeof(sf_addr));",
            "    /* write all rules */",
            "    for (r = prio_rules; r != NULL; r = r->fw_next) {",
            "      memcpy(&rt, r, sizeof(rt));",
            "      if (r->level.ptr != NULL)",
            "\trt.level.num = r->level.ptr->n_level;",
            "      write(fd, &r, sizeof(r));",
            "      write(fd, &rt, sizeof(rt));",
            "    }",
            "    for (r = rules; r != NULL; r = r->fw_next) {",
            "      memcpy(&rt, r, sizeof(rt));",
            "      if (r->level.ptr != NULL)",
            "\trt.level.num = r->level.ptr->n_level;",
            "      write(fd, &r, sizeof(r));",
            "      write(fd, &rt, sizeof(rt));",
            "    }",
            "    write(fd, &r, sizeof(r));",
            "    /* write variables and values */",
            "    write(fd, &sf_var_free, sizeof(sf_var_free));",
            "    write(fd, variables, sizeof(variables));",
            "    for (i = 0; i < SF_VAR_CNT_MAX; i++) {",
            "      struct variable *v;",
            "      v = variables[i].next;",
            "      while (v != NULL) {",
            "\twrite(fd, &v, sizeof(v));",
            "\twrite(fd, v, sizeof(*v));",
            "\tv = v->next;",
            "      }",
            "      write(fd, &v, sizeof(v));",
            "    }",
            "    for (i = 0; i < SF_VAR_CNT_MAX; i++) {",
            "      if (varnames[i] == NULL)",
            "\twrite(fd, &(varnames[i]), sizeof(char));",
            "      else",
            "\twrite(fd, varnames[i], strlen(varnames[i]) + 1);",
            "    }",
            "    /* close the firewall named pipe */",
            "    close(fd);",
            "    exit(0);",
            " * Tell kernel to kill specified TCP connection.",
            " * Write return value to named pipe.",
            "static void daemon_kill_tcp(int fd)",
            "  int ofd;",
            "  int rc = -2;",
            "  struct sf_control *control;",
            "  struct sf_control_tcp ctl;",
            "  read(fd, &ctl, sizeof(ctl));",
            "  if ((control = (struct sf_control *) malloc(sizeof(struct sf_control) +",
            "\t\t\t\t sizeof(struct sf_control_tcp))) == NULL)",
            "     crit_error(\"Out of memory (malloc:control)!\");",
            "  /* do it */",
            "  control->magic = SF_CONTROL_MAGIC;",
            "  control->command = SF_COMMAND_TCP_KILL;",
            "  memcpy(control->data, &ctl, sizeof(ctl));",
            "  rc = write(fddev, control, sizeof(struct sf_control) +",
            "\t     sizeof(struct sf_control_tcp));",
            "  free(control);",
            "  /* open the firewall named output pipe */",
            "  if ((ofd = open(OPIPE, O_WRONLY)) < 0)",
            "    crit_error(\"Cannot open the firewall output pipe!\");",
            "  write(ofd, &rc, sizeof(rc));",
            "  close(ofd);",
            " * Tell kernel to kill all TCP connections.",
            "static void daemon_flush_all(void)",
            "  struct sf_control control;",
            "  control.magic = SF_CONTROL_MAGIC;",
            "  control.command = SF_COMMAND_FLUSH_ALL;",
            "  write(fddev, &control, sizeof(control));",
            " * Tell kernel to reset usage counters.",
            "void daemon_resetusage(void)",
            "  struct sf_control control;",
            "  control.magic   = SF_CONTROL_MAGIC;",
            "  control.command = SF_COMMAND_RESETUSAGE;",
            "  write(fddev, &control, sizeof(control));",
            "  usage_since = ltime;",
            "/* The signal handler */",
            "static void catch_usr2(int sig)",
            "  /* BSD reliable signals: no need to re-set signal handler */",
            "  process_signal();",
            " * Initialize the daemon ",
            "void init_log(void)",
            "  /* Get the current time first and convert it to ASCII.",
            "     Both values are stored in static variables, because",
            "     the time is needed so very often. */",
            "  get_time();",
            "  if (sf_configure_filter() != 0) {",
            "    fputs(\"Error configuring the kernel filter module!\\n\", stderr);",
            "    exit(1);",
            "  usage_since = ltime;",
            "  if ((fddev = open(sf_devname, O_RDWR)) < 0) {",
            "    perror(\"Cannot open the firewall device\");",
            "    exit(1);",
            " * Start the daemon ",
            "void start_log(char *config)",
            "  int i;",
            "  /* Catching all signals is required, because we want to flush ",
            "     the log file before terminating and record the time */",
            "  for (i = 1; i < NSIG; i++)",
            "    signal(i, cleanup);",
            "  /* SIGCHLD: fetch exit state of children */",
            "  signal(SIGCHLD, catch_child);",
            "  /* Set alarm */",
            "  signal(SIGALRM, catch_alarm);",
            "  /* SIGUSR1: Terminate if !conn_established */",
            "  signal(SIGUSR1, catch_usr1);",
            "  /* SIGUSR2: Write config to named pipe */",
            "  signal(SIGUSR2, catch_usr2);",
            "  /* Other signals to ignore */",
            "  signal(SIGURG, SIG_IGN);",
            "  signal(SIGCONT, SIG_IGN);",
            "  signal(SIGIO, SIG_IGN);",
            "  signal(SIGPIPE, SIG_IGN);\t/* test for EPIPE after each write() */",
            "  /* initialize signal masks */",
            "  sigemptyset(&blockmask);",
            "  sigaddset(&blockmask, SIGALRM);",
            "  sigaddset(&blockmask, SIGUSR2);",
            "  sigaddset(&blockmask, SIGUSR1);",
            "  connect_logs(config);",
            "  serv_init();",
            "  comm_init();",
            "  packet_loop();",
            "  exit(2);",
            "sifi-0.1/server/sf_device.c",
            "100644 ",
            "     0 ",
            "     0 ",
            "      16536  6610506752  14026",
            "ustar  ",
            "root",
            "root",
            "/* ----------------------------------------------------------------------",
            "   The SINUS Firewall -- a TCP/IP packet filter for Linux",
            "   Written within the SINUS project at the University of Zurich,",
            "   SWITCH, Telekurs Payserv AG, ETH Zurich.",
            "   originally based on the sf Firewall Software (C) 1996 by Robert",
            "   Muchsel and Roland Schmid.",
            "   This program is free software; you can redistribute it and/or modify",
            "   it under the terms of the GNU General Public License as published by",
            "   the Free Software Foundation; either version 2 of the License, or",
            "   (at your option) any later version.",
            "   This program is distributed in the hope that it will be useful,",
            "   but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "   GNU General Public License for more details.",
            "   You should have received a copy of the GNU General Public License",
            "   along with this program; if not, write to the Free Software",
            "   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
            "   SINUS Firewall resources:",
            "   SINUS Homepage: http://www.ifi.unizh.ch/ikm/SINUS/",
            "   Firewall Homepage: http://www.ifi.unizh.ch/ikm/SINUS/firewall.html",
            "   Frequently asked questions: http://www.ifi.unizh.ch/ikm/SINUS/sf_faq.html",
            "   Mailing list for comments, questions, bug reports: firewall@ifi.unizh.ch",
            "   ----------------------------------------------------------------------  */",
            " * Firewall character device -- loadable kernel module",
            " * $Id: sf_device.c,v 1.17 1995/08/05 14:57:57 robby Rel $",
            "#include <linux/config.h>",
            "#ifdef CONFIG_MODVERSIONS",
            "#define MODVERSIONS 1",
            "#endif",
            "#include <linux/module.h>",
            "#include <linux/modversions.h>",
            "#include <linux/version.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/malloc.h>",
            "#include <linux/string.h>",
            "#include <linux/timer.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/in.h>",
            "#include <linux/delay.h>",
            "#include <linux/fs.h>",
            "#include <linux/fcntl.h>",
            "#include <linux/errno.h>",
            "#include <linux/major.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/firewall.h>",
            "#include \"sf_kernel.h\"",
            "#include \"sf_filter.h\"",
            "#include \"sf_device.h\"",
            "#include \"sf_global.h\"",
            " * Used to get the current state in a `for' loop.",
            "static int isopen = 0;",
            "static struct sf_fw *last = NULL;",
            "static struct sf_tcp_connection *tcpl = NULL;",
            " * Read the firewall device. This function takes the file mode to distinguish",
            " * between a `get config' call and a `get buffer' call.",
            "static int read_firewall(struct inode *inode, struct file *file, char *buf, int count)",
            "  int len;",
            "  unsigned long flags;",
            "  if ((file->f_mode & 2) == 0) {\t/* read state */",
            "    if (count == sizeof(struct sf_fw)) {",
            "      /* (I) read struct sf_fw */",
            "      /* get the rules one by one */",
            "      last = (struct sf_fw *) ((last == NULL) ? sf_rule_first() : sf_rule_next());",
            "      if (last == NULL)",
            "\treturn 0;\t\t/* signals end of this data */",
            "      memcpy_tofs(buf, last, sizeof(struct sf_fw));",
            "    }",
            "    else if (count == sizeof(struct sf_tcp_connection)) {",
            "      /* (II) read struct sf_tcp_connection */",
            "      tcpl = (struct sf_tcp_connection *) ((tcpl == NULL) ? sf_conn_first() : sf_conn_next());",
            "      if (tcpl == NULL)",
            "\treturn 0;\t\t/* signals end of this data */",
            "      memcpy_tofs(buf, tcpl, sizeof(struct sf_tcp_connection));",
            "    }",
            "    else",
            "      return -EINVAL;",
            "    len = count;",
            "  else {\t\t\t/* normal operation */",
            "    if (count != sizeof(struct sf_proc))",
            "       return -EINVAL;",
            "    if (sf_fw_enabled <= 0)",
            "      return 0;",
            "    /* sleep until there is data to consume */",
            "    if (sf_log_data.num_entries == 0) ",
            "      interruptible_sleep_on(&sf_log_entry);",
            "    /* we don't want to be interrupted... */",
            "    save_flags(flags);",
            "    cli();",
            "    /* consume data */",
            "    memcpy_tofs(buf, &sf_log_data, sizeof(struct sf_proc));",
            "    /* reset offset */",
            "    sf_log_data.num_entries = 0;",
            "    /* interrupts are ok again */",
            "    restore_flags(flags);",
            "    len = sizeof(struct sf_proc);",
            "  file->f_pos += len;",
            "  return len;",
            " * Write the firewall device -- used for reconfiguration.",
            "static int write_firewall(struct inode *inode, struct file *file, const char *buf, int count)",
            "  int len;",
            "  int (*sf_fw_chk_save) (struct iphdr *, struct device *, int);",
            "  /* save filter routine and set it to `block all'",
            "     to avoid corruption of the configuration data */",
            "  sf_fw_chk_save = sf_fw_chk;",
            "  sf_fw_chk = sf_fw_chk_block;",
            "  len = sf_write_config(buf, count);",
            "  /* restore filter routine */",
            "  sf_fw_chk = sf_fw_chk_save;",
            "  if (len > 0)",
            "    file->f_pos += len;",
            "  return len;",
            " * determine if data is available for read",
            "static int select_firewall(struct inode *inode, struct file *file, int sel_type, select_table * wait)",
            "  if ((file->f_mode & 2) == 0) { /* read state */ ",
            "    return (sel_type == SEL_IN);",
            "  /* normal operation (read/write) */",
            "  switch (sel_type) {",
            "    case SEL_IN: ",
            "      if (sf_log_data.num_entries) ",
            "        return 1; /* data available */",
            "      select_wait(&sf_log_entry, wait);",
            "      return 0;",
            "    case SEL_OUT:",
            "      return 1; /* may always write */",
            "    case SEL_EX: ",
            "      return 0; /* no exceptions */",
            "  return 0;",
            " * Open the firewall device. There are three cases:",
            " * read/write: normal operation",
            " * write only: reconfiguration",
            " * read only:  read current state ",
            "static int open_firewall(struct inode *inode, struct file *file)",
            "  if (MINOR(inode->i_rdev) != 0)",
            "    return -ENODEV;",
            "  if ((file->f_mode & 2) == 0) {\t/* read only */",
            "    if (isopen != 0)",
            "      return -EBUSY;",
            "    isopen = 1;",
            "    last = NULL;",
            "    tcpl = NULL;",
            "  else {",
            "    if (sf_fw_enabled != 0)",
            "      return -EBUSY;",
            "    sf_log_data.num_entries = 0;",
            "    if ((file->f_mode & 1) == 1) {\t/* read/write requested */",
            "      sf_fw_chk = sf_check_packet;\t/* normal operation */",
            "    }",
            "    else {\t\t\t/* write only */",
            "      sf_fw_chk = sf_fw_chk_block;\t/* device open for reconfiguration */",
            "    }",
            "    sf_fw_enabled++;",
            "  MOD_INC_USE_COUNT;",
            "  return 0;",
            "static void close_firewall(struct inode *inode, struct file *file)",
            "  MOD_DEC_USE_COUNT;",
            "  if ((file->f_mode & 2) == 0) {",
            "    isopen = 0;",
            "  else {",
            "    sf_fw_enabled--;",
            "    /* Always block all packets if the daemon died. The user's",
            "       manual gives reasons for this behavior */",
            "    sf_fw_chk = sf_fw_chk_block;",
            "/* this structure contains the device switching table */",
            "static struct file_operations firewall_fops =",
            "  NULL,\t\t\t\t/* lseek */",
            "  read_firewall,\t\t/* read */",
            "  write_firewall,\t\t/* write */",
            "  NULL,\t\t\t\t/* readdir */",
            "  select_firewall,\t\t/* select */",
            "  NULL,\t\t\t\t/* ioctl */",
            "  NULL,\t\t\t\t/* mmap */",
            "  open_firewall,\t\t/* open code */",
            "  close_firewall,\t\t/* release code */",
            "  NULL\t\t\t\t/* fsync */",
            "int init_module(void)",
            "  if (register_chrdev(FIREWALL_MAJOR, \"firewall\", &firewall_fops)) {",
            "    printk(\"unable to get major %d for firewall devs\\n\", FIREWALL_MAJOR);",
            "    return -EIO;",
            "  if (register_firewall(PF_INET, &sf_fw_ops)) {",
            "    printk(\"unable to register firewall\\n\");",
            "    return -EIO;",
            "  if ((dev_base == NULL) || (strcmp(dev_base->name, \"lo\") != 0)) {",
            "    printk(\"loopback is not first device in chain\\n\");",
            "    return -EIO;",
            "  sf_init();",
            "  return 0;",
            "void cleanup_module(void)",
            "  if (MOD_IN_USE)",
            "    printk(\"firewall: busy - remove delayed\\n\");",
            "  else {",
            "    /* let all packets pass if filter is not loaded */",
            "    sf_fw_chk = sf_fw_chk_pass;",
            "    sf_del_all_timers();",
            "    unregister_chrdev(FIREWALL_MAJOR, \"firewall\");",
            "    /* may fail.. */",
            "    unregister_firewall(PF_INET, &sf_fw_ops);",
            "sifi-0.1/server/sf_filter.c",
            "100644 ",
            "     0 ",
            "     0 ",
            "     174553  6612755451  14104",
            "ustar  ",
            "root",
            "root",
            "/* ----------------------------------------------------------------------",
            "   The SINUS Firewall -- a TCP/IP packet filter for Linux",
            "   Written within the SINUS project at the University of Zurich,",
            "   SWITCH, Telekurs Payserv AG, ETH Zurich.",
            "   originally based on the sf Firewall Software (C) 1996 by Robert",
            "   Muchsel and Roland Schmid.",
            "   This program is free software; you can redistribute it and/or modify",
            "   it under the terms of the GNU General Public License as published by",
            "   the Free Software Foundation; either version 2 of the License, or",
            "   (at your option) any later version.",
            "   This program is distributed in the hope that it will be useful,",
            "   but WITHOUT ANY WARRANTY; without even the implied warranty of",
            "   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the",
            "   GNU General Public License for more details.",
            "   You should have received a copy of the GNU General Public License",
            "   along with this program; if not, write to the Free Software",
            "   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.",
            "   SINUS Firewall resources:",
            "   SINUS Homepage: http://www.ifi.unizh.ch/ikm/SINUS/",
            "   Firewall Homepage: http://www.ifi.unizh.ch/ikm/SINUS/firewall.html",
            "   Frequently asked questions: http://www.ifi.unizh.ch/ikm/SINUS/sf_faq.html",
            "   Mailing list for comments, questions, bug reports: firewall@ifi.unizh.ch",
            "   ----------------------------------------------------------------------  */",
            " * This file is part of the SINUS firewall loadable driver module",
            " * $Id: sf_filter.c,v 1.40 1995/09/12 15:08:59 robby Rel $",
            "#include <linux/config.h>",
            "#ifdef CONFIG_MODVERSIONS",
            "#define MODVERSIONS 1",
            "#endif",
            "#include <linux/modversions.h>",
            "#include <linux/kernel.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/errno.h>",
            "#include <linux/net.h>",
            "#include <linux/in.h>",
            "#include <linux/inet.h>",
            "#include <linux/netdevice.h>",
            "#include <linux/icmp.h>",
            "#include <linux/tcp.h>",
            "#include <linux/udp.h>",
            "#include <linux/ip.h>",
            "#include <linux/malloc.h>",
            "#include <linux/timer.h>",
            "#include <net/ip.h>",
            "#include <net/tcp.h>",
            "#include <linux/igmp.h>",
            "#include <asm/checksum.h>",
            "#include \"sf_kernel.h\"",
            "#include \"sf_rc.h\"",
            "#include \"sf_global.h\"",
            "#include \"sf_filter.h\"",
            "#include \"sf_control.h\"",
            "#include \"sf_tcp.h\"",
            "#include \"sf_icmp.h\"",
            "/* loopback is the first device in the dev chain */",
            "#define LOOPBACK_MASK (dev_base->pa_mask)",
            "#define LOOPBACK_ADDR (dev_base->pa_addr)",
            "/* firewall enabled */",
            "int sf_fw_enabled = 0;",
            "/* firewall initialized */",
            "int sf_fw_initialized = 0;",
            "/* temporary storage for packets to be sent to the daemon */",
            "struct sf_proc sf_log_data;",
            "/* wait queue for synchronization between filter function and daemon */",
            "struct wait_queue *sf_log_entry = NULL;",
            "#define PRINTIP(a) printk(\"%lu.%lu.%lu.%lu\", ntohl(a)>>24&0xFF,\\",
            "                          ntohl(a)>>16&0xFF, ntohl(a)>>8&0xFF, ntohl(a)&0xFF)",
            "#define MIN(a,b) ((a) < (b) ? (a) : (b))",
            " * linear lists to store the rules and connections",
            "struct sf_fw *prio_rules = NULL;",
            "struct sf_fw *rules      = NULL;",
            "struct sf_tcp_connection *conns = NULL;",
            "struct sf_tcp_connection *lastc = NULL;",
            " * pointers to save positions for sf_****_first() and sf_****_next()",
            " * (used by \"sfc show\")",
            "struct sf_fw *rule_first_next = NULL;",
            "unsigned long conn_id = 0;",
            " * array to store the ip addresses of the rules ",
            "struct sf_address sf_addr[SF_ADDRESS_CNT_MAX];",
            "int sf_addr_free = 1;\t\t/* first free entry in array */",
            "/* returns 1 if addr matches one of the \"internalnet\" addresses */",
            "static inline int sf_inside(__u32 addr)",
            "  int i;",
            "  for (i = 1; i <= sf_addr[0].addr; i++) {",
            "    if ((sf_addr[i].addr & sf_addr[i].mask) == (addr & sf_addr[i].mask))",
            "      return 1;",
            "  return 0;",
            "/* returns 1 if address is local",
            " * dev_base is taken from <linux/netdevice.h> */",
            "int sf_local(__u32 addr)",
            "  struct device *pdev;",
            "  for(pdev = dev_base; pdev; pdev = pdev->next) {",
            "    if(pdev->pa_addr == addr)",
            "      return 1;",
            "  return 0;",
            "/* returns 1 if address matches */",
            "int sf_addr_match(long idx, long cnt, __u32 addr, int port, int negative)",
            "  int i;",
            "  for (i = idx; i < (idx + cnt); i++) {\t\t",
            "    /* set addrmatch if address does not matter or if address matches */",
            "    /* address is to be ignored if mask == 0 */",
            "    int addrmatch =",
            "    ((sf_addr[i].addr & sf_addr[i].mask) == (addr & sf_addr[i].mask));",
            "    int portmatch = 1;",
            "    /* reset portmatch if port matters but does not match */",
            "    if (port >= 0)",
            "      if ((port < sf_addr[i].port) || (sf_addr[i].prend < port))",
            "        portmatch = 0;",
            "    /* If the negative flag is not set, we have got a match if at",
            "       least once addrmatch and portmatch is set, so return 1. ",
            "       If the negative flag is set, the return value must be zero",
            "       to be good. It may only be zero if the port matches (or",
            "       does not matter) and none of the addresses match. As the ",
            "       negative flag is set only if the outside keyword is used,",
            "       all port fields contain the same value. So we can return",
            "       one if portmatch is zero for the first array entry.       */",
            "    if ((addrmatch && portmatch)",
            "\t|| (negative && !portmatch))",
            "      return 1;",
            "  return 0;",
            " * interface cache to determine if interface is connected to inside or outside.",
            " * Warning: there is collision detection, but no resolution; interface",
            " * base adresses should never collide.",
            "#define SF_IF_CACHE_SIZE\t199\t/* must be a prime number */",
            "struct sf_if_cache_entry {",
            "  __u32 ifaddr;\t\t\t/* address of interface */",
            "  int inside;\t\t\t/* 1 if interface is inside */",
            "struct sf_if_cache_entry sf_if_cache[SF_IF_CACHE_SIZE];",
            "#define SF_IF_CACHE_KEY(a)  ( (a) % SF_IF_CACHE_SIZE )",
            "#ifndef CONFIG_IP_ALWAYS_DEFRAG",
            " * hash queues for fragmented ip datagrams ",
            "struct sf_fragment {",
            "  struct sf_fragment *prev, *next;\t/* queue pointers */",
            "  __u16 id;\t\t\t/* identification field */",
            "  __u32 src;\t\t\t/* source address */",
            "  __u32 dst;\t\t\t/* destination address */",
            "  struct timer_list timer;\t/* expiration of datagram */",
            "#define SF_FRAG_HASH_SIZE\t499\t/* must be a prime number */",
            "struct sf_fragment *sf_frag[SF_FRAG_HASH_SIZE];",
            "#define SF_FRAG_KEY(a)\t( (a) % SF_FRAG_HASH_SIZE )",
            "/* delete entry from hash queue */",
            "static void sf_frag_expire(unsigned long arg)",
            "  struct sf_fragment *frag;",
            "  unsigned long flags;",
            "  frag = (struct sf_fragment *) arg;",
            "#ifdef SF_DEBUG_FRAG",
            "  printk(\"sf_frag_expire: id = %u\\n\", ntohs(frag->id));",
            "#endif",
            "  del_timer(&frag->timer);",
            "  save_flags(flags);",
            "  cli();",
            "  /* delete fragment from queue */",
            "  if (frag->prev != NULL) {",
            "    frag->prev->next = frag->next;",
            "  else",
            "    sf_frag[SF_FRAG_KEY(frag->id)] = frag->next;",
            "  if (frag->next != NULL)",
            "    frag->next->prev = frag->prev;",
            "  restore_flags(flags);",
            "  kfree_s(frag, sizeof(struct sf_fragment));",
            "/* insert hash queue entry */",
            "static void sf_frag_insert(__u16 id, __u32 saddr, __u32 daddr)",
            "  int key = SF_FRAG_KEY(id);",
            "  struct sf_fragment *frag;",
            "  unsigned long flags;",
            "  /* allocate memory and initialize fragmentation hash queue entry */",
            "  if ((frag =",
            "       (struct sf_fragment *) kmalloc(sizeof(struct sf_fragment), GFP_ATOMIC)) == NULL) {",
            "    printk(\"sf_frag_insert: out of memory!\\n\");",
            "    return;",
            "  frag->id = id;",
            "  frag->src = saddr;",
            "  frag->dst = daddr;",
            "#ifdef SF_DEBUG_FRAG",
            "  printk(\"sf_frag_insert: id = %u\\n\", ntohs(frag->id));",
            "#endif",
            "  /* initialize timer */",
            "  init_timer(&frag->timer);",
            "  frag->timer.expires = jiffies + IP_FRAG_TIME;\t\t/* same time as in reassembly */",
            "  frag->timer.data = (unsigned long) frag;",
            "  frag->timer.function = sf_frag_expire;",
            "  add_timer(&frag->timer);",
            "  /* insert as first element into hash queue */",
            "  save_flags(flags);",
            "  cli();",
            "  if (sf_frag[key] != NULL)",
            "    sf_frag[key]->prev = frag;",
            "  frag->next = sf_frag[key];",
            "  frag->prev = NULL;",
            "  sf_frag[key] = frag;",
            "  restore_flags(flags);",
            "/* packet is a fragment if \"more fragments\" bit is set => add to hash queue */",
            "static inline void check_for_fragment(struct iphdr *ip)",
            "  if (ip->frag_off & htons(IP_MF)) ",
            "    sf_frag_insert(ip->id, ip->saddr, ip->daddr);",
            "#else",
            "#define check_for_fragment(a)",
            "#endif /* CONFIG_IP_ALWAYS_DEFRAG */",
            " * hash queues for tcp circuits",
            "/* An established TCP connection is identified */",
            "/* by the source and dest addresses and ports. */",
            "#define SF_TCP_NO_SYN_YET\t( 180 * HZ)\t/* ftp data connection timeout */",
            "#define SF_TCP_SYN_TO\t\t( 120 * HZ)\t/* connection establishment timeout */",
            "#define SF_TCP_FIN_WAIT\t\t(  15 * HZ)\t/* wait after last FIN (let ACKs pass) */",
            "#define SF_TCP_HALFCLOSE\t( 480 * HZ)\t/* half close timeout */",
            "struct sf_tcp_connection *sf_tcp[SF_TCP_HASH_SIZE];",
            "/* delete entry from hash queue */",
            "typedef void (*sf_tcp_expire)(unsigned long);",
            "static void sf_tcp_delete(struct sf_tcp_connection *sftcp)",
            "  unsigned long flags;",
            "  if (sftcp->timer_set) {",
            "    del_timer(&sftcp->timer);",
            "    sftcp->timer_set = 0;",
            "  save_flags(flags);",
            "  cli();",
            "  sftcp->id = 0;\t\t/* invalidate */",
            "  if (sftcp->prev != NULL) {",
            "    sftcp->prev->next = sftcp->next;",
            "  else",
            "    sf_tcp[SF_TCP_KEY(sftcp->client_addr + sftcp->server_addr",
            "\t\t      + (__u32) sftcp->client_port + (__u32) sftcp->server_port)] = sftcp->next;",
            "  if (sftcp->next != NULL)",
            "    sftcp->next->prev = sftcp->prev;",
            "  if (sftcp->before != NULL)",
            "    sftcp->before->after = sftcp->after;",
            "  else",
            "    conns = sftcp->after;",
            "  if (sftcp->after != NULL)",
            "    sftcp->after->before = sftcp->before;",
            "  else",
            "    lastc = sftcp->before;",
            "#ifdef SF_DEBUG_TCP",
            "  printk(\"sf: tcp: delete: %p \", sftcp); PRINTIP(sftcp->client_addr);",
            "  printk(\":%u -> \", ntohs(sftcp->client_port)); PRINTIP(sftcp->server_addr);",
            "  printk(\":%u\\n\", ntohs(sftcp->server_port));",
            "#endif",
            "  restore_flags(flags);",
            "  kfree_s(sftcp, sizeof(struct sf_tcp_connection));",
            "static void sf_tcp_reset(struct sf_tcp_connection *sftcp)",
            "  struct iphdr *ip;",
            "  struct tcphdr *tcp; ",
            "  /* allocate minimum IP + minimum TCP header */",
            "  ip  = kmalloc(sizeof(struct iphdr) + sizeof(struct tcphdr), GFP_ATOMIC); ",
            "  tcp = (struct tcphdr *) ((char *) ip + sizeof(struct iphdr));",
            "  memset(ip, 0, sizeof(struct iphdr) + sizeof(struct tcphdr));",
            "  /* hand craft packet (checksums will be ignored) */",
            "  ip->version  = 4;",
            "  ip->ihl      = 5;",
            "  ip->tos      = 0x10;",
            "  ip->tot_len  = sizeof(struct iphdr) + sizeof(struct tcphdr);",
            "  ip->id       = 0;",
            "  ip->frag_off = 0;",
            "  ip->ttl      = 255;",
            "  ip->protocol = IPPROTO_TCP;",
            "  ip->check    = 0;",
            "  ip->saddr    = sftcp->client_addr; ",
            "  ip->daddr    = sftcp->server_addr;",
            "  tcp->source  = sftcp->client_port; ",
            "  tcp->dest    = sftcp->server_port;",
            "  tcp->seq     = sftcp->client_seq;",
            "  send_tcp(1, sftcp->rif, ip, tcp);",
            "  kfree(ip);",
            "  sf_tcp_delete(sftcp);",
            "static inline void set_tcp_timer(struct sf_tcp_connection *, unsigned long);",
            "static inline void set_tcp_rst_timer(struct sf_tcp_connection *, unsigned long);",
            "/* insert hash queue entry */",
            "static struct sf_tcp_connection *sf_tcp_insert(__u32 saddr, __u32 daddr, ",
            "                                               __u16 source, __u16 dest,",
            "                                               struct sf_fw *rule,",
            "\t\t\t\t\t       struct device *rif)",
            "  int key = SF_TCP_KEY(saddr + daddr + (__u32) source + (__u32) dest);",
            "  struct sf_tcp_connection *sftcp;",
            "  unsigned long flags;",
            "  int sf_flush_all(void);",
            "  /* allocate memory and initialize tcp hash queue entry */",
            "  if ((sftcp = (struct sf_tcp_connection *) kmalloc(sizeof(struct sf_tcp_connection), GFP_ATOMIC)) == NULL) {",
            "    printk(\"sf: tcp_insert: out of memory -- closing all connections!\\n\");",
            "    /* Clean up the tcp hash queues. This will abort all TCP connections. */",
            "    /* But if the hash queues occupy a lot of memory, it will help! */",
            "    sf_flush_all();",
            "    return NULL;",
            "  memset(sftcp, 0, sizeof(struct sf_tcp_connection));",
            "  sftcp->client_addr  = saddr;",
            "  sftcp->server_addr  = daddr;",
            "  sftcp->client_port  = source;",
            "  sftcp->server_port  = dest;",
            "  sftcp->state        = SF_TCP_ACCEPT_SYN;",
            "  sftcp->established  = jiffies;",
            "  sftcp->rif          = rif;",
            "  if (rule->timeout == SF_RULE_STATIC)",
            "    sftcp->rule = rule;",
            "#ifdef SF_DEBUG_TCP",
            "  printk(\"sf: tcp: insert: (%i) %p \", key, sftcp); PRINTIP(sftcp->client_addr);",
            "  printk(\":%u -> \", ntohs(sftcp->client_port)); PRINTIP(sftcp->server_addr);",
            "  printk(\":%u\\n\", ntohs(sftcp->server_port));",
            "#endif",
            "  /* initialize timer */",
            "  init_timer(&sftcp->timer);",
            "  set_tcp_timer(sftcp, SF_TCP_NO_SYN_YET);",
            "  sftcp->timer_set = 1;",
            "  /* insert as first element into hash queue */",
            "  save_flags(flags);",
            "  cli();",
            "  if (sf_tcp[key] != NULL)",
            "    sf_tcp[key]->prev = sftcp;",
            "  sftcp->next = sf_tcp[key];",
            "  sftcp->prev = NULL;",
            "  sf_tcp[key] = sftcp;",
            "  /* make id, renumber ids if needed */",
            "  if (lastc != NULL) {",
            "    if (lastc->id == UINT_MAX) {",
            "      /* renumber connection ids */",
            "      struct sf_tcp_connection *ptr;",
            "      __u32 id;",
            "      ptr = conns;",
            "      id = 1;",
            "      while (ptr != NULL) {",
            "\tif (ptr->id == conn_id)",
            "\t  conn_id = id;",
            "\tptr->id = id;",
            "\tid++;",
            "\tptr = ptr->after;",
            "      }",
            "    }",
            "    sftcp->id = lastc->id + 1;",
            "  else",
            "    sftcp->id = 1;",
            "  /* insert as last element into linked list of connections */",
            "  if (conns == NULL)",
            "    conns = sftcp;",
            "  if (lastc != NULL)",
            "    lastc->after = sftcp;",
            "  sftcp->before = lastc;",
            "  sftcp->after = NULL;",
            "  lastc = sftcp;",
            "  restore_flags(flags);",
            "  return sftcp;",
            " * RIP",
            "#define SF_RIP_PORT 520",
            "struct riphdr {",
            "  __u8 command;\t\t\t/* RIP command */",
            "  __u8 version;\t\t\t/* RIP version */",
            "  __u16 zero1;\t\t\t/* must be zero */",
            "struct ripdata {",
            "  __u16 af;\t\t\t/* address family */",
            "  __u16 zero1;\t\t\t/* must be zero */",
            "  __u32 addr;\t\t\t/* IP address */",
            "  __u32 zero2;\t\t\t/* must be zero */",
            "  __u32 zero3;\t\t\t/* must be zero */",
            "  __u32 metric;\t\t\t/* metric */",
            "static inline int check_rip(struct sf_fw *rule, struct riphdr *rip, unsigned long riplength)",
            "  unsigned long len;",
            "  struct ripdata *rd = (struct ripdata *) (rip + 1);",
            "#ifdef SF_DEBUG_RIP",
            "  printk(\"RIP command %u version %u length %lu\\n\",",
            "         (unsigned) rip->command,(unsigned) rip->version,riplength);",
            "#endif",
            "  for (len = riplength - sizeof(struct riphdr); len >= 20; len -= 20, rd++) {",
            "#ifdef SF_DEBUG_RIP",
            "    printk(\" af %u addr \",ntohs(rd->af)); PRINTIP(rd->addr);",
            "    printk(\" metric %lu\\n\",ntohl(rd->metric));",
            "#endif",
            "    if ((ntohs(rd->af) == AF_INET)",
            "\t&& (ntohs(rd->metric) < 16)",
            "\t&& ((!(rule->fw_flags & SF_RIP_ADDR_NEG)",
            "    && !sf_addr_match(rule->fw_rip_idx, rule->fw_rip_cnt, rd->addr, -1, 0))",
            "\t    || ((rule->fw_flags & SF_RIP_ADDR_NEG)",
            "\t\t&& sf_addr_match(rule->fw_rip_idx, rule->fw_rip_cnt, rd->addr, -1, 1))))",
            "      return 0;",
            "  return 1;",
            "static inline void set_tcp_timer(struct sf_tcp_connection *sftcp,",
            "                            unsigned long when)",
            "   if (sftcp->timer_set)",
            "     del_timer(&sftcp->timer);",
            "   sftcp->timer.expires  = jiffies + when;",
            "   sftcp->timer.data     = (unsigned long) sftcp;",
            "   sftcp->timer.function = (sf_tcp_expire) sf_tcp_delete;",
            "   sftcp->timer_set      = 1;",
            "   add_timer(&sftcp->timer);",
            "static inline void set_tcp_rst_timer(struct sf_tcp_connection *sftcp,",
            "                            unsigned long when)",
            "   if (sftcp->timer_set)",
            "     del_timer(&sftcp->timer);",
            "   sftcp->timer.expires  = jiffies + when;",
            "   sftcp->timer.data     = (unsigned long) sftcp;",
            "   sftcp->timer.function = (sf_tcp_expire) sf_tcp_reset;",
            "   sftcp->timer_set      = 1;",
            "   add_timer(&sftcp->timer);",
            "/* update usage counter, send packet to daemon, append to message buffer */",
            "static int inform_log(struct sf_fw *rule, struct iphdr *ip, ",
            "                      struct device *rif, int ip_tot_len)",
            "  rule->usage++;",
            "  /* no notification? */",
            "  if (!(rule->fw_flags & SF_FW_LOG))",
            "    return 0;",
            "  if (sf_log_data.num_entries < NUM_PROC_ENTRIES) {",
            "    struct sf_proc_entry *current_p = &(sf_log_data.data[sf_log_data.num_entries]);",
            "    current_p->action     = rule->fw_rc;",
            "    current_p->rule.num   = rule->rule_id.num;",
            "    strncpy(current_p->devname, rif->name, 7);",
            "    current_p->devname[7] = 0;",
            "    memcpy(current_p->ip_packet, ip, MIN(PROC_SIZE_IP, ip_tot_len));",
            "    sf_log_data.num_entries++;",
            "  else {",
            "    sf_log_data.lost_entries++;",
            "    /* wake up daemon */",
            "    wake_up_interruptible(&sf_log_entry);",
            "    /* drop packet silently if buffer is full */",
            "    return -1;",
            "  /* wake up daemon */",
            "  wake_up_interruptible(&sf_log_entry);",
            "  return 0;",
            " * Returns FW_BLOCK if packet should be dropped, FW_ACCEPT if it should be ",
            " * accepted, and FW_REJECT if an ICMP unreachable packet should be sent.",
            " * opt is one of SF_STATE_FORWARD, TRANSMIT or RECEIVE.",
            " * This call is done from task[0], so it must not sleep.  ",
            "int sf_check_packet(struct iphdr *ip, struct device *rif, int opt)",
            "  struct sf_fw implicit_rule;",
            "  struct sf_fw *rule = &implicit_rule;",
            "  int ip_hdr_len = ip->ihl * 4;",
            "  int ip_tot_len = ntohs(ip->tot_len);",
            "  char *payload  = (char *) ip + ip_hdr_len;",
            "  char *pktend   = (char *) ip + ip_tot_len;",
            "#define tcp  ((struct tcphdr  *) payload)",
            "#define udp  ((struct udphdr  *) payload)",
            "#define icmp ((struct icmphdr *) payload)",
            "#define igmp ((struct igmphdr *) payload)",
            "  int returncode  = FW_BLOCK;",
            "  /* --- TCP variables --- */",
            "  struct sf_tcp_connection *sftcp = NULL;",
            "  char *tcpdata   = NULL;",
            "  int sequence_ok = 0;",
            "  int reverse     = 0;\t\t/* indicates direction of packet */",
            "    \t\t\t\t/* reverse == 0: client->server  */",
            "    \t\t\t\t/* reverse == 1: client<-server  */",
            "  int key; ",
            "  __u32 end_seq = 0;",
            "  __u32 ack_seq = 0;",
            "  __u16 window  = 0;",
            "  /* --- end TCP variables --- */",
            "  /* don't let packet pass if firewall functions are disabled */",
            "  if (sf_fw_enabled <= 0)",
            "    return FW_BLOCK;",
            "  /* check if packet is long enough to hold IP header and an IPv4 packet */",
            "  if (ip_tot_len < ip_hdr_len || ip->ihl < 5 || ip->version != 4)",
            "    return FW_BLOCK;",
            "  rule->fw_rc    = FW_BLOCK;",
            "  rule->fw_flags = SF_FW_LOG;",
            "  /* --- check for loopback spoofing --- */",
            "  /* if the device is loopback, source and dest addr. must be loopback addr. */",
            "  if (!(rif->flags & IFF_LOOPBACK)",
            "      && (((ip->saddr & LOOPBACK_MASK) ==",
            "\t   (LOOPBACK_ADDR & LOOPBACK_MASK))",
            "\t  || ((ip->daddr & LOOPBACK_MASK) ==",
            "\t      (LOOPBACK_ADDR & LOOPBACK_MASK)))) {\t/* packet not allowed */",
            "    rule->rule_id.num = (opt == SF_STATE_RECEIVE) ",
            "                        ? RULE_SPOOF_RECV : RULE_SPOOF_XMIT;",
            "    goto informlog;\t\t/* skip all further examination but inform daemon */",
            "  /* --- end loopback check --- */",
            "  /* check local packets only once -- at transmit time */",
            "  if (opt == SF_STATE_RECEIVE && ip->saddr == ip->daddr)",
            "    return FW_ACCEPT;",
            "  /* don't check forwarded packets at transmit time */",
            "  if (opt == SF_STATE_TRANSMIT && !sf_local(ip->saddr))",
            "    return FW_ACCEPT;",
            "  /* --- check interface --- */",
            "    int ifinside, ifkey;",
            "    /* determine if interface is connected to inside or to outside */",
            "    if (sf_if_cache[ifkey = SF_IF_CACHE_KEY(rif->pa_addr)].ifaddr == rif->pa_addr) {",
            "      ifinside = sf_if_cache[ifkey].inside;",
            "    }",
            "    else {\t\t\t/* interface not in cache */",
            "#ifdef SF_DEBUG",
            "      printk(\"sf: caching interface \"); PRINTIP(rif->pa_addr);",
            "      printk(\", cache entry %i\\n\", ifkey);",
            "#endif",
            "      ifinside = sf_inside(rif->pa_addr);",
            "      sf_if_cache[ifkey].ifaddr = rif->pa_addr;",
            "      sf_if_cache[ifkey].inside = ifinside;",
            "    }",
            "    /* detect spoofing on non-loopback devices: source/dest interface",
            "     * is internal, ip number is external or vice versa */",
            "    if (!(rif->flags & IFF_LOOPBACK)",
            "\t&& (((opt == SF_STATE_RECEIVE)",
            "\t     && !(IN_CLASSD(ntohl(ip->saddr)))",
            "\t     && (ifinside != sf_inside(ip->saddr)))",
            "\t    || (((opt == SF_STATE_TRANSMIT)",
            "\t\t || (opt == SF_STATE_FORWARD))",
            "\t\t&& !(IN_CLASSD(ntohl(ip->daddr)))",
            "\t\t&& (ifinside != sf_inside(ip->daddr))))) {\t/* packet not allowed */",
            "      rule->rule_id.num = (opt == SF_STATE_RECEIVE) ",
            "                          ? RULE_SPOOF_RECV : RULE_SPOOF_XMIT;",
            "      goto informlog;\t\t/* skip all further examination but inform daemon */",
            "    }",
            "  /* --- end check interface --- */",
            "  /* If SF_STATE_FORWARD, the packet has already been examined at receive ",
            "     time. So skip the examination now. Do NOT move this test before the",
            "     interface check, because at SF_STATE_RECEIVE we examine a different",
            "     interface. */",
            "  if (opt == SF_STATE_FORWARD)",
            "    return FW_ACCEPT;",
            "  rule->rule_id.num = RULE_CONNECTION;",
            "  /* --- check fragments --- */",
            "  if (ip->frag_off & htons(IP_OFFSET)) {\t/* fragment offset != 0 */",
            "#ifndef CONFIG_IP_ALWAYS_DEFRAG",
            "    /* this is an ip fragment but not the first one of the packet */",
            "    struct sf_fragment *frag = sf_frag[SF_FRAG_KEY(ip->id)];",
            "#ifdef SF_DEBUG_FRAG",
            "    printk(\"sf_check_packet: frag_off %u  tot_len %u\\n\",",
            "\t   (ntohs(ip->frag_off) & IP_OFFSET) << 3, ip_tot_len);",
            "#endif",
            "    if (((ntohs(ip->frag_off) & IP_OFFSET) << 3) + ip_tot_len > 65535) {",
            "#ifdef SF_DEBUG_FRAG",
            "      printk(\"sf_check_packet: oversized packet detected!\\n\");",
            "#endif",
            "      rule->rule_id.num = RULE_OVERSIZED;",
            "      goto informlog;\t\t/* skip all further examination but inform daemon */",
            "    }",
            "    while (frag != NULL) {",
            "      if ((ip->id == frag->id) && (ip->saddr == frag->src) && (ip->daddr == frag->dst)) {\t/* fragment belongs to an allowed packet */",
            "\t/* Always let the timer delete the queue entry, because",
            "\t   fragments need not arrive in order, thus there may still",
            "\t   be fragments missing when the last fragment arrives. */",
            "\tdel_timer(&frag->timer);",
            "\tfrag->timer.expires  = jiffies + IP_FRAG_TIME;\t/* same time as in reassembly */",
            "\tfrag->timer.data     = (unsigned long) frag;",
            "\tfrag->timer.function = sf_frag_expire;",
            "\tadd_timer(&frag->timer);",
            "\treturn FW_ACCEPT;",
            "      }",
            "      frag = frag->next;",
            "    }",
            "#endif /* CONFIG_IP_ALWAYS_DEFRAG */",
            "    /* fragment must not pass */",
            "    return FW_BLOCK;",
            "  /* --- end check fragments --- */",
            "  /* Now we know that the packet is not a subsequent fragment.",
            "     So we can check, if the packet is long enough to hold an",
            "     entire UDP, ICMP, IGMP (or TCP, see below) header */",
            "  if(ip->protocol == IPPROTO_UDP)",
            "    if (ip_tot_len < ip_hdr_len + sizeof(struct udphdr))",
            "       return FW_BLOCK;",
            "  if(ip->protocol == IPPROTO_ICMP)",
            "    if (ip_tot_len < ip_hdr_len + sizeof(struct icmphdr))",
            "       return FW_BLOCK;",
            "  if(ip->protocol == IPPROTO_IGMP)",
            "    if (ip_tot_len < ip_hdr_len + sizeof(struct igmphdr))",
            "       return FW_BLOCK;",
            "  /* check for land attack with UDP packets",
            "     -- same in and out socket, see CERT adv. 79.28 */",
            "  if(ip->protocol == IPPROTO_UDP &&",
            "     ip->saddr == ip->daddr && udp->source == udp->dest)",
            "    return FW_BLOCK;",
            "  /* add Logfile entry sometimes -- hw */",
            "  /* --- check tcp --- */",
            "  if(ip->protocol == IPPROTO_TCP) {",
            "    if(ip_tot_len < ip_hdr_len + sizeof(struct tcphdr))",
            "       return FW_BLOCK;",
            "    /* check for land attack with TCP packets",
            "       -- same in and out socket, see CERT adv. 79.28 */",
            "    if(ip->saddr == ip->daddr && tcp->source == tcp->dest)",
            "      return FW_BLOCK;",
            "    /* add Logfile entry sometimes -- hw */",
            "    key = SF_TCP_KEY(ip->saddr + ip->daddr + (__u32) tcp->source + ",
            "                     (__u32) tcp->dest);",
            "#ifdef SF_DEBUG_TCP_VERBOSE",
            "    printk(\"sf: tcp: \"); PRINTIP(ip->saddr); ",
            "    printk(\":%u -> \", ntohs(tcp->source)); PRINTIP(ip->daddr);",
            "    printk(\":%u\\n\", ntohs(tcp->dest)); ",
            "#endif",
            "    /* convert these to host order for faster processing */",
            "    tcpdata = payload + tcp->doff*4;",
            "    end_seq = ntohl(tcp->seq) + pktend - tcpdata;",
            "    ack_seq = ntohl(tcp->ack_seq);",
            "    window  = ntohs(tcp->window);",
            "    sftcp = sf_tcp[key];",
            "    while (sftcp != NULL) {",
            "      if ((sftcp->client_addr == ip->saddr) &&",
            "\t  (sftcp->client_port == tcp->source) &&",
            "\t  (sftcp->server_addr == ip->daddr) &&",
            "\t  (sftcp->server_port == tcp->dest)) {",
            "\t/* reverse = 0; --- packet from client to server [default] */",
            "\tgoto have_connection;",
            "      }",
            "      if ((sftcp->client_addr == ip->daddr) &&",
            "\t  (sftcp->client_port == tcp->dest) &&",
            "\t  (sftcp->server_addr == ip->saddr) &&",
            "\t  (sftcp->server_port == tcp->source)) {",
            "\treverse++;\t\t/* packet from server to client */",
            "\tgoto have_connection;",
            "      }",
            "      sftcp = sftcp->next;",
            "    }",
            "    /* assert(sftcp == NULL) */",
            "    if (tcp->syn && !tcp->ack) {",
            "      /* special case for passive mode ftp */",
            "      sftcp = sf_tcp[SF_TCP_KEY(ip->saddr + ip->daddr + (__u32) tcp->dest)];",
            "      while (sftcp != NULL) {",
            "        if ((sftcp->client_addr == ip->saddr) &&",
            "\t    sftcp->allpsource &&",
            "\t    (sftcp->server_addr == ip->daddr) &&",
            "\t    (sftcp->server_port == tcp->dest)) {",
            "\t  struct sf_fw *rule = sftcp->rule;",
            "          int log_open = sftcp->log_open;",
            "\t  /* reverse = 0; --- packet from client to server [default] */",
            "          sf_tcp_delete(sftcp);",
            "#ifdef SF_DEBUG_TCP",
            "\t  printk(\"sf: tcp: using wildcard connection ex %p\\n\", sftcp);",
            "#endif",
            "          sftcp = sf_tcp_insert(ip->saddr, ip->daddr, tcp->source, tcp->dest, rule, rif);",
            "          if (sftcp != NULL) {",
            "            sftcp->log_open = log_open;",
            "\t    goto have_connection;",
            "          }",
            "          else",
            "            break;",
            "        }",
            "        sftcp = sftcp->next;",
            "      }",
            "      goto checkrules;\t/* new connection */",
            "    }",
            "#ifdef SF_DEBUG_TCP",
            "    printk(\"sf: tcp: connection not in hash queue\\n\");",
            "#endif",
            "    return FW_BLOCK;\t/* block packet */",
            "    /* connection found in hash queue: assert(sftcp != NULL) */",
            "have_connection:",
            "    if (sftcp->rule != NULL) {",
            "      sftcp->rule->bytes += ip_tot_len;",
            "      if (sftcp->rule->bytes >= GIGA) {",
            "        sftcp->rule->gbytes++;",
            "        sftcp->rule->bytes -= GIGA;",
            "      }",
            "    }",
            "#ifdef SF_DEBUG_TCP",
            "    if (tcp->syn || tcp->fin || tcp->rst) {",
            "      printk(\"sf: tcp: %p %s\", sftcp, reverse ? \"s->c\" : \"c->s\");",
            "      if (tcp->syn) printk(\" SYN\");",
            "      if (tcp->fin) printk(\" FIN\");",
            "      if (tcp->ack) printk(\" ACK\");",
            "      if (tcp->rst) printk(\" RST\");",
            "      printk(\"\\n\");",
            "      printk(\"sf: tcp: end_seq=%08x, ack_seq=%08x\\n\", end_seq, ack_seq);",
            "    }",
            "#endif",
            "    sftcp->lastused = jiffies;",
            "    /* --- test checksum --- */",
            "#ifndef CONFIG_IP_ALWAYS_DEFRAG",
            "    if ((ip->frag_off & htons(IP_MF)) == 0)",
            "#endif",
            "      if (tcp_check(tcp, pktend - payload, ip->saddr, ip->daddr,",
            "          csum_partial(payload, pktend - payload, ~tcp->check)) != tcp->check) {",
            "#ifdef SF_DEBUG_CSUM",
            "        printk(\"sf: tcp: wrong checksum (hdr = %04hx)\\n\", tcp->check);",
            "#endif",
            "        return FW_BLOCK;",
            "      }",
            "    /* --- end test checksum --- */",
            "    /* --- check sequence numbers --- */",
            "    if (sftcp->check_sequence) {",
            "      if (!tcp->syn) {",
            "        if (!reverse) {",
            "          /* OK = client_seq <= end_seq <= client_seq+server_win */",
            "          if (between(end_seq, sftcp->client_seq-1, ",
            "              sftcp->client_seq + (sftcp->server_win << sftcp->server_scale))) {",
            "            sequence_ok++;",
            "            sftcp->client_win = window;",
            "          }",
            "#ifdef SF_DEBUG_SEQ",
            "          else",
            "            printk(\"client_seq %u end_seq %u server_win %u client_win %u\\n\", ",
            "                   sftcp->client_seq, end_seq, ",
            "                   sftcp->server_win << sftcp->server_scale, ",
            "                   sftcp->client_win << sftcp->client_scale);",
            "#endif",
            "        }",
            "        else {",
            "          /* OK = server_seq <= end_seq <= server_seq+client_win */",
            "          if (between(end_seq, sftcp->server_seq-1,",
            "              sftcp->server_seq + (sftcp->client_win << sftcp->client_scale))) {",
            "            sequence_ok++;",
            "            sftcp->server_win = window;",
            "          }",
            "#ifdef SF_DEBUG_SEQ",
            "          else",
            "            printk(\"server_seq %u end_seq %u client_win %u server_win %u\\n\", ",
            "                   sftcp->server_seq, end_seq, ",
            "                   sftcp->client_win << sftcp->client_scale, ",
            "                   sftcp->server_win << sftcp->server_scale);",
            "#endif",
            "        }",
            "        if (sftcp->state >= SF_TCP_ESTABLISHED3 && sequence_ok && tcp->ack) {",
            "          /* update minimum sequence number */",
            "          if (!reverse) {",
            "            if (after(ack_seq, sftcp->server_seq-1))",
            "              sftcp->server_seq = ack_seq;",
            "#ifdef SF_DEBUG_SEQ",
            "            else",
            "              printk(\"server_seq %u ack_seq %u client_win %u server_win %u\\n\", ",
            "                     sftcp->server_seq, ack_seq, ",
            "                     sftcp->client_win << sftcp->client_scale, ",
            "                     sftcp->server_win << sftcp->server_scale);",
            "#endif",
            "          }",
            "          else {",
            "            if (after(ack_seq, sftcp->client_seq-1))",
            "              sftcp->client_seq = ack_seq;",
            "#ifdef SF_DEBUG_SEQ",
            "            else",
            "              printk(\"client_seq %u ack_seq %u server_win %u client_win %u\\n\", ",
            "                     sftcp->client_seq, ack_seq, ",
            "                     sftcp->server_win << sftcp->server_scale, ",
            "                     sftcp->client_win << sftcp->client_scale);",
            "#endif",
            "          }",
            "        }",
            "      } /* end !syn */",
            "    }",
            "    else /* ignore sequence numbers */",
            "      sequence_ok++;",
            "    /* --- end check sequence numbers --- */",
            "    /* --- simple packets: no fin, no rst --- */",
            "    if (!tcp->fin && !tcp->rst) {",
            "      /* --- default case goes first --- */",
            "      if (sftcp->state == SF_TCP_ESTABLISHED3) {",
            "        /* This branch also catches SYN packets on an established connection. */",
            "#ifdef SF_DEBUG_SEQ",
            "        /* Wrong sequence numbers most likely result from resent packets */",
            "        if (!sequence_ok)",
            "          printk(\"sf: tcp: wrong sequence number [default]\\n\");",
            "#endif",
            "        check_for_fragment(ip);\t\t/* check if packet is fragmented */",
            "        return FW_ACCEPT;\t\t/* packet is allowed */",
            "      } ",
            "      /* --- end default case --- */",
            "      /* --- filter FTP --- */",
            "      if (sftcp->state == SF_TCP_ESTABLISHEDFTP && sequence_ok) {",
            "        if (!reverse) {",
            "\t  /* FTP packet from client to server */",
            "#ifdef SF_DEBUG_FTP",
            "\t  char cmd[80];",
            "\t  char *p;",
            "\t  int cmdlen;",
            "\t  p = (char *) memscan(tcpdata, '\\r', pktend - tcpdata);",
            "\t  cmdlen = (p < pktend) ? p - tcpdata : 0;",
            "\t  if (cmdlen > 0) {",
            "\t    strncpy(cmd, tcpdata, cmdlen);",
            "\t    cmd[cmdlen] = 0;",
            "\t    printk(\"sf ftp: c->s: %s\\n\", cmd);",
            "\t  }",
            "#endif",
            "\t  /* Format of port command is \"PORT n1,n2,n3,n4,n5,n6\"",
            "\t     where n1.n2.n3.n4 is the IP address ",
            "\t     and n5*256+n6 is the port number.",
            "\t     Convert the string into numbers */",
            "\t  if ((sftcp->ftp_allow_active) &&",
            "              (pktend - tcpdata > 15) && ",
            "              (strncmp(tcpdata, \"PORT \", 5) == 0)) {",
            "\t    int i;",
            "\t    __u16 ftpport = 0;",
            "\t    struct sf_tcp_connection *sfftp = NULL;",
            "            char *ftpdata = tcpdata + 5;",
            "\t    /* Skip the IP address and use the packet source address",
            "\t       instead. So it is not possible to redirect the data ",
            "\t       connection to another host. */",
            "\t    for (i = 0; i < 4; i++) {",
            "\t      while (ftpdata < pktend && *ftpdata != ',')",
            "\t        ftpdata += 1;",
            "\t      ftpdata += 1;",
            "\t    }",
            "\t    /* convert port number */",
            "\t    for (i = 0; i < 2; i++) {",
            "\t      int j = 0;",
            "\t      ftpport <<= 8;",
            "\t      while (ftpdata < pktend && *ftpdata >= '0' && *ftpdata <= '9') {",
            "\t        j = j * 10 + *ftpdata - '0';",
            "\t        ftpdata += 1;",
            "\t      }",
            "\t      ftpdata += 1;",
            "\t      ftpport += (__u16) j;",
            "\t    }",
            "\t    if (((ftpport >= 1024) && (ftpport < 6000)) || (ftpport > 6100)) {",
            "#ifdef SF_DEBUG_FTP",
            "\t      printk(\"sf ftp: accepting active port \"); PRINTIP(ip->saddr);",
            "\t      printk(\":%u\\n\", ftpport);",
            "#endif",
            "\t      sfftp = sf_tcp_insert(ip->daddr, ip->saddr, htons(FTP_DATA_PORT), ",
            "                                  htons(ftpport), sftcp->rule, rif);",
            "              if (sfftp != NULL)",
            "                sfftp->log_open = sftcp->log_dxfer;",
            "            } /* end port >= 1024 and not X11 */",
            "\t    else {",
            "#ifdef SF_DEBUG_FTP",
            "\t      printk(\"sf ftp: rejecting active port \"); PRINTIP(ip->saddr);",
            "\t      printk(\":%u\\n\", ftpport);",
            "#endif",
            "              /* Store ftpport so that a meaningful log message can be ",
            "                 generated (\"FTP: block TCP from dest:ftpdata to source:port\") */",
            "              rule->fw_rc       = htons(ftpport);",
            "              rule->rule_id.num = RULE_REJECT_FTP;",
            "              returncode        = FW_ACCEPT;",
            "              goto informlog;",
            "            }",
            "\t  } /* end PORT command detected */ ",
            "        }",
            "        else { /* reverse */",
            "\t  /* FTP packet from server to client */",
            "#ifdef SF_DEBUG_FTP",
            "\t  char cmd[80];",
            "\t  char *p;",
            "\t  int cmdlen;",
            "\t  p = (char *) memscan(tcpdata, '\\r', pktend - tcpdata);",
            "\t  cmdlen = (p < pktend) ? p - tcpdata : 0;",
            "\t  if (cmdlen > 0) {",
            "\t    strncpy(cmd, tcpdata, cmdlen);",
            "\t    cmd[cmdlen] = 0;",
            "\t    printk(\"sf ftp: s->c: %s\\n\", cmd);",
            "\t  }",
            "#endif",
            "\t  /* Format of passive reply is \"227 blah (n1,n2,n3,n4,n5,n6)\" ",
            "\t     where the parantheses are optional, n1.n2.n3.n4 is the ",
            "\t     IP address and n5*256+n6 is the port number. */",
            "\t  if ((sftcp->ftp_allow_passive) &&",
            "              (pktend - tcpdata > 14) && ",
            "              (strncmp(tcpdata, \"227 \", 4) == 0)) {",
            "\t    int i;",
            "\t    __u16 ftpport = 0;",
            "\t    struct sf_tcp_connection *sfftp = NULL;",
            "            char *ftpdata = tcpdata + 5;",
            "\t    /* Skip the IP address and use the packet source address",
            "\t       instead. So it is not possible to redirect the data ",
            "\t       connection to another host. */",
            "\t    for (i = 0; i < 4; i++) {",
            "\t      while (ftpdata < pktend && *ftpdata != ',')",
            "\t        ftpdata++;",
            "\t      ftpdata++;",
            "\t    }",
            "\t    /* convert port number */",
            "\t    for (i = 0; i < 2; i++) {",
            "\t      int j = 0;",
            "\t      ftpport <<= 8;",
            "\t      while (ftpdata < pktend && *ftpdata >= '0' && *ftpdata <= '9') {",
            "\t        j = j * 10 + *ftpdata - '0';",
            "\t        ftpdata++;",
            "\t      }",
            "\t      ftpdata++;",
            "\t      ftpport += (__u16) j;",
            "\t    }",
            "#ifdef SF_DEBUG_FTP",
            "\t    printk(\"sf ftp: accepting passive port \"); PRINTIP(ip->daddr);",
            "\t    printk(\":%u\\n\", ftpport);",
            "#endif",
            "\t    sfftp = sf_tcp_insert(ip->daddr, ip->saddr, 0, htons(ftpport), sftcp->rule, rif);",
            "\t    if (sfftp != NULL) {",
            "              sfftp->allpsource = 1;",
            "              sfftp->log_open = sftcp->log_dxfer;",
            "            }",
            "\t  } /* end passive 227 reply detected */",
            "        }",
            "        check_for_fragment(ip);\t/* check if packet is fragmented */",
            "        return FW_ACCEPT;\t/* packet is allowed */",
            "      }",
            "      /* --- end FTP filter --- */",
            "      /* --- this is similar to the default case, but more options --- */",
            "      if (sftcp->state >= SF_TCP_ESTABLISHED3) {",
            "#ifdef SF_DEBUG_SEQ",
            "        if (!sequence_ok)",
            "          printk(\"sf: tcp: wrong sequence number [extra]\\n\");",
            "#endif",
            "        if (sftcp->state > SF_TCP_ESTABLISHEDFTP &&",
            "            sftcp->state < SF_TCP_TERMINATED) {",
            "          /* support half close: reset timeout */",
            "          set_tcp_timer(sftcp, SF_TCP_HALFCLOSE);",
            "#ifdef SF_DEBUG_TCP",
            "\t  printk(\"sf: tcp: data in half close, resetting timeout\\n\");",
            "#endif",
            "        }",
            "        check_for_fragment(ip);\t/* check if packet is fragmented */",
            "        return FW_ACCEPT;\t/* packet is allowed */",
            "      }",
            "      /* --- end more options in state >= ESTABLISHED3 --- */",
            "      /* --- ACK to complete 3-way handshake --- */",
            "      if (sftcp->state == SF_TCP_SYN_ACK && !reverse) {",
            "        /* We are waiting for ACK to complete 3-way handshake */",
            "        if (sftcp->check_sequence) {",
            "#ifdef SF_DEBUG_SEQ",
            "          if (!sequence_ok)",
            "            printk(\"sf: tcp: wrong sequence number [3-way-ack]\\n\");",
            "#endif",
            "          if (ack_seq-1 == sftcp->server_seq)",
            "            sftcp->server_seq++;",
            "          else {",
            "#ifdef SF_DEBUG_SEQ",
            "            if (!sequence_ok)",
            "              printk(\"Are we guessing sequence numbers!?\\n\");",
            "            printk(\"server_seq %u ack_seq %u server_win %u client_win %u\\n\", ",
            "                    sftcp->server_seq, ack_seq, ",
            "                    sftcp->server_win << sftcp->server_scale, ",
            "                    sftcp->client_win << sftcp->client_scale);",
            "#endif",
            "            return FW_BLOCK;",
            "          }",
            "        }",
            "        sftcp->state = SF_TCP_ESTABLISHED3;",
            "        if (sftcp->server_port == htons(FTP_CONTROL_PORT))",
            "          sftcp->state = SF_TCP_ESTABLISHEDFTP;",
            "        del_timer(&sftcp->timer);",
            "        sftcp->timer_set = 0;",
            "        check_for_fragment(ip);",
            "        return FW_ACCEPT;",
            "      }",
            "      /* --- end ACK to complete 3-way handshake --- */",
            "      /* --- SYN: initiate new connection or step 2 in handshake --- */",
            "      if (tcp->syn) {",
            "        int opt_scale = -1; /* TCP window scaling option */",
            "        char *tcpopt;",
            "        if (sftcp->state >= SF_TCP_TERMINATED) {\t",
            "          /* Somebody is trying to establish a connection that is still in the ",
            "             2 MSL wait state. This should not happen if the TCP protocol is ",
            "             implemented correctly. But if it happens nevertheless, we must ",
            "             not allow the connection without checking the rules. ",
            "             See also: RFC 1185 */",
            "          if (sftcp->check_sequence && ",
            "              (!after(end_seq, reverse ? sftcp->server_seq : sftcp->client_seq)))",
            "            return FW_BLOCK;",
            "#ifdef SF_DEBUG_TCP",
            "\t  printk(\"sf: tcp: SYN && SF_TCP_TERMINATED\\n\");",
            "#endif",
            "\t  sf_tcp_delete(sftcp);",
            "          sftcp = NULL;",
            "          goto checkrules;",
            "        }",
            "        if (sftcp->check_sequence) {",
            "          /* parse TCP options */",
            "          tcpopt = payload + sizeof(struct tcphdr);",
            "          while (tcpopt < tcpdata && *tcpopt) {",
            "            if (*tcpopt == 1)",
            "              tcpopt++;",
            "            else {",
            "              int len = *(tcpopt+1);",
            "#ifdef SF_TCP_DEBUG_TCPOPT",
            "              printk(\"sf: tcp: option kind=%i, len=%i\\n\", *tcpopt, len);",
            "#endif",
            "              if (*tcpopt == 3 && len == 3)",
            "                opt_scale = *(tcpopt+2);",
            "              tcpopt += len;",
            "            }",
            "          } /* end parse options */",
            "        } /* check_sequence */",
            "        /* this should allow simultaneous opens */",
            "        if (!reverse) {",
            "          if (sftcp->state < SF_TCP_SYN_ACK) {",
            "#ifdef SF_DEBUG_TCP",
            "\t    printk(\"sf: tcp: client %ssent SYN\\n\",",
            "                   sftcp->state == SF_TCP_CLIENT_SYN ? \"re\" : \"\");",
            "#endif",
            "            if (sftcp->check_sequence) {",
            "\t      /* set initial sequence/window numbers for client */",
            "              sftcp->client_seq = ntohl(tcp->seq);",
            "              sftcp->client_win = window;",
            "              if (opt_scale != -1)",
            "                sftcp->client_scale = opt_scale;",
            "            }",
            "            set_tcp_timer(sftcp, SF_TCP_SYN_TO);",
            "            check_for_fragment(ip);\t/* check if packet is fragmented */",
            "            if (sftcp->state == SF_TCP_CLIENT_SYN)",
            "              return FW_ACCEPT;",
            "\t    sftcp->state = SF_TCP_CLIENT_SYN;",
            "            ",
            "            if (!sftcp->log_open) ",
            "              return FW_ACCEPT;",
            "            else {",
            "              returncode  =",
            "              rule->fw_rc = FW_ACCEPT;",
            "              goto informlog;",
            "            }",
            "          } /* end state < SYN_ACK */",
            "          else { ",
            "            /* \"Again!?\" [Andie McDowell as Dougs wife in the movie Multiplicity]",
            "               --- We KNOW the server got the SYN, because we have seen the",
            "               corresponding SYN ACK. No reason to accept this SYN! */",
            "            return FW_BLOCK;",
            "          }",
            "        } /* end !reverse */",
            "        else { /* is reverse */",
            "          if (sftcp->state < SF_TCP_SYN_ACK) {",
            "#ifdef SF_DEBUG_TCP",
            "\t    printk(\"sf: tcp: connection established\\n\");",
            "#endif",
            "            if (!sftcp->check_sequence || (ack_seq-1 == sftcp->client_seq) ",
            "                || !tcp->ack) {",
            "              /* first valid SYN ACK ever */",
            "\t      sftcp->state = SF_TCP_SYN_ACK;",
            "              if (sftcp->check_sequence) {",
            "                if (tcp->ack) /* simultaneous open kludge */",
            "                  sftcp->client_seq++;",
            "                /* set initial sequence number for server */",
            "                sftcp->server_seq = ntohl(tcp->seq);",
            "                sftcp->server_win = window;",
            "                if (opt_scale != -1)",
            "                  sftcp->server_scale = opt_scale;",
            "                else",
            "                  sftcp->client_scale = 0;",
            "              }",
            "              /* defend against SYN flooding */",
            "              if (!sf_inside(ip->saddr))",
            "                set_tcp_timer(sftcp, SF_TCP_SYN_TO);",
            "              else {",
            "                /* fabricate ACK for this SYN ACK and send it inside */",
            "\t        send_tcp(0, rif, ip, tcp);",
            "                /* set timer to kill connection if not established */",
            "                set_tcp_rst_timer(sftcp, SF_TCP_SYN_TO);",
            "              }",
            "              check_for_fragment(ip);\t/* check if packet is fragmented */",
            "              return FW_ACCEPT;",
            "            } /* end valid SYN ACK */",
            "            else {",
            "#ifdef SF_DEBUG_SEQ",
            "              printk(\"Sequence number of SYN ACK does not match!\\n\");",
            "              printk(\"client_seq = %u ack_seq = %u\\n\", sftcp->client_seq, ack_seq);",
            "#endif",
            "              return FW_BLOCK;",
            "            } /* end invalid SYN ACK */",
            "          } /* end state < SYN_ACK */",
            "          else {",
            "            /* We are in SYN_ACK state (>= ESTABLISHED was caught above) */",
            "            if (sftcp->check_sequence && (ack_seq != sftcp->client_seq)) {",
            "#ifdef SF_DEBUG_SEQ",
            "              printk(\"Sequence number of resent SYN ACK does not match!\\n\");",
            "              printk(\"client_seq = %u ack_seq = %u\\n\", sftcp->client_seq, ack_seq);",
            "#endif",
            "              return FW_BLOCK;",
            "            }",
            "          } /* end SYN_ACK state */",
            "        } /* end reverse */",
            "        set_tcp_timer(sftcp, SF_TCP_SYN_TO);",
            "        check_for_fragment(ip);\t/* check if packet is fragmented */",
            "        return FW_ACCEPT;",
            "      }",
            "      /* --- end syn --- */",
            "    }",
            "    /* --- end simple packets, !rst && !fin --- */",
            "    /* --- fin packets --- */",
            "    if (tcp->fin) {",
            "      if (!sequence_ok) {",
            "#ifdef SF_DEBUG_SEQ",
            "        if (( reverse && (sftcp->state & SF_TCP_SERVER_FIN) == 0) ||",
            "            (!reverse && (sftcp->state & SF_TCP_CLIENT_FIN) == 0))",
            "          printk(\"sf: tcp: wrong sequence number [fin]!\\n\");",
            "#endif",
            "        /* else we don't klog it: it doesn't matter, we are already in ",
            "           the FIN state (but block it anyway) */",
            "        return FW_BLOCK;",
            "      }",
            "      /* Check for Kamikaze packets (also known as nastygrams, christmas",
            "         tree packets, lamp test segments). Block them, because we are ",
            "         neither Santa Claus nor J. Postel... [see RFC 1025 for explanation] */",
            "      if (tcp->syn || tcp->rst) {",
            "#ifdef SF_DEBUG_TCP",
            "        printk(\"sf: tcp: Kamikaze packet detected\\n\");",
            "#endif",
            "        return FW_BLOCK;",
            "      }",
            "      sftcp->state |= reverse ? SF_TCP_SERVER_FIN : SF_TCP_CLIENT_FIN;",
            "      if (sftcp->state < SF_TCP_TERMINATED) {",
            "        /* Single FIN received. Since RFCs 793/1122",
            "           only state we MAY support half close and SHOULD send a reset",
            "           if the connection is closed, we DO support half close but set",
            "           a timeout. Otherwise we might have a half dead/closed connection ",
            "           forever. Make sure the timeout is long enough, however. ",
            "           To support half close, we keep resetting the timeout (see above) */",
            "        set_tcp_timer(sftcp, SF_TCP_HALFCLOSE);",
            "#ifdef SF_DEBUG_TCP",
            "\tprintk(\"sf: tcp: connection terminating\\n\");",
            "#endif",
            "      }",
            "      else { ",
            "        /* both FINs received, let final ACKs pass */",
            "        set_tcp_timer(sftcp, SF_TCP_FIN_WAIT);",
            "#ifdef SF_DEBUG_TCP",
            "\tprintk(\"sf: tcp: connection properly terminated\\n\");",
            "#endif",
            "      }",
            "      check_for_fragment(ip);\t/* check if packet is fragmented */",
            "      return FW_ACCEPT;",
            "    }",
            "    /* --- end fin packets --- */",
            "    /* --- rst packets --- */",
            "    if (tcp->rst) {",
            "      if (!sequence_ok) {",
            "        /* We are not going to close a connection if you cannot even",
            "           guess the sequence number... */",
            "#ifdef SF_DEBUG_SEQ",
            "        printk(\"sf: tcp: wrong sequence number [rst]!\\n\");",
            "#endif",
            "        return FW_BLOCK;",
            "      }",
            "      /* Kamikaze check (see above for fin|rst) */",
            "      if (tcp->syn) {",
            "#ifdef SF_DEBUG_TCP",
            "        printk(\"sf: tcp: Kamikaze packet detected\\n\");",
            "#endif",
            "        return FW_BLOCK;",
            "      }",
            "      sf_tcp_delete(sftcp);\t/* RST aborts an connection immediately */",
            "      check_for_fragment(ip);\t/* check if packet is fragmented */",
            "      return FW_ACCEPT;",
            "    } ",
            "    /* --- end rst packets --- */",
            "    /* Only packets with !SYN, !FIN, !RST that belong to connections",
            "       with state < SF_TCP_ESTABLISHED3 can arrive here. */",
            "    /* This should never happen - but it does happen, e.g. when",
            "       one side thinks the connection is still established and",
            "       the other side tries to establish a new connection to the",
            "       same port numbers. This can also happen if the connection",
            "       has died on one end only (e.g. rebooted PC). There's no",
            "       need to accept these strange packets, since the other",
            "       side of the connection will not accept them. */",
            "#ifdef SF_DEBUG_TCP",
            "    printk(\"sf: tcp: connection in strange state:\\n\");",
            "    if (reverse)  printk(\"s->c\"); else printk(\"c->s\");",
            "    if (tcp->syn) printk(\" SYN\");",
            "    if (tcp->fin) printk(\" FIN\");",
            "    if (tcp->ack) printk(\" ACK\");",
            "    if (tcp->rst) printk(\" RST\");",
            "    printk(\"\\n\");",
            "#endif",
            "    return FW_BLOCK;",
            "  /* --- end check tcp --- */",
            "checkrules:",
            "  /* --- check rules --- */",
            "    for (rule = prio_rules; rule != NULL; rule = rule->fw_next) {",
            "#ifdef SF_DEBUG_RULES",
            "      printk(\"sf: rule %li, flags %lx, prot %i\\n\", ",
            "             rule->rule_id.num, rule->fw_flags, rule->protocol);",
            "#endif",
            "      /* check if protocols match */",
            "      if ((rule->fw_flags & SF_FW_PROT) != SF_FW_PROT_ALL) {",
            "\tif ((rule->fw_flags & SF_FW_PROT) == SF_FW_CHECK_PROTOCOL) {",
            "\t  unsigned long flg = rule->fw_flags & SF_TYPE_MASK;",
            "\t  if (rule->protocol != ip->protocol)",
            "\t    continue;",
            "\t  switch (ip->protocol) {",
            "\t    case IPPROTO_ICMP:",
            "\t      if (flg == SF_ICMP_ALLTYPES)",
            "\t\tbreak;",
            "\t      switch (icmp->type) {\t/* filter msg type */",
            "\t\tcase ICMP_ECHOREPLY:",
            "\t\t  if (!(flg & SF_ICMP_ECHOREPLY))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_DEST_UNREACH:",
            "\t\t  if (!(flg & SF_ICMP_DEST_UNREACH))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_SOURCE_QUENCH:",
            "\t\t  if (!(flg & SF_ICMP_SOURCE_QUENCH))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_REDIRECT:",
            "\t\t  if (!(flg & SF_ICMP_REDIRECT))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_ECHO:",
            "\t\t  if (!(flg & SF_ICMP_ECHO))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_TIME_EXCEEDED:",
            "\t\t  if (!(flg & SF_ICMP_TIME_EXCEEDED))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_PARAMETERPROB:",
            "\t\t  if (!(flg & SF_ICMP_PARAMETERPROB))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_TIMESTAMP:",
            "\t\t  if (!(flg & SF_ICMP_TIMESTAMP))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_TIMESTAMPREPLY:",
            "\t\t  if (!(flg & SF_ICMP_TIMESTAMPREPLY))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_INFO_REQUEST:",
            "\t\t  if (!(flg & SF_ICMP_INFO_REQUEST))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_INFO_REPLY:",
            "\t\t  if (!(flg & SF_ICMP_INFO_REPLY))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_ADDRESS:",
            "\t\t  if (!(flg & SF_ICMP_ADDRESS))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase ICMP_ADDRESSREPLY:",
            "\t\t  if (!(flg & SF_ICMP_ADDRESSREPLY))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tdefault:",
            "\t\t  continue;",
            "\t      }",
            "\t      break;",
            "\t    case IPPROTO_IGMP:",
            "\t      if (flg == SF_IGMP_ALLTYPES)",
            "\t\tbreak;",
            "\t      switch (igmp->type) {\t/* filter msg type */",
            "\t\tcase IGMP_HOST_MEMBERSHIP_QUERY:",
            "\t\t  if (!(flg & IGMP_HOST_MEMBERSHIP_QUERY))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase IGMP_HOST_MEMBERSHIP_REPORT:",
            "\t\t  if (!(flg & SF_IGMP_HOST_MEMBERSHIP_REPORT))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tcase IGMP_HOST_LEAVE_MESSAGE:",
            "\t\t  if (!(flg & IGMP_HOST_LEAVE_MESSAGE))",
            "\t\t    continue;",
            "\t\t  break;",
            "\t\tdefault:",
            "\t\t  continue;",
            "\t      }",
            "\t      break;",
            "Thread failed: %d",
            "WSAStartup failed: %d",
            "Send Packets",
            "0.0.0.0",
            "set TimeOut failed: %d",
            "set IP_HDRINCL failed: %d",
            "socket failed: %d",
            "Error: File not found!",
            "iplist.txt",
            "  %s 192.168.0.1 80 170 2000",
            "  %s 192.168.0.1 80 170 ",
            "  %s 192.168.0.1 80",
            "  %s 192.168.0.1",
            "EXAMPLE:",
            "  %s DestIP [DestPort] [TcpServerPort] [TimeOut]",
            "USAGE:",
            "|  http://www.safechina.net   |",
            "|                             |",
            "|  DRD.O.S Tool v0.3          |",
            "+-----------------------------+",
            "  Timeout: %d",
            "  TCP Server Port: %d",
            "  Target Port: %d",
            "  Target: %s",
            "<------------------------>",
            "format != NULL",
            "fprintf.c",
            "str != NULL",
            "_file.c",
            "i386\\chkesp.c",
            "The value of ESP was not properly saved across a function call.  This is usually a result of calling a function declared with one calling convention with a function pointer declared with a different calling convention. ",
            "rewind.c",
            "fgetc.c",
            "stream != NULL",
            "printf.c",
            "*mode != _T('\\0')",
            "mode != NULL",
            "*file != _T('\\0')",
            "fopen.c",
            "file != NULL",
            "_sftbuf.c",
            "flag == 0 || flag == 1",
            " (8PX",
            "700WP",
            "`h````",
            "ppxxxx",
            "(null)",
            "output.c",
            "ch != _T('\\0')",
            "Assertion Failed",
            "Error",
            "Warning",
            "%s(%d) : %s",
            "Assertion failed!",
            "Assertion failed: ",
            "_CrtDbgReport: String too long or IO Error",
            "Second Chance Assertion Failed: File %s, Line %d",
            "wsprintfA",
            "user32.dll",
            "Microsoft Visual C++ Debug Library",
            "Debug %s!",
            "Program: %s%s%s%s%s%s%s%s%s%s%s",
            "(Press Retry to debug the application)",
            "Module: ",
            "File: ",
            "Line: ",
            "Expression: ",
            "For information on how your program can cause an assertion",
            "failure, see the Visual C++ documentation on asserts.",
            "<program name unknown>",
            "dbgrpt.c",
            "szUserMessage != NULL",
            "ioinit.c",
            "Client",
            "Ignore",
            "Normal",
            "Free",
            "Error: memory allocation: bad memory block type.",
            "Invalid allocation size: %u bytes.",
            "Client hook allocation failure.",
            "Client hook allocation failure at file %hs line %d.",
            "dbgheap.c",
            "_CrtCheckMemory()",
            "_pFirstBlock == pOldBlock",
            "_pLastBlock == pOldBlock",
            "fRealloc || (!fRealloc && pNewBlock == pOldBlock)",
            "_BLOCK_TYPE(pOldBlock->nBlockUse)==_BLOCK_TYPE(nBlockUse)",
            "pOldBlock->nLine == IGNORE_LINE && pOldBlock->lRequest == IGNORE_REQ",
            "_CrtIsValidHeapPointer(pUserData)",
            "Allocation too large or negative: %u bytes.",
            "Client hook re-allocation failure.",
            "Client hook re-allocation failure at file %hs line %d.",
            "_pFirstBlock == pHead",
            "_pLastBlock == pHead",
            "pHead->nBlockUse == nBlockUse",
            "pHead->nLine == IGNORE_LINE && pHead->lRequest == IGNORE_REQ",
            "DAMAGE: after %hs block (#%d) at 0x%08X.",
            "DAMAGE: before %hs block (#%d) at 0x%08X.",
            "_BLOCK_TYPE_IS_VALID(pHead->nBlockUse)",
            "Client hook free failure.",
            "memory check error at 0x%08X = 0x%02X, should be 0x%02X.",
            "%hs located at 0x%08X is %u bytes long.",
            "%hs allocated at file %hs(%d).",
            "DAMAGE: on top of Free block at 0x%08X.",
            "DAMAGED",
            "_heapchk fails with unknown return value!",
            "_heapchk fails with _HEAPBADPTR.",
            "_heapchk fails with _HEAPBADEND.",
            "_heapchk fails with _HEAPBADNODE.",
            "_heapchk fails with _HEAPBADBEGIN.",
            "Bad memory block found at 0x%08X.",
            "_CrtMemCheckPoint: NULL state pointer.",
            "_CrtMemDifference: NULL state pointer.",
            "Object dump complete.",
            "crt block at 0x%08X, subtype %x, %u bytes long.",
            "normal block at 0x%08X, %u bytes long.",
            "client block at 0x%08X, subtype %x, %u bytes long.",
            "{%ld} ",
            "%hs(%d) : ",
            "#File Error#(%d) : ",
            "Dumping objects ->",
            " Data: <%s> %s",
            "%.2X ",
            "Detected memory leaks!",
            "Total allocations: %ld bytes.",
            "Largest number used: %ld bytes.",
            "%ld bytes in %ld %hs Blocks.",
            "_filbuf.c",
            "_open.c",
            "filename != NULL",
            "stream.c",
            "stdenvp.c",
            "stdargv.c",
            "a_env.c",
            "runtime error ",
            "TLOSS error",
            "SING error",
            "DOMAIN error",
            "R6028",
            "- unable to initialize heap",
            "R6027",
            "- not enough space for lowio initialization",
            "R6026",
            "- not enough space for stdio initialization",
            "R6025",
            "- pure virtual function call",
            "R6024",
            "- not enough space for _onexit/atexit table",
            "R6019",
            "- unable to open console device",
            "R6018",
            "- unexpected heap error",
            "R6017",
            "- unexpected multithread lock error",
            "R6016",
            "- not enough space for thread data",
            "abnormal program termination",
            "R6009",
            "- not enough space for environment",
            "R6008",
            "- not enough space for arguments",
            "R6002",
            "- floating point not loaded",
            "Microsoft Visual C++ Runtime Library",
            "Runtime Error!",
            "Program: ",
            "(\"inconsistent IOB fields\", stream->_ptr - stream->_base >= 0)",
            "_flsbuf.c",
            "sprintf.c",
            "string != NULL",
            "vsprintf.c",
            "GetLastActivePopup",
            "GetActiveWindow",
            "MessageBoxA",
            "fclose.c",
            "osfinfo.c",
            "_getbuf.c",
            "_freebuf.c",
            "chsize.c",
            "size >= 0",
            "KERNEL32.DLL",
            "WS2_32.dll",
            "TerminateProcess",
            "GetLastError",
            "GetCurrentProcess",
            "SetFilePointer",
            "LCMapStringA",
            "SetEndOfFile",
            "LCMapStringW",
            "GetACP",
            "GetCPInfo",
            "GetOEMCP",
            "CloseHandle",
            "GetStringTypeW",
            "RtlUnwind",
            "GetCommandLineA",
            "GetVersion",
            "DebugBreak",
            "GetStdHandle",
            "WriteFile",
            "InterlockedDecrement",
            "OutputDebugStringA",
            "GetProcAddress",
            "LoadLibraryA",
            "InterlockedIncrement",
            "GetModuleFileNameA",
            "SetHandleCount",
            "GetFileType",
            "GetStartupInfoA",
            "IsBadWritePtr",
            "IsBadReadPtr",
            "HeapValidate",
            "ExitProcess",
            "HeapFree",
            "CreateFileA",
            "UnhandledExceptionFilter",
            "FreeEnvironmentStringsA",
            "FreeEnvironmentStringsW",
            "WideCharToMultiByte",
            "GetEnvironmentStrings",
            "GetEnvironmentStringsW",
            "HeapDestroy",
            "HeapCreate",
            "VirtualAlloc",
            "VirtualFree",
            "SetConsoleCtrlHandler",
            "HeapAlloc",
            "HeapReAlloc",
            "FlushFileBuffers",
            "SetStdHandle",
            "ReadFile",
            "MultiByteToWideChar",
            "GetStringTypeA",
            "WSASocketA"
        ],
        "file": {
            "KERNEL32.DLL": "Library",
            "WS2_32.dll": "Library",
            "iplist.txt": "Text",
            "user32.dll": "Library"
        },
        "fuzzing": {},
        "ip": [
            "192.168.0.1"
        ],
        "url": [
            "http://www.ifi.unizh.ch/ikm/SINUS/",
            "http://www.safechina.net",
            "http://www.ifi.unizh.ch/ikm/SINUS/sf_faq.html",
            "http://www.ifi.unizh.ch/ikm/SINUS/firewall.html"
        ]
    },
    "time": "0:00:00.987071",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": [
        {
            "packer_compiler_signatures.yar": "IsPE32"
        },
        {
            "packer_compiler_signatures.yar": "IsConsole"
        },
        {
            "packer_compiler_signatures.yar": "HasRichSignature"
        }
    ]
}
